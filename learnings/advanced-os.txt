--BEGIN--12/03/2025--OPERATING SYSTEM--
1. Computer System Components
ð–¦¹ A computer system has four main parts: hardware, operating system, application programs, and user.
ð–¦¹ Hardware includes CPU, memory, storage, and input/output devices.
ð–¦¹ Operating system (OS) controls hardware and allows applications to run.
ð–¦¹ Users interact with the system through applications.
ð–¦¹ OS appearance differs by device: 
â€¢ Laptop/PC â†’ keyboard, mouse, screen
â€¢ Mobile â†’ touch or voice
â€¢ Embedded devices â†’ invisible, works silently
ð–¦¹ OS roles:
â€¢ Resource allocator â†’ manages CPU, memory, storage, devices
â€¢ Control program â†’ oversees program execution, prevents errors, manages device usage
ð–¦¹ Kernel: main program in memory, interacts directly with hardware.
ð–¦¹ System programs: file managers, command-line tools (not part of kernel).
ð–¦¹ Middleware: software frameworks aiding applications (graphics, multimedia, databases).
ð–¦¹ Modern OS like Android/iOS include kernel, system utilities, and middleware.

2. CPU and Device Controllers
ð–¦¹ Systems may have one or more CPUs; CPUs can be multi-core.
ð–¦¹ Device controllers manage devices like USB, graphics, keyboards, disks, network cards.
ð–¦¹ Components connect through a system bus and use main memory (RAM).
ð–¦¹ Controllers use RAM and DMA for data transfer without CPU involvement.
ð–¦¹ Controllers may manage multiple devices, have local buffers, and special registers (command, status, data).
ð–¦¹ CPU writes commands to registers; controller updates status.
ð–¦¹ Each controller has a device driver, software inside OS for uniform interface.
ð–¦¹ CPU and controllers run in parallel; memory controller coordinates RAM access.

3. Interrupts
ð–¦¹ Devices raise interrupts to signal CPU.
ð–¦¹ CPU checks for interrupts after each instruction, saves state, and uses interrupt vector table to find ISR.
ð–¦¹ ISR handles event, restores state, returns to program.
ð–¦¹ Interrupts can be maskable (temporarily disabled) or non-maskable (cannot be disabled).
ð–¦¹ Higher-priority interrupts can pre-empt lower-priority ones.
ð–¦¹ Multiple devices sharing a vector use interrupt chaining.

4. Storage and Memory
ð–¦¹ CPU executes programs only in main memory (RAM), which is fast but volatile.
ð–¦¹ EEPROM is non-volatile, used for firmware and boot code, slower to write.
ð–¦¹ Basic data units: bits, bytes, words (e.g., 64-bit word = 8 bytes).
ð–¦¹ Load transfers data from memory to registers; store transfers data back.
ð–¦¹ Larger non-volatile storage: SSDs, HDDs, optical disks, magnetic tapes.
ð–¦¹ Memory hierarchy (fastest â†’ slowest): registers â†’ cache â†’ RAM â†’ flash/SSD â†’ HDD â†’ tape.
ð–¦¹ Volatile memory loses data on power-off; non-volatile keeps data.

5. Computer System Organization
ð–¦¹ CPUs are main computation units.
ð–¦¹ Organization depends on number of CPUs for parallel execution.
ð–¦¹ More CPUs â†’ more parallel work â†’ higher performance.

    6. Single-Processor System
    ð–¦¹ CPU: 1 general-purpose CPU, single core executes instructions using registers.
    ð–¦¹ May have special-purpose processors (disk, keyboard, graphics controllers) running limited instructions.
    â€¢ Can work autonomously or managed by OS.
    â€¢ Example: Disk controller microprocessor â†’ handles disk queue & scheduling.
    â€¢ Example: Keyboard microprocessor â†’ converts keystrokes to codes.
    ð–¦¹ Only one general-purpose CPU executes main instructions.
    ð–¦¹ Remember: Single-processor system = 1 CPU, 1 core, may have extra small special-purpose processors.

    7. Multiprocessor System
    ð–¦¹ More than one CPU; each may be single-core or multi-core.
    ð–¦¹ Shared resources: system bus, memory, I/O devices, sometimes clock.
    ð–¦¹ Advantage: more work done in parallel â†’ higher throughput.
    ð–¦¹ Overhead: coordination and waiting for shared resources â†’ reduces efficiency.

        8. Symmetric Multiprocessing (SMP)
        ð–¦¹ Each CPU performs all tasks (OS + user processes).
        ð–¦¹ CPUs have own registers and local cache.
        ð–¦¹ Share physical memory.
        ð–¦¹ Multiple processes run simultaneously; uneven load may leave CPUs idle.
        ð–¦¹ Remember: SMP = multiple CPUs, each does everything, share memory.

        9. Multicore Processor
        ð–¦¹ Multiple cores on single CPU chip.
        ð–¦¹ Each core has its own registers; L1 cache per core; L2 cache shared.
        ð–¦¹ Advantage: faster on-chip communication, lower power consumption.
        ð–¦¹ Remember: Multicore = multiple cores inside one CPU, fast on-chip communication, shared L2 cache.

        10. NUMA (Non-Uniform Memory Access)
        ð–¦¹ Multiple CPUs/groups with local memory accessed via fast local bus.
        ð–¦¹ Share physical address space through system interconnect.
        ð–¦¹ Local memory â†’ fast; remote memory â†’ slower.
        ð–¦¹ OS reduces latency using smart CPU scheduling and memory management.
        ð–¦¹ Remember: NUMA = CPUs with fast local memory; remote memory slower â†’ non-uniform access.

    11. Blade Server
    ð–¦¹ Multiple processor, I/O, and networking boards in one chassis.
    ð–¦¹ Each board can boot independently and run its own OS.
    ð–¦¹ Some boards are multiprocessor â†’ independent multiprocessor systems inside chassis.
    ð–¦¹ Remember: Blade server = multiple independent computer boards in one chassis.

--END--
