--BEGIN--SSA: INTRODUCTION--30/11/2025
1. Definition of a Variable
ð–¦¹ A definition is any point where a variable is given a value.
ð–¦¹ Each assignment creates a new definition.
â€¢ Example:
- [green]x[/green] [blue]=[/blue] [yellow]5[/yellow];    [violet]// definition of x[/violet]
- [green]y[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]1[/yellow];  [violet]// definition of y (uses x)[/violet]
- [green]x[/green] [blue]=[/blue] [yellow]10[/yellow];   [violet]// new definition of x[/violet]

2. Use of a Variable
ð–¦¹ A use is any point where the value of a variable is read.
â€¢ Example:
- [green]y[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]1[/yellow];  [violet]// use of x[/violet]
- [green]z[/green] [blue]=[/blue] [green]y[/green] [blue]+[/blue] [yellow]2[/yellow];  [violet]// use of y[/violet]

3. Def-Use Chains
ð–¦¹ A def-use chain links a variable definition to all its uses that are not overwritten.
â€¢ Example:
- [green]x[/green] [blue]=[/blue] [yellow]5[/yellow];      [violet]// def1[/violet]
- [green]y[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]1[/yellow];  [violet]// use1 of def1[/violet]
- [green]x[/green] [blue]=[/blue] [yellow]10[/yellow];     [violet]// def2[/violet]
- [green]z[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]2[/yellow];  [violet]// use1 of def2[/violet]
ð–¦¹ Def-use chains:
â€¢ def1 ([green]x[/green]=5) â†’ use1 ([green]y[/green]=[green]x[/green]+1)
â€¢ def2 ([green]x[/green]=10) â†’ use1 ([green]z[/green]=[green]x[/green]+2)

4. Static Single Assignment (SSA) Form
ð–¦¹ SSA is a way of writing programs where each variable is assigned exactly once.
ð–¦¹ Every assignment creates a new version of the variable, usually with a subscript number.
ð–¦¹ SSA makes it easier for compilers to analyze and optimize code.

5. Example without SSA
[pink]x[/pink] [blue]=[/blue] [yellow]1[/yellow];
[pink]y[/pink] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]1[/yellow];  [violet]// y = 2[/violet]
[pink]x[/pink] [blue]=[/blue] [yellow]2[/yellow];
[pink]z[/pink] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]1[/yellow];  [violet]// z = 3[/violet]
ð–¦¹ Problem: The value of [green]x[/green] changes, so it's unclear which value to use when reading [green]x[/green].

6. Example in SSA Form
[pink]x1[/pink] [blue]=[/blue] [yellow]1[/yellow];
[pink]y[/pink] [blue]=[/blue] [green]x1[/green] [blue]+[/blue] [yellow]1[/yellow];  [violet]// y = 2[/violet]
[pink]x2[/pink] [blue]=[/blue] [yellow]2[/yellow];
[pink]z[/pink] [blue]=[/blue] [green]x2[/green] [blue]+[/blue] [yellow]1[/yellow];  [violet]// z = 3[/violet]
ð–¦¹ Benefit: Each variable version ([green]x1[/green], [green]x2[/green]) has only one definition.
ð–¦¹ Compiler can directly see the correct value to use for any variable.
ð–¦¹ SSA simplifies optimizations like constant propagation, dead code elimination, and alias analysis.

7. Constant Propagation
ð–¦¹ Goal: Replace variables with known constant values during compile time.
â€¢ Problem without SSA:
- [green]x[/green] [blue]=[/blue] [yellow]5[/yellow];
- [green]y[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]2[/yellow];
- [green]x[/green] [blue]=[/blue] [yellow]7[/yellow];
- [green]z[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]2[/yellow];
ð–¦¹ Problem: Multiple definitions make it hard to know which value to propagate.
â€¢ With SSA:
- [green]x1[/green] [blue]=[/blue] [yellow]5[/yellow];
- [green]y[/green] [blue]=[/blue] [green]x1[/green] [blue]+[/blue] [yellow]2[/yellow];
- [green]x2[/green] [blue]=[/blue] [yellow]7[/yellow];
- [green]z[/green] [blue]=[/blue] [green]x2[/green] [blue]+[/blue] [yellow]2[/yellow];
ð–¦¹ Benefit: Single definition per variable â†’ value propagation is clear and precise.

8. Dead Code Elimination (DCE)
ð–¦¹ Goal: Remove code whose results are never used.
â€¢ Problem without SSA:
- [green]x[/green] [blue]=[/blue] [yellow]5[/yellow];
- [green]y[/green] [blue]=[/blue] [yellow]10[/yellow];
- [green]z[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]2[/yellow];
- [pink]print[/pink]([green]z[/green]);
ð–¦¹ Problem: Multiple definitions make checking unused variables hard.
â€¢ With SSA:
- [green]x1[/green] [blue]=[/blue] [yellow]5[/yellow];
- [green]y1[/green] [blue]=[/blue] [yellow]10[/yellow];  [violet]// no uses[/violet]
- [green]z1[/green] [blue]=[/blue] [green]x1[/green] [blue]+[/blue] [yellow]2[/yellow];
- [pink]print[/pink]([green]z1[/green]);
ð–¦¹ Benefit: SSA makes it easy to detect unused variables.

9. Alias Analysis
ð–¦¹ Goal: Find if two variables might point to the same memory.
â€¢ Problem without SSA:
- [pink]int[/pink] *[green]p[/green] [blue]=[/blue] &[green]a[/green];
- [pink]int[/pink] *[green]q[/green] [blue]=[/blue] &[green]a[/green];
- *[green]p[/green] [blue]=[/blue] [yellow]5[/yellow];
- [pink]printf[/pink]("%d", *[green]q[/green]);
ð–¦¹ Problem: Compiler must track all definitions; multiple assignments make aliasing complex.
â€¢ With SSA:
ð–¦¹ Each SSA variable has a single unique definition.
ð–¦¹ Memory effects are easier to track; aliasing is clear.
ð–¦¹ Temporary SSA variables make reasoning about interference easier.
ð–¦¹ Benefit: Simplifies analysis and allows safer optimizations.
--END--
--BEGIN--PHI FUNCTION--30/11/2025
â €â €â €â €â €â €â €â£¤â£¶â£¶â£¶â£¶â£¶â£¶â£¶â£¶â£¶â£¶â£¤â €â €â €â €â €â €â €
â €â €â €â €â €â €â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â €â €â €â €â €â €
â €â €â €â €â €â €â €â ™â ›â ›â¢¿â£¿â£¿â£¿â£¿â¡¿â ›â ›â ‹â €â €â €â €â €â €â €
â €â €â €â €â €â¢€â£ â£¤â£´â£¶â£¾â£¿â£¿â£¿â£¿â£·â£¶â£¦â£¤â£„â¡€â €â €â €â €â €
â €â €â¢€â£¤â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â£¤â¡€â €â €
â €â£°â£¿â£¿â£¿â£¿â£¿â£¿â ¿â Ÿâ¢»â£¿â£¿â£¿â£¿â¡Ÿâ »â ¿â£¿â£¿â£¿â£¿â£¿â£¿â£†â €
â¢¸â£¿â£¿â£¿â£¿â Ÿâ ‰â €â €â €â¢¸â£¿â£¿â£¿â£¿â¡‡â €â €â €â ‰â »â£¿â£¿â£¿â£¿â¡‡
â£¿â£¿â£¿â£¿â£â €â €â €â €â €â¢¸â£¿â£¿â£¿â£¿â¡‡â €â €â €â €â €â£¹â£¿â£¿â£¿â£¿
â¢¸â£¿â£¿â£¿â£¿â£¦â£€â €â €â €â¢¸â£¿â£¿â£¿â£¿â¡‡â €â €â €â£€â£´â£¿â£¿â£¿â£¿â¡‡
â €â ¹â£¿â£¿â£¿â£¿â£¿â£¿â£¶â£¦â£¼â£¿â£¿â£¿â£¿â£§â£´â£¶â£¿â£¿â£¿â£¿â£¿â£¿â â €
â €â €â ˆâ ›â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â ›â â €â €
â €â €â €â €â €â ˆâ ™â ›â »â ¿â¢¿â£¿â£¿â£¿â£¿â¡¿â ¿â Ÿâ ›â ‹â â €â €â €â €â €
â €â €â €â €â €â €â €â£ â£¤â£¤â£¾â£¿â£¿â£¿â£¿â£·â£¤â£¤â£„â €â €â €â €â €â €â €
â €â €â €â €â €â €â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â €â €â €â €â €â €
â €â €â €â €â €â €â €â ›â ¿â ¿â ¿â ¿â ¿â ¿â ¿â ¿â ¿â ¿â ‹â €â €â €â €â €â €â €

1. Ï†-function (phi-function) in SSA
ð–¦¹ A Ï†-function is a pseudo-assignment used in SSA.
ð–¦¹ It merges values from different control-flow paths.
ð–¦¹ Acts like a selector to choose a value depending on which path was taken.
ð–¦¹ Occurs at control-flow merge points:
â€¢ After an if-else block
â€¢ At the start of a loop (loop header)
ð–¦¹ Keeps SSA property by creating a new variable for all possible values.
ð–¦¹ Syntax: [green]x3[/green] [blue]=[/blue] Ï†([green]x1[/green], [green]x2[/green])
â€¢ [green]x1[/green] â†’ value from one path
â€¢ [green]x2[/green] â†’ value from another path
â€¢ [green]x3[/green] â†’ new SSA variable after merge

2. LEVEL 1: Very Easy SSA Questions
ð–¦¹ Q1
Original:
[pink]a[/pink] [blue]=[/blue] [yellow]5[/yellow]
[pink]a[/pink] [blue]=[/blue] [green]a[/green] [blue]+[/blue] [yellow]2[/yellow]
[pink]a[/pink] [blue]=[/blue] [green]a[/green] [blue]+[/blue] [yellow]3[/yellow]
SSA Version:
[pink]a1[/pink] [blue]=[/blue] [yellow]5[/yellow]
[pink]a2[/pink] [blue]=[/blue] [green]a1[/green] [blue]+[/blue] [yellow]2[/yellow]
[pink]a3[/pink] [blue]=[/blue] [green]a2[/green] [blue]+[/blue] [yellow]3[/yellow]

ð–¦¹ Q2
Original:
[pink]x[/pink] [blue]=[/blue] [yellow]1[/yellow]
[pink]y[/pink] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]2[/yellow]
[pink]x[/pink] [blue]=[/blue] [green]y[/green] [blue]+[/blue] [yellow]3[/yellow]
SSA Version:
[pink]x1[/pink] [blue]=[/blue] [yellow]1[/yellow]
[pink]y1[/pink] [blue]=[/blue] [green]x1[/green] [blue]+[/blue] [yellow]2[/yellow]
[pink]x2[/pink] [blue]=[/blue] [green]y1[/green] [blue]+[/blue] [yellow]3[/yellow]

ð–¦¹ Q3
Original:
[pink]p[/pink] [blue]=[/blue] [yellow]10[/yellow]
[pink]q[/pink] [blue]=[/blue] [green]p[/green]
[pink]p[/pink] [blue]=[/blue] [green]q[/green] [blue]+[/blue] [yellow]4[/yellow]
SSA Version:
[pink]p1[/pink] [blue]=[/blue] [yellow]10[/yellow]
[pink]q1[/pink] [blue]=[/blue] [green]p1[/green]
[pink]p2[/pink] [blue]=[/blue] [green]q1[/green] [blue]+[/blue] [yellow]4[/yellow]

3. LEVEL 2 â€” Simple if-else SSA Questions
IMG_URL phi_in_if.png
ð–¦¹ Q4
Original:
[pink]x[/pink] [blue]=[/blue] [yellow]5[/yellow]
if ([green]x[/green] [blue]>[/blue] [yellow]3[/yellow]):
    [green]x[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]1[/yellow]
else:
    [green]x[/green] [blue]=[/blue] [green]x[/green] [blue]-[/blue] [yellow]1[/yellow]
print([green]x[/green])
SSA Version:
[pink]x1[/pink] [blue]=[/blue] [yellow]5[/yellow]
[pink]x2[/pink] [blue]=[/blue] [green]x1[/green] [blue]+[/blue] [yellow]1[/yellow]
[pink]x3[/pink] [blue]=[/blue] [green]x1[/green] [blue]-[/blue] [yellow]1[/yellow]
[pink]x4[/pink] [blue]=[/blue] Ï†([green]x2[/green], [green]x3[/green])
print([green]x4[/green])

ð–¦¹ Q5
Original:
[pink]a[/pink] [blue]=[/blue] [yellow]0[/yellow]
if ([green]a[/green] [blue]==[/blue] [yellow]0[/yellow]):
    [pink]b[/pink] [blue]=[/blue] [yellow]1[/yellow]
else:
    [pink]b[/pink] [blue]=[/blue] [yellow]2[/yellow]
[pink]c[/pink] [blue]=[/blue] [green]b[/green] [blue]+[/blue] [yellow]3[/yellow]
SSA Version:
[pink]a1[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]b1[/pink] [blue]=[/blue] [yellow]1[/yellow]  # if branch
[pink]b2[/pink] [blue]=[/blue] [yellow]2[/yellow]  # else branch
[pink]b3[/pink] [blue]=[/blue] Ï†([green]b1[/green], [green]b2[/green])
[pink]c1[/pink] [blue]=[/blue] [green]b3[/green] [blue]+[/blue] [yellow]3[/yellow]

ð–¦¹ Q6
Original:
[pink]m[/pink] [blue]=[/blue] [yellow]4[/yellow]
[pink]n[/pink] [blue]=[/blue] [yellow]6[/yellow]
if ([green]m[/green] [blue]<[/blue] [green]n[/green]):
    [green]m[/green] [blue]=[/blue] [green]n[/green]
else:
    [green]n[/green] [blue]=[/blue] [green]m[/green]
[pink]k[/pink] [blue]=[/blue] [green]m[/green] [blue]+[/blue] [green]n[/green]
SSA Version:
[pink]m1[/pink] [blue]=[/blue] [yellow]4[/yellow]
[pink]n1[/pink] [blue]=[/blue] [yellow]6[/yellow]
[pink]m2[/pink] [blue]=[/blue] [green]n1[/green]  # if branch
[pink]n2[/pink] [blue]=[/blue] [green]m1[/green]  # else branch
[pink]m3[/pink] [blue]=[/blue] Ï†([green]m1[/green], [green]m2[/green])
[pink]n3[/pink] [blue]=[/blue] Ï†([green]n1[/green], [green]n2[/green])
[pink]k1[/pink] [blue]=[/blue] [green]m3[/green] [blue]+[/blue] [green]n3[/green]

4. LEVEL 3 â€” Loops (easy)
IMG_URL phi_in_loop.png
ð–¦¹ Q7
Original:
[pink]i[/pink] [blue]=[/blue] [yellow]0[/yellow]
while ([green]i[/green] [blue]<[/blue] [yellow]3[/yellow]):
    [green]i[/green] [blue]=[/blue] [green]i[/green] [blue]+[/blue] [yellow]1[/yellow]
SSA Version:
[pink]i1[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]i2[/pink] [blue]=[/blue] Ï†([green]i1[/green], [green]i3[/green])
while [green]i2[/green] [blue]<[/blue] [yellow]3[/yellow]:
    [pink]i3[/pink] [blue]=[/blue] [green]i2[/green] [blue]+[/blue] [yellow]1[/yellow]

ð–¦¹ Q8
Original:
[pink]x[/pink] [blue]=[/blue] [yellow]2[/yellow]
[pink]y[/pink] [blue]=[/blue] [yellow]1[/yellow]
while ([green]x[/green] [blue]<[/blue] [yellow]5[/yellow]):
    [green]y[/green] [blue]=[/blue] [green]y[/green] [blue]+[/blue] [green]x[/green]
    [green]x[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [yellow]1[/yellow]
SSA Version:
[pink]x1[/pink] [blue]=[/blue] [yellow]2[/yellow]
[pink]y1[/pink] [blue]=[/blue] [yellow]1[/yellow]
[pink]x2[/pink] [blue]=[/blue] Ï†([green]x1[/green], [green]x3[/green])
[pink]y2[/pink] [blue]=[/blue] Ï†([green]y1[/green], [green]y3[/green])
while [green]x2[/green] [blue]<[/blue] [yellow]5[/yellow]:
    [pink]y3[/pink] [blue]=[/blue] [green]y2[/green] [blue]+[/blue] [green]x2[/green]
    [pink]x3[/pink] [blue]=[/blue] [green]x2[/green] [blue]+[/blue] [yellow]1[/yellow]

ð–¦¹ Q9
Original:
[pink]sum[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]i[/pink] [blue]=[/blue] [yellow]1[/yellow]
while ([green]i[/green] [blue]<=[/blue] [yellow]3[/yellow]):
    [green]sum[/green] [blue]=[/blue] [green]sum[/green] [blue]+[/blue] [green]i[/green]
    [green]i[/green] [blue]=[/blue] [green]i[/green] [blue]+[/blue] [yellow]1[/yellow]
SSA Version:
[pink]sum1[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]i1[/pink] [blue]=[/blue] [yellow]1[/yellow]
[pink]i2[/pink] [blue]=[/blue] Ï†([green]i1[/green], [green]i3[/green])
[pink]sum2[/pink] [blue]=[/blue] Ï†([green]sum1[/green], [green]sum3[/green])
while [green]i2[/green] [blue]<=[/blue] [yellow]3[/yellow]:
    [pink]sum3[/pink] [blue]=[/blue] [green]sum2[/green] [blue]+[/blue] [green]i2[/green]
    [pink]i3[/pink] [blue]=[/blue] [green]i2[/green] [blue]+[/blue] [yellow]1[/yellow]

5. LEVEL 4 â€” Loop with 2 variables
ð–¦¹ Q10
Original:
[pink]a[/pink] [blue]=[/blue] [yellow]1[/yellow]
[pink]b[/pink] [blue]=[/blue] [yellow]2[/yellow]
while ([green]a[/green] [blue]<[/blue] [yellow]4[/yellow]):
    [green]a[/green] [blue]=[/blue] [green]a[/green] [blue]+[/blue] [yellow]1[/yellow]
    [green]b[/green] [blue]=[/blue] [green]b[/green] [blue]+[/blue] [green]a[/green]
SSA Version:
[pink]a1[/pink] [blue]=[/blue] [yellow]1[/yellow]
[pink]b1[/pink] [blue]=[/blue] [yellow]2[/yellow]
[pink]a2[/pink] [blue]=[/blue] Ï†([green]a1[/green], [green]a3[/green])
[pink]b2[/pink] [blue]=[/blue] Ï†([green]b1[/green], [green]b3[/green])
while [green]a2[/green] [blue]<[/blue] [yellow]4[/yellow]:
    [pink]a3[/pink] [blue]=[/blue] [green]a2[/green] [blue]+[/blue] [yellow]1[/yellow]
    [pink]b3[/pink] [blue]=[/blue] [green]b2[/green] [blue]+[/blue] [green]a3[/green]

6. LEVEL 5 â€” Nested SSA tasks
ð–¦¹ Q11
Original:
[pink]x[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]y[/pink] [blue]=[/blue] [yellow]5[/yellow]
while ([green]y[/green] [blue]>[/blue] [yellow]0[/yellow]):
    [green]x[/green] [blue]=[/blue] [green]x[/green] [blue]+[/blue] [green]y[/green]
    [green]y[/green] [blue]=[/blue] [green]y[/green] [blue]-[/blue] [yellow]1[/yellow]
print([green]x[/green])
SSA Version:
[pink]x1[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]y1[/pink] [blue]=[/blue] [yellow]5[/yellow]
[pink]x2[/pink] [blue]=[/blue] Ï†([green]x1[/green], [green]x3[/green])
[pink]y2[/pink] [blue]=[/blue] Ï†([green]y1[/green], [green]y3[/green])
while [green]y2[/green] [blue]>[/blue] [yellow]0[/yellow]:
    [pink]x3[/pink] [blue]=[/blue] [green]x2[/green] [blue]+[/blue] [green]y2[/green]
    [pink]y3[/pink] [blue]=[/blue] [green]y2[/green] [blue]-[/blue] [yellow]1[/yellow]
print([green]x3[/green])

ð–¦¹ Q12
Original:
[pink]count[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]total[/pink] [blue]=[/blue] [yellow]0[/yellow]
while ([green]count[/green] [blue]<[/blue] [yellow]3[/yellow]):
    [pink]input[/pink] [blue]=[/blue] [green]count[/green] [blue]*[/blue] [yellow]2[/yellow]
    [green]total[/green] [blue]=[/blue] [green]total[/green] [blue]+[/blue] [green]input[/green]
    [green]count[/green] [blue]=[/blue] [green]count[/green] [blue]+[/blue] [yellow]1[/yellow]
SSA Version:
[pink]count1[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]total1[/pink] [blue]=[/blue] [yellow]0[/yellow]
[pink]count2[/pink] [blue]=[/blue] Ï†([green]count1[/green], [green]count3[/green])
[pink]total2[/pink] [blue]=[/blue] Ï†([green]total1[/green], [green]total3[/green])
while [green]count2[/green] [blue]<[/blue] [yellow]3[/yellow]:
    [pink]input1[/pink] [blue]=[/blue] [green]count2[/green] [blue]*[/blue] [yellow]2[/yellow]
    [pink]total3[/pink] [blue]=[/blue] [green]total2[/green] [blue]+[/blue] [green]input1[/green]
    [pink]count3[/pink] [blue]=[/blue] [green]count2[/green] [blue]+[/blue] [yellow]1[/yellow]
7. OTHER NAMES FOR Ï†: Phoney-function
--END--
