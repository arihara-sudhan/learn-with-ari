--BEGIN--22/11/2025--TIME COMPLEXITY--
1. Computational and asymptotic complexity
ğ–¦¹ A single problem can have many algorithms, each with different efficiency.
ğ–¦¹ For small data, these differences are small; for large data, the differences grow.
â€¢ Computational complexity
- Shows how much effort an algorithm needs in terms of time or space.

2. Time and space as efficiency measures
ğ–¦¹ Time is usually more important than space when judging an algorithm.
ğ–¦¹ Actual run time depends on the machine used.
â€¢ System dependence
- An inefficient algorithm on a very fast machine may still run faster than an efficient one on a slow machine.
- To compare many algorithms, all must be tested on the same machine.
â€¢ Language dependence
- Compiled programs run faster than interpreted ones.
- Some languages produce faster code than others.

3. Using logical units instead of real time
ğ–¦¹ Real-time units (microseconds, nanoseconds) should not be used for analysis.
ğ–¦¹ Use logical units that relate input size n to time t.
â€¢ Linear example
- If tâ‚ = cÂ·nâ‚, then increasing n by 5 times increases t by 5 times.
â€¢ Log example
- If tâ‚ = logâ‚‚(n), doubling n increases t by 1 unit.

4. Need for simplified functions
ğ–¦¹ The true relationship between n and t can be complex.
ğ–¦¹ For large data, small terms in the function do not change its overall growth.
ğ–¦¹ These small terms are removed to get a simpler approximate function.
â€¢ Asymptotic complexity
- Used when only the main growth of the function matters.
- Useful when exact calculation is hard or unnecessary.

5. Example: f(n) = nÂ² + 100n + logâ‚â‚€(n) + 1000
ğ–¦¹ For small n, the constant term 1000 is the biggest.
ğ–¦¹ At n = 10, the linear term 100n and constant term 1000 are similar in effect.
ğ–¦¹ At n = 100, the nÂ² and 100n terms have similar effects.
â€¢ For large n
- The nÂ² term grows much faster than other terms.
- 100n, logâ‚â‚€(n), and 1000 become very small in comparison.
- The function mainly depends on nÂ² when n is large.

6. Big-O notation
ğ–¦¹ Big-O is used to describe how fast a function grows for large n.
ğ–¦¹ It compares two functions f(n) and g(n) by checking if f grows no faster than g.
â€¢ Meaning of f(n) = O(g(n))
IMG_URL fnlessthancgn.png
- There exist positive numbers c and N such that f(n) â‰¤ cÂ·g(n) for all n â‰¥ N.
IMG_URL fnogn.png
- g(n) acts as an upper bound for the growth of f(n) when n is large.
IMG_URL rabbit-carrot-chase.gif

7. Limits of the basic definition
ğ–¦¹ The definition says constants c and N must exist but does not show how to find them.
ğ–¦¹ Many different pairs of c and N can satisfy the same f(n) and g(n).
â€¢ Example idea
- For f(n) = 2nÂ² + 3n + 1 and g(n) = nÂ², many c, N pairs work.
- These pairs come from solving: 2nÂ² + 3n + 1 â‰¤ cÂ·nÂ².

8. Finding useful constants
ğ–¦¹ To pick the best N, find when the largest term in f(n) stays the largest.
ğ–¦¹ For f(n) = 2nÂ² + 3n + 1, the biggest terms are 2nÂ² and 3n.
â€¢ Compare terms
- 2nÂ² > 3n when n > 1.
- So N = 2 is suitable, and c must be at least 33/4.

9. Meaning of different c and N
ğ–¦¹ Many pairs of c and N still describe the same relationship f = O(g).
ğ–¦¹ â€œAlmost alwaysâ€ means gÂ·c is â‰¥ f for all n â‰¥ N.
â€¢ Effect of choosing different N
- If N = 1, then c must be â‰¥ 6.
- If N = 2, c must be â‰¥ 3.75.
- If N = 3, c must be â‰¥ 31/9.
- c and N depend on each other.

10. Multiple possible upper bounds
ğ–¦¹ A function f can be O(nÂ²), O(nÂ³), O(nâ´), â€¦ for any power â‰¥ 2.
ğ–¦¹ To avoid too many choices, the smallest suitable g(n) is normally taken.
â€¢ Removing small terms
- Small terms in f(n) that do not affect growth are written using O( ).
- Example: f(n) = nÂ² + 100n + O(logâ‚â‚€(n))
â€¢ Another example
- f(n) = 2nÂ² + O(n)

11. Finding c and N
IMG_URL bigo.png
ğ–¦¹ We compare each part of f(n) with g(n) to show f(n) â‰¤ c Ã— g(n)
ğ–¦¹ We rewrite all parts of f(n) so they look like some_number Ã— g(n)
â€¢ This helps us show f(n) grows no faster than g(n)
- Explanation: If every part of f(n) can be written in terms of g(n), then the whole f(n) can also be written using g(n)

11.1 Making all terms look like g(n) = nÂ²
ğ–¦¹ For f(n) = 2nÂ² + 3n + 1, we try to rewrite each term as something Ã— nÂ²
ğ–¦¹ First term: 2nÂ² â‰¤ 2nÂ²
â€¢ It already matches nÂ², so no change needed

11.2 Converting 3n into something Ã— nÂ²
ğ–¦¹ We check if 3n can be compared with 3nÂ²
ğ–¦¹ Check if n â‰¤ nÂ² when n â‰¥ 1
â€¢ Divide both sides by n (n > 0) â†’ 1 â‰¤ n
- Explanation: This is true for all n â‰¥ 1, so 3n â‰¤ 3nÂ²

11.3 Converting constant 1 into something Ã— nÂ²
ğ–¦¹ We check if 1 â‰¤ nÂ² when n â‰¥ 1
ğ–¦¹ For n = 1,2,3,... this is always true
â€¢ So 1 â‰¤ nÂ² for all n â‰¥ 1

11.4 Putting all replacements together
ğ–¦¹ Now each part of f(n) is written in terms of nÂ²
ğ–¦¹ So:
â€¢ 2nÂ² + 3n + 1 â‰¤ 2nÂ² + 3nÂ² + nÂ²
- Explanation: Add them â†’ 6nÂ²

11.5 Final values
ğ–¦¹ f(n) â‰¤ 6nÂ²
ğ–¦¹ So c = 6
ğ–¦¹ And N = 1

12. Properties of Big-O notation
ğ–¦¹ Big-O has useful rules that help compare how fast functions grow
ğ–¦¹ These rules make it easier to estimate how fast algorithms run

12.1 Fact 1: Transitivity
IMG_URL transitive.png
ğ–¦¹ If f(n) is O(g(n)) and g(n) is O(h(n)), then f(n) is O(h(n))
ğ–¦¹ This means we can connect the two bounds into one
- Explanation: Since f(n) â‰¤ c1Â·g(n) for n â‰¥ N1 and g(n) â‰¤ c2Â·h(n) for n â‰¥ N2, we get f(n) â‰¤ (c1Â·c2)Â·h(n) for large enough n

12.2 Fact 2: Sum rule
IMG_URL sumrule.png
ğ–¦¹ If f(n) is O(h(n)) and g(n) is O(h(n)), then f(n) + g(n) is O(h(n))
- Explanation: If f(n) â‰¤ c1Â·h(n) and g(n) â‰¤ c2Â·h(n), then f(n)+g(n) â‰¤ (c1+c2)Â·h(n)

12.3 Fact 3: Constant times nk
IMG_URL constant.png
ğ–¦¹ The function aÂ·n^k is O(n^k)
- Explanation: aÂ·n^k â‰¤ cÂ·n^k if c â‰¥ a
An Example: Even though 5Â·nÂ³ is big for small n, as n â†’ âˆ, it becomes insignificant compared to nâ´. Multiplying by a constant (5) cannot change the exponent â€” nÂ³ will always grow slower than nâ´ in the long run

12.4 Fact 4: Smaller powers grow slower
IMG_URL smallpower.png
ğ–¦¹ n^k is O(n^(k+j)) for any positive j
- Explanation: This works for c = 1 and N = 1

12.5 Polynomial rule
IMG_URL highestpower.png
ğ–¦¹ A polynomial grows at the rate of its highest power
ğ–¦¹ Example: f(n) = akÂ·n^k + akâˆ’1Â·n^(kâˆ’1) + â€¦ + a1Â·n + a0 is O(n^k)
â€¢ Also, f(n) is O(n^(k+j)) for any positive j

12.6 Logarithmic functions grow very slowly
ğ–¦¹ Algorithms with logarithmic running time are considered very good
ğ–¦¹ Some even slower functions exist, like log log n or constant time O(1), but they are rarely used

12.7 Fact 5: Constant multiple rule
ğ–¦¹ If f(n) = cÂ·g(n), then f(n) is O(g(n))
- Explanation: Multiplying by a fixed constant does not change the growth rate

12.8 Fact 6: Logarithms with any base have the same growth
IMG_URL logdiffbases.png
ğ–¦¹ log_a(n) is O(log_b(n)) for any positive a and b â‰  1
ğ–¦¹ All logarithms grow at the same rate
- Explanation: Using log rules, log_a(n) can be written as a constant Ã— log_b(n)

12.9 Fact 7: Using base 2 for convenience
ğ–¦¹ log_a(n) is O(lg n) for any positive a â‰  1
ğ–¦¹ lg n means log base 2 of n

13. Î© and Î˜ notations
ğ–¦¹ Î© notation gives a lower bound for how fast a function grows
ğ–¦¹ f(n) is Î©(g(n)) when f(n) â‰¥ cÂ·g(n) for all n â‰¥ N
â€¢ Means f grows at least as fast as g in the long run
- Explanation: Only the direction of the inequality changes compared to big-O
In other words, f(n cannot grow slower than g(n) after some point N)

13.1 Relation between Î© and O
ğ–¦¹ f(n) is Î©(g(n)) exactly when g(n) is O(f(n))
ğ–¦¹ Both notations allow many choices of c and N
â€¢ Many different lower bounds are possible for the same f

13.2 Examples of many possible lower bounds
ğ–¦¹ If f(n) is Î©(nÂ²), it is also Î©(n), Î©(nÂ¹áŸÂ²), Î©(nÂ¹áŸÂ³), and so on
ğ–¦¹ Also Î©(log n), Î©(log log n), etc.
- Explanation: Only the largest lower bound is interesting in practice

13.3 Î˜ notation idea
ğ–¦¹ Î˜ notation gives both lower and upper bounds together
ğ–¦¹ f(n) is Î˜(g(n)) if c1Â·g(n) â‰¤ f(n) â‰¤ c2Â·g(n) for all n â‰¥ N
- Explanation: Means f and g grow at the same rate in the long run

13.4 Link between O, Î©, and Î˜
ğ–¦¹ f(n) is Î˜(g(n)) only if f(n) is both O(g(n)) and Î©(g(n))
ğ–¦¹ For the function 2nÂ² + 3n + 1, the simplest Î˜ bound is nÂ²

14. Possible problems with big-O
ğ–¦¹ Big-O hides constants; a large constant can mislead comparisons
ğ–¦¹ Some algorithms may look worse by big-O but are faster for small n
- Explanation: Big-O only cares about the long run and ignores small n

14.1 Example of misleading big-O
ğ–¦¹ Compare 108Â·n and 10Â·nÂ²
ğ–¦¹ First is O(n), second is O(nÂ²)
â€¢ For n â‰¤ 10â·, second one is actually faster
- Explanation: Big-O alone may cause rejecting a better algorithm

14.2 Double-O (OO) notation idea
ğ–¦¹ OO(g(n)) means O(g(n)) but with a constant too large to be useful
ğ–¦¹ Example: 108Â·n is OO(n)
- Explanation: â€œToo largeâ€ depends on the application

15. Examples of complexities
ğ–¦¹ Algorithms can be grouped by how fast their running time grows
ğ–¦¹ Common groups: constant, logarithmic, linear, nÂ·log n, quadratic, cubic, exponential
- Explanation: Growth patterns show which algorithms are practical

15.1 Real-time execution examples
ğ–¦¹ With 1 million operations per second, quadratic on 1M items takes 11+ days
ğ–¦¹ Cubic on 1M items takes thousands of years
â€¢ Even huge hardware improvements help only a little for high-complexity algorithms
- Explanation: Good algorithm design is more important than fast hardware

15.2 Importance of complexity study
ğ–¦¹ Even fast computers cannot save badly designed algorithms
ğ–¦¹ Understanding complexity is essential, especially in data structures

16. Asymptotic complexity idea
ğ–¦¹ Asymptotic bounds help us estimate time and memory needs of algorithms
ğ–¦¹ We mostly study time complexity by counting assignment steps
â€¢ Comparisons are also counted in some cases
- Explanation: We focus on how the total work grows when input size grows

16.1 Simple loop example
ğ–¦¹ Code:
[pink]for[/pink] [yellow](i = sum = 0; i < n; i++)[/yellow]
    [pink]sum[/pink] [yellow]+= a[i];[/yellow]
ğ–¦¹ Two initial assignments, then loop runs n times
â€¢ Each loop step has 2 assignments (sum update and i update)
- Explanation: Total steps = 2 + 2n, so complexity is O(n)

16.2 Nested loop example (sums of subarrays starting at 0)
ğ–¦¹ Code:
[pink]for[/pink] [yellow](i = 0; i < n; i++)[/yellow] {
    [pink]for[/pink] [yellow](j = 1, sum = a[0]; j <= i; j++)[/yellow]
        [pink]sum[/pink] [yellow]+= a[j];[/yellow]
    [yellow]System.out.println(...);[/yellow]
}
ğ–¦¹ Outer loop runs n times; inner loop runs i times for each i
â€¢ Inner loop has 2 assignments per step
- Explanation: Total = 1 + 3n + 2(1+2+â€¦+(nâ€“1)) = O(nÂ²)

16.3 Nested loops but with fixed-size work
ğ–¦¹ We print sums of last five cells of each subarray starting at 0
ğ–¦¹ Code:
[pink]for[/pink] [yellow](i = 4; i < n; i++)[/yellow] {
    [pink]for[/pink] [yellow](j = i-3, sum = a[i-4]; j <= i; j++)[/yellow]
        [pink]sum[/pink] [yellow]+= a[j];[/yellow]
    [yellow]System.out.println(...);[/yellow]
}
â€¢ Outer loop runs nâ€“4 times
â€¢ Inner loop always runs 4 times (constant work)
- Explanation: Total = 1 + 8Â·(nâ€“4) = O(n)

16.4 Loops where iteration count depends on data order
ğ–¦¹ We find length of longest increasing subarray
ğ–¦¹ Code:
[pink]for[/pink] [yellow](i = 0, length = 1; i < n-1; i++)[/yellow] {
    [pink]for[/pink] [yellow](i1 = i2 = k = i; k < n-1 && a[k] < a[k+1]; k++, i2++)[/yellow];
    [pink]if[/pink] [yellow](length < i2 - i1 + 1)[/yellow]
        [pink]length[/pink] [yellow]= i2 - i1 + 1;[/yellow]
    [yellow]System.out.println(...);[/yellow]
}
ğ–¦¹ Worst case (array strictly increasing):
â€¢ Outer loop runs nâ€“1 times, inner loop runs (nâ€“1â€“i) times  
- Explanation: Total = O(nÂ²)
ğ–¦¹ Best case (array strictly decreasing):
â€¢ Inner loop runs once each time  
- Explanation: Total = O(n)

16.5 Binary search complexity
ğ–¦¹ Binary search works by checking the middle of the current array part
ğ–¦¹ Code:
[pink]int[/pink] [yellow]binarySearch(int[] arr, int key) {[/yellow]
    [pink]int[/pink] [yellow]lo = 0, mid, hi = arr.length-1;[/yellow]
    [pink]while[/pink] [yellow](lo <= hi) {[/yellow]
        [yellow]mid = (lo + hi)/2;[/yellow]
        [pink]if[/pink] [yellow](key < arr[mid])[/yellow]
            [yellow]hi = mid - 1;[/yellow]
        [pink]else if[/pink] [yellow](arr[mid] < key)[/yellow]
            [yellow]lo = mid + 1;[/yellow]
        [pink]else return[/pink] [yellow]mid;[/yellow]
    [yellow]}[/yellow]
    [pink]return[/pink] [yellow]-1;[/yellow]
[yellow]}[/yellow]
ğ–¦¹ If key is absent:
â€¢ Checked array sizes go n â†’ n/2 â†’ n/4 â†’ ... â†’ 1
- Explanation: Number of halvings = m where n / 2^m = 1, so m = logâ‚‚ n  
â€¢ Complexity = O(log n)
--END--
--BEGIN--23/11/2025--LINKED LISTS--
1. Arrays and their limitations
ğ–¦¹ Arrays store elements one after another in memory, i.e., sequentially
ğ–¦¹ Limitations of arrays:
â€¢ Fixed size
- To change the size, you must create a new array and copy all data.
â€¢ Sequential memory
- Elements are next to each other in memory.
- Inserting in the middle requires shifting other elements, which is slow.

2. Linked structures
ğ–¦¹ Used to overcome array limitations.
ğ–¦¹ Made of nodes, where each node has:
â€¢ Data
- The value you want to store.
â€¢ Reference(s)
- Links to other nodes.
ğ–¦¹ Nodes can be anywhere in memory.
ğ–¦¹ You move from one node to another using links.

3. Singly Linked List (SLL)
ğ–¦¹ Each node has a link only to its next node (successor).
ğ–¦¹ Nodes are connected like a chain.
ğ–¦¹ Access the list using one variable pointing to the first node.
ğ–¦¹ Last node points to null to indicate the end of the list.
IMG_URL sll.png

4. Singly Linked List (SLL) implementation
ğ–¦¹ Demonstrates creating and linking nodes in a singly linked list.
ğ–¦¹ Code example:
[pink]#include[/pink] <[green]iostream[/green]>
[pink]using[/pink] [pink]namespace[/pink] [green]std[/green];

[pink]class[/pink] [yellow]SLLNode[/yellow] {
    [pink]public[/pink]:
        [blue]int[/blue] [yellow]data[/yellow];
        [yellow]SLLNode*[/yellow] [yellow]next[/yellow];
        [yellow]SLLNode[/yellow]([blue]int[/blue] [yellow]data[/yellow], [yellow]SLLNode*[/yellow] [yellow]next[/yellow]=[green]nullptr[/green]){
            [pink]this[/pink]->[yellow]data[/yellow] = [yellow]data[/yellow];
            [pink]this[/pink]->[yellow]next[/yellow] = [yellow]next[/yellow];
        }
};

[pink]int[/pink] [pink]main[/pink]() {
     ;
    [yellow]SLLNode*[/yellow] [yellow]firstNode[/yellow] = [pink]new[/pink] [yellow]SLLNode[/yellow](2, [yellow]secondNode[/yellow]);
    [green]cout[/green]<<[yellow]firstNode[/yellow]->[yellow]data[/yellow]<<"\n";
    [green]cout[/green]<<[yellow]firstNode[/yellow]->[yellow]next[/yellow]->[yellow]data[/yellow];
    [pink]delete[/pink] [yellow]secondNode[/yellow];
    [pink]delete[/pink] [yellow]firstNode[/yellow];
    [pink]return[/pink] 0;
}
ğ–¦¹ Creates two nodes with data 2 and 3.
ğ–¦¹ Links first node to second node.
ğ–¦¹ Prints data of first and second node.
ğ–¦¹ Frees memory using delete to avoid memory leaks.

5. Adding a Node to Singly Linked List
ğ–¦¹ A singly linked list has a head pointer pointing to the first node.
ğ–¦¹ Each node stores data and a pointer to the next node.
ğ–¦¹ Example C++ implementation:

[pink]#include[/pink] [yellow]<iostream>[/yellow]
[yellow]using namespace std;[/yellow]

[pink]class[/pink] SLLNode {
    [pink]public[/pink]:
        [pink]int[/pink] data;
        SLLNode* next;
        SLLNode([pink]int[/pink] data, SLLNode* next = [green]nullptr[/green]) {
            this->data = data;
            this->next = next;
        }
};

[pink]class[/pink] SinglyLinkedList {
    [pink]private[/pink]:
        SLLNode* head;
    [pink]public[/pink]:
        SinglyLinkedList() {
            head = [green]nullptr[/green];
        }
        void printAll() {
            SLLNode* temp = head;
            while(temp != [green]nullptr[/green]) {
                [green]cout[/green] << temp->data << "->";
                temp = temp->next;
            }
            [green]cout[/green] << "END\n";
        }
        void addNode([pink]int[/pink] value) {
            SLLNode* newNode = [pink]new[/pink] SLLNode(value);
            if(head == [green]nullptr[/green]) {
                head = newNode;
            } else {
                SLLNode* temp = head;
                while(temp->next != [green]nullptr[/green]) {
                    temp = temp->next;
                }
                temp->next = newNode;
            }
        }
};

[pink]int[/pink] [pink]main[/pink]() {
    SinglyLinkedList sll;
    sll.addNode(1);
    sll.addNode(2);
    sll.addNode(3);
    sll.printAll();
    [pink]return[/pink] 0;
}

ğ–¦¹ [pink]addNode[/pink] creates a new node with the given value.
ğ–¦¹ If the list is empty, the new node becomes the head.
ğ–¦¹ If not empty, traverse to the last node and link the new node.
ğ–¦¹ [pink]printAll[/pink] traverses the list and prints all node data followed by "END".

6. Deleting a Node from Singly Linked List
ğ–¦¹ A singly linked list has a head pointer pointing to the first node.
ğ–¦¹ Each node stores data and a pointer to the next node.
ğ–¦¹ Example C++ implementation:

[pink]#include[/pink] [yellow]<iostream>[/yellow]
[yellow]using namespace std;[/yellow]

[pink]class[/pink] SLLNode {
    [pink]public[/pink]:
        [pink]int[/pink] data;
        SLLNode* next;
        SLLNode([pink]int[/pink] data, SLLNode* next = [green]nullptr[/green]) {
            this->data = data;
            this->next = next;
        }
};

[pink]class[/pink] SinglyLinkedList {
    [pink]private[/pink]:
        SLLNode* head;
    [pink]public[/pink]:
        SinglyLinkedList() {
            head = [green]nullptr[/green];
        }
        ~SinglyLinkedList() {  // destructor to free memory
            SLLNode* temp = head;
            while(temp != [green]nullptr[/green]) {
                SLLNode* nextNode = temp->next;
                [pink]delete[/pink] temp;
                temp = nextNode;
            }
        }
        void printAll() {
            SLLNode* temp = head;
            while(temp != [green]nullptr[/green]) {
                [green]cout[/green] << temp->data << "->";
                temp = temp->next;
            }
            [green]cout[/green] << "END\n";
        }
        void addNode([pink]int[/pink] value) {
            SLLNode* newNode = [pink]new[/pink] SLLNode(value);
            if(head == [green]nullptr[/green]) {
                head = newNode;
            } else {
                SLLNode* temp = head;
                while(temp->next != [green]nullptr[/green]) {
                    temp = temp->next;
                }
                temp->next = newNode;
            }
        }
        void deleteNode([pink]int[/pink] value) {
            if(head == [green]nullptr[/green]) {
                [green]cout[/green] << "NOTHING TO DELETE\n";
            } else {
                SLLNode* temp = head;
                SLLNode* prev = [green]nullptr[/green];
                while(temp != [green]nullptr[/green] && temp->data != value) {
                    prev = temp;
                    temp = temp->next;
                }
                if(temp == [green]nullptr[/green]) {
                    [green]cout[/green] << "DATA NOT THERE\n";
                } else if(temp == head) {
                    head = head->next;
                } else {
                    prev->next = temp->next;
                }
                [pink]delete[/pink] temp;
            }
        }
};

[pink]int[/pink] [pink]main[/pink]() {
    SinglyLinkedList sll;
    sll.addNode(1);
    sll.addNode(2);
    sll.addNode(3);
    sll.printAll();
    sll.deleteNode(1);
    sll.printAll();
    sll.deleteNode(11);
    [pink]return[/pink] 0;
}

ğ–¦¹ [pink]deleteNode[/pink] searches for the node with given value.
ğ–¦¹ If the list is empty, it prints "NOTHING TO DELETE".
ğ–¦¹ If the value is not found, it prints "DATA NOT THERE".
ğ–¦¹ If the node is the head, update head to next node.
ğ–¦¹ Otherwise, update previous node's next to skip the deleted node.
ğ–¦¹ The destructor frees all nodes to avoid memory leaks.

7. Singly Linked List Operations and Complexity
ğ–¦¹ Insertion at head: O(1)
â€¢ Create a new node and point it to the current head.
- Very fast because no traversal is needed.
ğ–¦¹ Insertion at tail (without tail pointer): O(n)
â€¢ Traverse from head to the last node.
â€¢ Link the new node after the last node.
- Slower because traversal is needed.
ğ–¦¹ Insertion after a given node: O(1)
â€¢ If you have a pointer to the node, link the new node immediately.
- Constant time insertion.
ğ–¦¹ Deletion of head node: O(1)
â€¢ Move head pointer to the next node.
â€¢ Delete the old head node.
- Fast because no traversal is needed.
ğ–¦¹ Deletion of a node by value: O(n)
â€¢ Traverse the list to find the node with the value.
â€¢ Remove the node and fix links.
- Slower because search may require visiting all nodes.
ğ–¦¹ Searching for a value: O(n)
â€¢ Check each node from head to tail.
- Linear time search.

8. What is a DLL?
IMG_URL dll.png
ğ–¦¹ A list where each node has two links: next and prev
ğ–¦¹ You can move both forward and backward
ğ–¦¹ Helpful when you need two-way movement

9. Node structure
ğ–¦¹ Each node has:
â€¢ data
â€¢ next pointer â†’ goes to next node
â€¢ prev pointer â†’ goes to previous node
ğ–¦¹ First node has prev = NULL
ğ–¦¹ Last node has next = NULL

10. Basic picture
ğ–¦¹ NULL <- [10] <-> [20] <-> [30] -> NULL
11. Doubly Linked List Operations and Complexity
ğ–¦¹ Insertion at head: O(1)
â€¢ Create new node
â€¢ new->next = head
â€¢ head->prev = new
â€¢ head = new
- No need to walk through list
ğ–¦¹ Insertion at tail without tail pointer: O(n)
â€¢ Walk from head to last node
â€¢ last->next = new
â€¢ new->prev = last
- Must visit all nodes
ğ–¦¹ Insertion at tail with tail pointer: O(1)
â€¢ tail->next = new
â€¢ new->prev = tail
â€¢ tail = new
- Very quick
ğ–¦¹ Insertion after a given node: O(1)
â€¢ new->next = node->next
â€¢ new->prev = node
â€¢ Fix next nodeâ€™s prev
â€¢ Fix node->next
- Only pointer updates
ğ–¦¹ Insertion before a given node: O(1)
â€¢ new->prev = node->prev
â€¢ new->next = node
â€¢ Fix prev nodeâ€™s next
â€¢ Fix node->prev
- DLL makes â€œinsert beforeâ€ easy
ğ–¦¹ Deletion of head: O(1)
â€¢ head = head->next
â€¢ head->prev = NULL
â€¢ delete old head
- Very fast
ğ–¦¹ Deletion of tail with tail pointer: O(1)
â€¢ tail = tail->prev
â€¢ tail->next = NULL
â€¢ delete old tail
- No traversal needed
ğ–¦¹ Deletion by value: O(n)
â€¢ Walk to find the value
â€¢ Fix next and prev
â€¢ Delete the node
- Search takes linear time
ğ–¦¹ Searching for a value: O(n)
â€¢ Move node by node
- Same as singly list
ğ–¦¹ Forward traversal: O(n)
â€¢ Use next pointer

ğ–¦¹ Backward traversal: O(n)
â€¢ Use prev pointer
- Only DLL can do backward travel

12. Extra Advanced DLL Operations
ğ–¦¹ Reverse the list: O(n)
â€¢ Swap next and prev for each node
â€¢ Move head to last node
ğ–¦¹ Insert at position k: O(n)
â€¢ Walk to k
â€¢ Insert before or after
ğ–¦¹ Delete at position k: O(n)
â€¢ Walk to k
â€¢ Remove the node

13. Memory Usage
ğ–¦¹ DLL uses more memory than singly lists
â€¢ data
â€¢ next pointer
â€¢ prev pointer
ğ–¦¹ Extra pointer takes more space

14. Advantages of DLL
ğ–¦¹ Move in both directions
ğ–¦¹ Delete easier because prev exists
ğ–¦¹ Insert before any node easily
ğ–¦¹ Good for systems like:
â€¢ LRU cache
â€¢ Browser history
â€¢ Undo-redo
â€¢ Playlist navigation
ğ–¦¹ Fast tail deletion if tail pointer exists

15. Disadvantages of DLL
ğ–¦¹ Uses more memory
ğ–¦¹ More complex to code
ğ–¦¹ Must update two pointers
ğ–¦¹ Mistakes in pointers can break list

16. When to Use DLL
ğ–¦¹ Use DLL when:
â€¢ You need two-way movement
â€¢ You want quick delete after finding node
â€¢ You need undo/redo
â€¢ You want LRU cache
â€¢ You need easy navigation
ğ–¦¹ Do not use DLL when:
â€¢ You want simple structure
â€¢ Memory must be saved
â€¢ Only forward travel is needed
â€¢ Backward travel not needed

17. Doubly Linked List Example Program
[pink]#include[/pink] <iostream>
[pink]using[/pink] [pink]namespace[/pink] std;

[pink]class[/pink] [yellow]DLLNode[/yellow] {
[pink]public[/pink]:
    [pink]int[/pink] [yellow]data[/yellow];
    [blue]DLLNode*[/blue] [yellow]next[/yellow];
    [blue]DLLNode*[/blue] [yellow]prev[/yellow];

    [yellow]DLLNode[/yellow]([pink]int[/pink] [yellow]data[/yellow],
              [blue]DLLNode*[/blue] [yellow]next[/yellow] = [green]nullptr[/green],
              [blue]DLLNode*[/blue] [yellow]prev[/yellow] = [green]nullptr[/green]) {
        [pink]this[/pink]->[yellow]data[/yellow] = [yellow]data[/yellow];
        [pink]this[/pink]->[yellow]next[/yellow] = [yellow]next[/yellow];
        [pink]this[/pink]->[yellow]prev[/yellow] = [yellow]prev[/yellow];
    }
};

[pink]class[/pink] [yellow]DoublyLinkedList[/yellow] {
[pink]private[/pink]:
    [blue]DLLNode*[/blue] [yellow]head[/yellow];

[pink]public[/pink]:
    [yellow]DoublyLinkedList[/yellow]() {
        [yellow]head[/yellow] = [green]nullptr[/green];
    }

    [pink]~DoublyLinkedList[/pink]() {
        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green]) {
            [blue]DLLNode*[/blue] [yellow]nextNode[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
            [pink]delete[/pink] [yellow]temp[/yellow];
            [yellow]temp[/yellow] = [yellow]nextNode[/yellow];
        }
    }

    [pink]void[/pink] [yellow]printAll[/yellow]() {
        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green]) {
            [green]cout[/green] << [yellow]temp[/yellow]->[yellow]data[/yellow] << " <-> ";
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }
        [green]cout[/green] << "END\n";
    }

    [pink]void[/pink] [yellow]addNode[/yellow]([pink]int[/pink] [yellow]value[/yellow]) {
        [blue]DLLNode*[/blue] [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]DLLNode[/yellow]([yellow]value[/yellow]);

        [pink]if[/pink] ([yellow]head[/yellow] == [green]nullptr[/green]) {
            [yellow]head[/yellow] = [yellow]newNode[/yellow];
            [pink]return[/pink];
        }

        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow]->[yellow]next[/yellow] != [green]nullptr[/green]) {
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }

        [yellow]temp[/yellow]->[yellow]next[/yellow] = [yellow]newNode[/yellow];
        [yellow]newNode[/yellow]->[yellow]prev[/yellow] = [yellow]temp[/yellow];
    }

    [pink]void[/pink] [yellow]deleteNode[/yellow]([pink]int[/pink] [yellow]value[/yellow]) {
        [pink]if[/pink] ([yellow]head[/yellow] == [green]nullptr[/green]) {
            [green]cout[/green] << "NOTHING TO DELETE\n";
            [pink]return[/pink];
        }

        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green] &&
               [yellow]temp[/yellow]->[yellow]data[/yellow] != [yellow]value[/yellow]) {
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }

        [pink]if[/pink] ([yellow]temp[/yellow] == [green]nullptr[/green]) {
            [green]cout[/green] << "DATA NOT THERE\n";
            [pink]return[/pink];
        }

        [pink]if[/pink] ([yellow]temp[/yellow] == [yellow]head[/yellow]) {
            [yellow]head[/yellow] = [yellow]head[/yellow]->[yellow]next[/yellow];
            [pink]if[/pink] ([yellow]head[/yellow] != [green]nullptr[/green]) {
                [yellow]head[/yellow]->[yellow]prev[/yellow] = [green]nullptr[/green];
            }
        } [pink]else[/pink] {
            [yellow]temp[/yellow]->[yellow]prev[/yellow]->[yellow]next[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];

            [pink]if[/pink] ([yellow]temp[/yellow]->[yellow]next[/yellow] != [green]nullptr[/green]) {
                [yellow]temp[/yellow]->[yellow]next[/yellow]->[yellow]prev[/yellow] = [yellow]temp[/yellow]->[yellow]prev[/yellow];
            }
        }

        [pink]delete[/pink] [yellow]temp[/yellow];
    }
};

[pink]int[/pink] [yellow]main[/yellow]() {
    [yellow]DoublyLinkedList[/yellow] [yellow]dll[/yellow];

    ;
    ;
    ;

    [yellow]dll[/yellow].[yellow]printAll[/yellow]();

    ;
    [yellow]dll[/yellow].[yellow]printAll[/yellow]();

    ;

    [pink]return[/pink] 0;
}

18. What is a Circularly Linked List (CLL)?
ğ–¦¹ Last node points back to first node, forming a loop
ğ–¦¹ Each node has data and next pointer
ğ–¦¹ Can be singly circular (one next) or doubly circular (next and prev)
ğ–¦¹ No true head or tail; can start from any node
ğ–¦¹ A cursor node marks starting point for operations

19. Structure
ğ–¦¹ Singly Circular:
IMG_URL csll.png
ğ–¦¹ Doubly Circular:
IMG_URL cdll.png

21. Key Concepts
ğ–¦¹ Cursor marks special node for operations
â€¢ back â†’ element at cursor
â€¢ front â†’ element after cursor
ğ–¦¹ Traversal
â€¢ Forward: follow next, eventually cycles back
â€¢ Backward (doubly): follow prev, cycles back
ğ–¦¹ Head/Tail Access
â€¢ Singly circular: tail pointer may be enough
â€¢ Tailâ€™s next points to head

22. Advantages of Circular List
ğ–¦¹ Useful in round-robin scheduling
ğ–¦¹ Can implement playlists, queues, process scheduling
ğ–¦¹ In doubly circular, insertion/deletion at both ends is easy
ğ–¦¹ No end; can cycle infinitely

23. Operations and Complexity
ğ–¦¹ Singly Circular:
â€¢ Add after cursor: O(1)
- Create new node
- newNode->next = cursor->next
- cursor->next = newNode
â€¢ Remove after cursor: O(1)
- Only node â†’ cursor = NULL
- Else â†’ cursor->next = cursor->next->next
- Delete old node
â€¢ Advance cursor: O(1)
- cursor = cursor->next
â€¢ Access front/back: O(1)
- back() = cursor->elem
- front() = cursor->next->elem
ğ–¦¹ Doubly Circular:
â€¢ Insert/delete at head or tail: O(1)
- prev pointer allows direct access to previous node
â€¢ Traversal backward: O(n)
- Can move in reverse without loops

24. Examples of Use
ğ–¦¹ Round-robin process scheduling
â€¢ Each process is a node
â€¢ Cursor moves to next process after execution
ğ–¦¹ Digital Audio Player / Playlist
â€¢ Each song is a node
â€¢ Cursor points to current song
â€¢ Advance moves to next song
â€¢ Add/remove songs after cursor
ğ–¦¹ Example Playlist Sequence
â€¢ Empty list: []
â€¢ Add "StayinAlive": [StayinAlive*]
â€¢ Add "LeFreak": [LeFreak, StayinAlive*]
â€¢ Add "JiveTalkin": [JiveTalkin, LeFreak, StayinAlive*]
â€¢ Advance cursor twice: [StayinAlive, JiveTalkin, LeFreak*]
â€¢ Remove after cursor: [JiveTalkin, LeFreak*]
â€¢ Add "DiscoInferno": [DiscoInferno, JiveTalkin, LeFreak*]

25. Memory Usage
ğ–¦¹ Similar to singly or doubly linked lists
ğ–¦¹ Doubly circular uses extra memory for prev pointers

26. Advantages of Circular Lists
ğ–¦¹ No head/tail limits; perfect for cycling
ğ–¦¹ O(1) insertion and deletion after cursor (or tail in doubly circular)
ğ–¦¹ Forward/backward traversal (doubly circular)
ğ–¦¹ Efficient for playlists, queues, round-robin

27. Disadvantages
ğ–¦¹ Slightly more complex than SLL or DLL
ğ–¦¹ Singly circular: reverse traversal difficult
ğ–¦¹ Must maintain links carefully; broken link breaks cycle

--END--