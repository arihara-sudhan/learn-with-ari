--BEGIN--22/11/2025--TIME COMPLEXITY--
1. Computational and asymptotic complexity
ğ–¦¹ A single problem can have many algorithms, each with different efficiency.
ğ–¦¹ For small data, these differences are small; for large data, the differences grow.
â€¢ Computational complexity
- Shows how much effort an algorithm needs in terms of time or space.

2. Time and space as efficiency measures
ğ–¦¹ Time is usually more important than space when judging an algorithm.
ğ–¦¹ Actual run time depends on the machine used.
â€¢ System dependence
- An inefficient algorithm on a very fast machine may still run faster than an efficient one on a slow machine.
- To compare many algorithms, all must be tested on the same machine.
â€¢ Language dependence
- Compiled programs run faster than interpreted ones.
- Some languages produce faster code than others.

3. Using logical units instead of real time
ğ–¦¹ Real-time units (microseconds, nanoseconds) should not be used for analysis.
ğ–¦¹ Use logical units that relate input size n to time t.
â€¢ Linear example
- If tâ‚ = cÂ·nâ‚, then increasing n by 5 times increases t by 5 times.
â€¢ Log example
- If tâ‚ = logâ‚‚(n), doubling n increases t by 1 unit.

4. Need for simplified functions
ğ–¦¹ The true relationship between n and t can be complex.
ğ–¦¹ For large data, small terms in the function do not change its overall growth.
ğ–¦¹ These small terms are removed to get a simpler approximate function.
â€¢ Asymptotic complexity
- Used when only the main growth of the function matters.
- Useful when exact calculation is hard or unnecessary.

5. Example: f(n) = nÂ² + 100n + logâ‚â‚€(n) + 1000
ğ–¦¹ For small n, the constant term 1000 is the biggest.
ğ–¦¹ At n = 10, the linear term 100n and constant term 1000 are similar in effect.
ğ–¦¹ At n = 100, the nÂ² and 100n terms have similar effects.
â€¢ For large n
- The nÂ² term grows much faster than other terms.
- 100n, logâ‚â‚€(n), and 1000 become very small in comparison.
- The function mainly depends on nÂ² when n is large.

6. Big-O notation
ğ–¦¹ Big-O is used to describe how fast a function grows for large n.
ğ–¦¹ It compares two functions f(n) and g(n) by checking if f grows no faster than g.
â€¢ Meaning of f(n) = O(g(n))
IMG_URL fnlessthancgn.png
- There exist positive numbers c and N such that f(n) â‰¤ cÂ·g(n) for all n â‰¥ N.
IMG_URL fnogn.png
- g(n) acts as an upper bound for the growth of f(n) when n is large.
IMG_URL rabbit-carrot-chase.gif

7. Limits of the basic definition
ğ–¦¹ The definition says constants c and N must exist but does not show how to find them.
ğ–¦¹ Many different pairs of c and N can satisfy the same f(n) and g(n).
â€¢ Example idea
- For f(n) = 2nÂ² + 3n + 1 and g(n) = nÂ², many c, N pairs work.
- These pairs come from solving: 2nÂ² + 3n + 1 â‰¤ cÂ·nÂ².

8. Finding useful constants
ğ–¦¹ To pick the best N, find when the largest term in f(n) stays the largest.
ğ–¦¹ For f(n) = 2nÂ² + 3n + 1, the biggest terms are 2nÂ² and 3n.
â€¢ Compare terms
- 2nÂ² > 3n when n > 1.
- So N = 2 is suitable, and c must be at least 33/4.

9. Meaning of different c and N
ğ–¦¹ Many pairs of c and N still describe the same relationship f = O(g).
ğ–¦¹ â€œAlmost alwaysâ€ means gÂ·c is â‰¥ f for all n â‰¥ N.
â€¢ Effect of choosing different N
- If N = 1, then c must be â‰¥ 6.
- If N = 2, c must be â‰¥ 3.75.
- If N = 3, c must be â‰¥ 31/9.
- c and N depend on each other.

10. Multiple possible upper bounds
ğ–¦¹ A function f can be O(nÂ²), O(nÂ³), O(nâ´), â€¦ for any power â‰¥ 2.
ğ–¦¹ To avoid too many choices, the smallest suitable g(n) is normally taken.
â€¢ Removing small terms
- Small terms in f(n) that do not affect growth are written using O( ).
- Example: f(n) = nÂ² + 100n + O(logâ‚â‚€(n))
â€¢ Another example
- f(n) = 2nÂ² + O(n)

11. Finding c and N
IMG_URL bigo.png
ğ–¦¹ We compare each part of f(n) with g(n) to show f(n) â‰¤ c Ã— g(n)
ğ–¦¹ We rewrite all parts of f(n) so they look like some_number Ã— g(n)
â€¢ This helps us show f(n) grows no faster than g(n)
- Explanation: If every part of f(n) can be written in terms of g(n), then the whole f(n) can also be written using g(n)

11.1 Making all terms look like g(n) = nÂ²
ğ–¦¹ For f(n) = 2nÂ² + 3n + 1, we try to rewrite each term as something Ã— nÂ²
ğ–¦¹ First term: 2nÂ² â‰¤ 2nÂ²
â€¢ It already matches nÂ², so no change needed

11.2 Converting 3n into something Ã— nÂ²
ğ–¦¹ We check if 3n can be compared with 3nÂ²
ğ–¦¹ Check if n â‰¤ nÂ² when n â‰¥ 1
â€¢ Divide both sides by n (n > 0) â†’ 1 â‰¤ n
- Explanation: This is true for all n â‰¥ 1, so 3n â‰¤ 3nÂ²

11.3 Converting constant 1 into something Ã— nÂ²
ğ–¦¹ We check if 1 â‰¤ nÂ² when n â‰¥ 1
ğ–¦¹ For n = 1,2,3,... this is always true
â€¢ So 1 â‰¤ nÂ² for all n â‰¥ 1

11.4 Putting all replacements together
ğ–¦¹ Now each part of f(n) is written in terms of nÂ²
ğ–¦¹ So:
â€¢ 2nÂ² + 3n + 1 â‰¤ 2nÂ² + 3nÂ² + nÂ²
- Explanation: Add them â†’ 6nÂ²

11.5 Final values
ğ–¦¹ f(n) â‰¤ 6nÂ²
ğ–¦¹ So c = 6
ğ–¦¹ And N = 1

12. Properties of Big-O notation
ğ–¦¹ Big-O has useful rules that help compare how fast functions grow
ğ–¦¹ These rules make it easier to estimate how fast algorithms run

12.1 Fact 1: Transitivity
IMG_URL transitive.png
ğ–¦¹ If f(n) is O(g(n)) and g(n) is O(h(n)), then f(n) is O(h(n))
ğ–¦¹ This means we can connect the two bounds into one
- Explanation: Since f(n) â‰¤ c1Â·g(n) for n â‰¥ N1 and g(n) â‰¤ c2Â·h(n) for n â‰¥ N2, we get f(n) â‰¤ (c1Â·c2)Â·h(n) for large enough n

12.2 Fact 2: Sum rule
IMG_URL sumrule.png
ğ–¦¹ If f(n) is O(h(n)) and g(n) is O(h(n)), then f(n) + g(n) is O(h(n))
- Explanation: If f(n) â‰¤ c1Â·h(n) and g(n) â‰¤ c2Â·h(n), then f(n)+g(n) â‰¤ (c1+c2)Â·h(n)

12.3 Fact 3: Constant times nk
IMG_URL constant.png
ğ–¦¹ The function aÂ·n^k is O(n^k)
- Explanation: aÂ·n^k â‰¤ cÂ·n^k if c â‰¥ a
An Example: Even though 5Â·nÂ³ is big for small n, as n â†’ âˆ, it becomes insignificant compared to nâ´. Multiplying by a constant (5) cannot change the exponent â€” nÂ³ will always grow slower than nâ´ in the long run

12.4 Fact 4: Smaller powers grow slower
IMG_URL smallpower.png
ğ–¦¹ n^k is O(n^(k+j)) for any positive j
- Explanation: This works for c = 1 and N = 1

12.5 Polynomial rule
IMG_URL highestpower.png
ğ–¦¹ A polynomial grows at the rate of its highest power
ğ–¦¹ Example: f(n) = akÂ·n^k + akâˆ’1Â·n^(kâˆ’1) + â€¦ + a1Â·n + a0 is O(n^k)
â€¢ Also, f(n) is O(n^(k+j)) for any positive j

12.6 Logarithmic functions grow very slowly
ğ–¦¹ Algorithms with logarithmic running time are considered very good
ğ–¦¹ Some even slower functions exist, like log log n or constant time O(1), but they are rarely used

12.7 Fact 5: Constant multiple rule
ğ–¦¹ If f(n) = cÂ·g(n), then f(n) is O(g(n))
- Explanation: Multiplying by a fixed constant does not change the growth rate

12.8 Fact 6: Logarithms with any base have the same growth
IMG_URL logdiffbases.png
ğ–¦¹ log_a(n) is O(log_b(n)) for any positive a and b â‰  1
ğ–¦¹ All logarithms grow at the same rate
- Explanation: Using log rules, log_a(n) can be written as a constant Ã— log_b(n)

12.9 Fact 7: Using base 2 for convenience
ğ–¦¹ log_a(n) is O(lg n) for any positive a â‰  1
ğ–¦¹ lg n means log base 2 of n

13. Î© and Î˜ notations
ğ–¦¹ Î© notation gives a lower bound for how fast a function grows
ğ–¦¹ f(n) is Î©(g(n)) when f(n) â‰¥ cÂ·g(n) for all n â‰¥ N
â€¢ Means f grows at least as fast as g in the long run
- Explanation: Only the direction of the inequality changes compared to big-O
In other words, f(n cannot grow slower than g(n) after some point N)

13.1 Relation between Î© and O
ğ–¦¹ f(n) is Î©(g(n)) exactly when g(n) is O(f(n))
ğ–¦¹ Both notations allow many choices of c and N
â€¢ Many different lower bounds are possible for the same f

13.2 Examples of many possible lower bounds
ğ–¦¹ If f(n) is Î©(nÂ²), it is also Î©(n), Î©(nÂ¹áŸÂ²), Î©(nÂ¹áŸÂ³), and so on
ğ–¦¹ Also Î©(log n), Î©(log log n), etc.
- Explanation: Only the largest lower bound is interesting in practice

13.3 Î˜ notation idea
ğ–¦¹ Î˜ notation gives both lower and upper bounds together
ğ–¦¹ f(n) is Î˜(g(n)) if c1Â·g(n) â‰¤ f(n) â‰¤ c2Â·g(n) for all n â‰¥ N
- Explanation: Means f and g grow at the same rate in the long run

13.4 Link between O, Î©, and Î˜
ğ–¦¹ f(n) is Î˜(g(n)) only if f(n) is both O(g(n)) and Î©(g(n))
ğ–¦¹ For the function 2nÂ² + 3n + 1, the simplest Î˜ bound is nÂ²

14. Possible problems with big-O
ğ–¦¹ Big-O hides constants; a large constant can mislead comparisons
ğ–¦¹ Some algorithms may look worse by big-O but are faster for small n
- Explanation: Big-O only cares about the long run and ignores small n

14.1 Example of misleading big-O
ğ–¦¹ Compare 108Â·n and 10Â·nÂ²
ğ–¦¹ First is O(n), second is O(nÂ²)
â€¢ For n â‰¤ 10â·, second one is actually faster
- Explanation: Big-O alone may cause rejecting a better algorithm

14.2 Double-O (OO) notation idea
ğ–¦¹ OO(g(n)) means O(g(n)) but with a constant too large to be useful
ğ–¦¹ Example: 108Â·n is OO(n)
- Explanation: â€œToo largeâ€ depends on the application

15. Examples of complexities
ğ–¦¹ Algorithms can be grouped by how fast their running time grows
ğ–¦¹ Common groups: constant, logarithmic, linear, nÂ·log n, quadratic, cubic, exponential
- Explanation: Growth patterns show which algorithms are practical

15.1 Real-time execution examples
ğ–¦¹ With 1 million operations per second, quadratic on 1M items takes 11+ days
ğ–¦¹ Cubic on 1M items takes thousands of years
â€¢ Even huge hardware improvements help only a little for high-complexity algorithms
- Explanation: Good algorithm design is more important than fast hardware

15.2 Importance of complexity study
ğ–¦¹ Even fast computers cannot save badly designed algorithms
ğ–¦¹ Understanding complexity is essential, especially in data structures

16. Asymptotic complexity idea
ğ–¦¹ Asymptotic bounds help us estimate time and memory needs of algorithms
ğ–¦¹ We mostly study time complexity by counting assignment steps
â€¢ Comparisons are also counted in some cases
- Explanation: We focus on how the total work grows when input size grows

16.1 Simple loop example
ğ–¦¹ Code:
[pink]for[/pink] [yellow](i = sum = 0; i < n; i++)[/yellow]
    [pink]sum[/pink] [yellow]+= a[i];[/yellow]
ğ–¦¹ Two initial assignments, then loop runs n times
â€¢ Each loop step has 2 assignments (sum update and i update)
- Explanation: Total steps = 2 + 2n, so complexity is O(n)

16.2 Nested loop example (sums of subarrays starting at 0)
ğ–¦¹ Code:
[pink]for[/pink] [yellow](i = 0; i < n; i++)[/yellow] {
    [pink]for[/pink] [yellow](j = 1, sum = a[0]; j <= i; j++)[/yellow]
        [pink]sum[/pink] [yellow]+= a[j];[/yellow]
    [yellow]System.out.println(...);[/yellow]
}
ğ–¦¹ Outer loop runs n times; inner loop runs i times for each i
â€¢ Inner loop has 2 assignments per step
- Explanation: Total = 1 + 3n + 2(1+2+â€¦+(nâ€“1)) = O(nÂ²)

16.3 Nested loops but with fixed-size work
ğ–¦¹ We print sums of last five cells of each subarray starting at 0
ğ–¦¹ Code:
[pink]for[/pink] [yellow](i = 4; i < n; i++)[/yellow] {
    [pink]for[/pink] [yellow](j = i-3, sum = a[i-4]; j <= i; j++)[/yellow]
        [pink]sum[/pink] [yellow]+= a[j];[/yellow]
    [yellow]System.out.println(...);[/yellow]
}
â€¢ Outer loop runs nâ€“4 times
â€¢ Inner loop always runs 4 times (constant work)
- Explanation: Total = 1 + 8Â·(nâ€“4) = O(n)

16.4 Loops where iteration count depends on data order
ğ–¦¹ We find length of longest increasing subarray
ğ–¦¹ Code:
[pink]for[/pink] [yellow](i = 0, length = 1; i < n-1; i++)[/yellow] {
    [pink]for[/pink] [yellow](i1 = i2 = k = i; k < n-1 && a[k] < a[k+1]; k++, i2++)[/yellow];
    [pink]if[/pink] [yellow](length < i2 - i1 + 1)[/yellow]
        [pink]length[/pink] [yellow]= i2 - i1 + 1;[/yellow]
    [yellow]System.out.println(...);[/yellow]
}
ğ–¦¹ Worst case (array strictly increasing):
â€¢ Outer loop runs nâ€“1 times, inner loop runs (nâ€“1â€“i) times  
- Explanation: Total = O(nÂ²)
ğ–¦¹ Best case (array strictly decreasing):
â€¢ Inner loop runs once each time  
- Explanation: Total = O(n)

16.5 Binary search complexity
ğ–¦¹ Binary search works by checking the middle of the current array part
ğ–¦¹ Code:
[pink]int[/pink] [yellow]binarySearch(int[] arr, int key) {[/yellow]
    [pink]int[/pink] [yellow]lo = 0, mid, hi = arr.length-1;[/yellow]
    [pink]while[/pink] [yellow](lo <= hi) {[/yellow]
        [yellow]mid = (lo + hi)/2;[/yellow]
        [pink]if[/pink] [yellow](key < arr[mid])[/yellow]
            [yellow]hi = mid - 1;[/yellow]
        [pink]else if[/pink] [yellow](arr[mid] < key)[/yellow]
            [yellow]lo = mid + 1;[/yellow]
        [pink]else return[/pink] [yellow]mid;[/yellow]
    [yellow]}[/yellow]
    [pink]return[/pink] [yellow]-1;[/yellow]
[yellow]}[/yellow]
ğ–¦¹ If key is absent:
â€¢ Checked array sizes go n â†’ n/2 â†’ n/4 â†’ ... â†’ 1
- Explanation: Number of halvings = m where n / 2^m = 1, so m = logâ‚‚ n  
â€¢ Complexity = O(log n)
--END--
--BEGIN--23/11/2025--LINKED LISTS--
1. Arrays and their limitations
ğ–¦¹ Arrays store elements one after another in memory, i.e., sequentially
ğ–¦¹ Limitations of arrays:
â€¢ Fixed size
- To change the size, you must create a new array and copy all data.
â€¢ Sequential memory
- Elements are next to each other in memory.
- Inserting in the middle requires shifting other elements, which is slow.

2. Linked structures
ğ–¦¹ Used to overcome array limitations.
ğ–¦¹ Made of nodes, where each node has:
â€¢ Data
- The value you want to store.
â€¢ Reference(s)
- Links to other nodes.
ğ–¦¹ Nodes can be anywhere in memory.
ğ–¦¹ You move from one node to another using links.

3. Singly Linked List (SLL)
ğ–¦¹ Each node has a link only to its next node (successor).
ğ–¦¹ Nodes are connected like a chain.
ğ–¦¹ Access the list using one variable pointing to the first node.
ğ–¦¹ Last node points to null to indicate the end of the list.
IMG_URL sll.png

4. Singly Linked List (SLL) implementation
ğ–¦¹ Demonstrates creating and linking nodes in a singly linked list.
ğ–¦¹ Code example:
[pink]#include[/pink] <[green]iostream[/green]>
[pink]using[/pink] [pink]namespace[/pink] [green]std[/green];

[pink]class[/pink] [yellow]SLLNode[/yellow] {
    [pink]public[/pink]:
        [blue]int[/blue] [yellow]data[/yellow];
        [yellow]SLLNode*[/yellow] [yellow]next[/yellow];
        [yellow]SLLNode[/yellow]([blue]int[/blue] [yellow]data[/yellow], [yellow]SLLNode*[/yellow] [yellow]next[/yellow]=[green]nullptr[/green]){
            [pink]this[/pink]->[yellow]data[/yellow] = [yellow]data[/yellow];
            [pink]this[/pink]->[yellow]next[/yellow] = [yellow]next[/yellow];
        }
};

[pink]int[/pink] [pink]main[/pink]() {
     ;
    [yellow]SLLNode*[/yellow] [yellow]firstNode[/yellow] = [pink]new[/pink] [yellow]SLLNode[/yellow](2, [yellow]secondNode[/yellow]);
    [green]cout[/green]<<[yellow]firstNode[/yellow]->[yellow]data[/yellow]<<"\n";
    [green]cout[/green]<<[yellow]firstNode[/yellow]->[yellow]next[/yellow]->[yellow]data[/yellow];
    [pink]delete[/pink] [yellow]secondNode[/yellow];
    [pink]delete[/pink] [yellow]firstNode[/yellow];
    [pink]return[/pink] 0;
}
ğ–¦¹ Creates two nodes with data 2 and 3.
ğ–¦¹ Links first node to second node.
ğ–¦¹ Prints data of first and second node.
ğ–¦¹ Frees memory using delete to avoid memory leaks.

5. Adding a Node to Singly Linked List
ğ–¦¹ A singly linked list has a head pointer pointing to the first node.
ğ–¦¹ Each node stores data and a pointer to the next node.
ğ–¦¹ Example C++ implementation:

[pink]#include[/pink] [yellow]<iostream>[/yellow]
[yellow]using namespace std;[/yellow]

[pink]class[/pink] SLLNode {
    [pink]public[/pink]:
        [pink]int[/pink] data;
        SLLNode* next;
        SLLNode([pink]int[/pink] data, SLLNode* next = [green]nullptr[/green]) {
            this->data = data;
            this->next = next;
        }
};

[pink]class[/pink] SinglyLinkedList {
    [pink]private[/pink]:
        SLLNode* head;
    [pink]public[/pink]:
        SinglyLinkedList() {
            head = [green]nullptr[/green];
        }
        void printAll() {
            SLLNode* temp = head;
            while(temp != [green]nullptr[/green]) {
                [green]cout[/green] << temp->data << "->";
                temp = temp->next;
            }
            [green]cout[/green] << "END\n";
        }
        void addNode([pink]int[/pink] value) {
            SLLNode* newNode = [pink]new[/pink] SLLNode(value);
            if(head == [green]nullptr[/green]) {
                head = newNode;
            } else {
                SLLNode* temp = head;
                while(temp->next != [green]nullptr[/green]) {
                    temp = temp->next;
                }
                temp->next = newNode;
            }
        }
};

[pink]int[/pink] [pink]main[/pink]() {
    SinglyLinkedList sll;
    sll.addNode(1);
    sll.addNode(2);
    sll.addNode(3);
    sll.printAll();
    [pink]return[/pink] 0;
}

ğ–¦¹ [pink]addNode[/pink] creates a new node with the given value.
ğ–¦¹ If the list is empty, the new node becomes the head.
ğ–¦¹ If not empty, traverse to the last node and link the new node.
ğ–¦¹ [pink]printAll[/pink] traverses the list and prints all node data followed by "END".

6. Deleting a Node from Singly Linked List
ğ–¦¹ A singly linked list has a head pointer pointing to the first node.
ğ–¦¹ Each node stores data and a pointer to the next node.
ğ–¦¹ Example C++ implementation:

[pink]#include[/pink] [yellow]<iostream>[/yellow]
[yellow]using namespace std;[/yellow]

[pink]class[/pink] SLLNode {
    [pink]public[/pink]:
        [pink]int[/pink] data;
        SLLNode* next;
        SLLNode([pink]int[/pink] data, SLLNode* next = [green]nullptr[/green]) {
            this->data = data;
            this->next = next;
        }
};

[pink]class[/pink] SinglyLinkedList {
    [pink]private[/pink]:
        SLLNode* head;
    [pink]public[/pink]:
        SinglyLinkedList() {
            head = [green]nullptr[/green];
        }
        ~SinglyLinkedList() {  // destructor to free memory
            SLLNode* temp = head;
            while(temp != [green]nullptr[/green]) {
                SLLNode* nextNode = temp->next;
                [pink]delete[/pink] temp;
                temp = nextNode;
            }
        }
        void printAll() {
            SLLNode* temp = head;
            while(temp != [green]nullptr[/green]) {
                [green]cout[/green] << temp->data << "->";
                temp = temp->next;
            }
            [green]cout[/green] << "END\n";
        }
        void addNode([pink]int[/pink] value) {
            SLLNode* newNode = [pink]new[/pink] SLLNode(value);
            if(head == [green]nullptr[/green]) {
                head = newNode;
            } else {
                SLLNode* temp = head;
                while(temp->next != [green]nullptr[/green]) {
                    temp = temp->next;
                }
                temp->next = newNode;
            }
        }
        void deleteNode([pink]int[/pink] value) {
            if(head == [green]nullptr[/green]) {
                [green]cout[/green] << "NOTHING TO DELETE\n";
            } else {
                SLLNode* temp = head;
                SLLNode* prev = [green]nullptr[/green];
                while(temp != [green]nullptr[/green] && temp->data != value) {
                    prev = temp;
                    temp = temp->next;
                }
                if(temp == [green]nullptr[/green]) {
                    [green]cout[/green] << "DATA NOT THERE\n";
                } else if(temp == head) {
                    head = head->next;
                } else {
                    prev->next = temp->next;
                }
                [pink]delete[/pink] temp;
            }
        }
};

[pink]int[/pink] [pink]main[/pink]() {
    SinglyLinkedList sll;
    sll.addNode(1);
    sll.addNode(2);
    sll.addNode(3);
    sll.printAll();
    sll.deleteNode(1);
    sll.printAll();
    sll.deleteNode(11);
    [pink]return[/pink] 0;
}

ğ–¦¹ [pink]deleteNode[/pink] searches for the node with given value.
ğ–¦¹ If the list is empty, it prints "NOTHING TO DELETE".
ğ–¦¹ If the value is not found, it prints "DATA NOT THERE".
ğ–¦¹ If the node is the head, update head to next node.
ğ–¦¹ Otherwise, update previous node's next to skip the deleted node.
ğ–¦¹ The destructor frees all nodes to avoid memory leaks.

7. Singly Linked List Operations and Complexity
ğ–¦¹ Insertion at head: O(1)
â€¢ Create a new node and point it to the current head.
- Very fast because no traversal is needed.
ğ–¦¹ Insertion at tail (without tail pointer): O(n)
â€¢ Traverse from head to the last node.
â€¢ Link the new node after the last node.
- Slower because traversal is needed.
ğ–¦¹ Insertion after a given node: O(1)
â€¢ If you have a pointer to the node, link the new node immediately.
- Constant time insertion.
ğ–¦¹ Deletion of head node: O(1)
â€¢ Move head pointer to the next node.
â€¢ Delete the old head node.
- Fast because no traversal is needed.
ğ–¦¹ Deletion of a node by value: O(n)
â€¢ Traverse the list to find the node with the value.
â€¢ Remove the node and fix links.
- Slower because search may require visiting all nodes.
ğ–¦¹ Searching for a value: O(n)
â€¢ Check each node from head to tail.
- Linear time search.

8. What is a DLL?
IMG_URL dll.png
ğ–¦¹ A list where each node has two links: next and prev
ğ–¦¹ You can move both forward and backward
ğ–¦¹ Helpful when you need two-way movement

9. Node structure
ğ–¦¹ Each node has:
â€¢ data
â€¢ next pointer â†’ goes to next node
â€¢ prev pointer â†’ goes to previous node
ğ–¦¹ First node has prev = NULL
ğ–¦¹ Last node has next = NULL

10. Basic picture
ğ–¦¹ NULL <- [10] <-> [20] <-> [30] -> NULL
11. Doubly Linked List Operations and Complexity
ğ–¦¹ Insertion at head: O(1)
â€¢ Create new node
â€¢ new->next = head
â€¢ head->prev = new
â€¢ head = new
- No need to walk through list
ğ–¦¹ Insertion at tail without tail pointer: O(n)
â€¢ Walk from head to last node
â€¢ last->next = new
â€¢ new->prev = last
- Must visit all nodes
ğ–¦¹ Insertion at tail with tail pointer: O(1)
â€¢ tail->next = new
â€¢ new->prev = tail
â€¢ tail = new
- Very quick
ğ–¦¹ Insertion after a given node: O(1)
â€¢ new->next = node->next
â€¢ new->prev = node
â€¢ Fix next nodeâ€™s prev
â€¢ Fix node->next
- Only pointer updates
ğ–¦¹ Insertion before a given node: O(1)
â€¢ new->prev = node->prev
â€¢ new->next = node
â€¢ Fix prev nodeâ€™s next
â€¢ Fix node->prev
- DLL makes â€œinsert beforeâ€ easy
ğ–¦¹ Deletion of head: O(1)
â€¢ head = head->next
â€¢ head->prev = NULL
â€¢ delete old head
- Very fast
ğ–¦¹ Deletion of tail with tail pointer: O(1)
â€¢ tail = tail->prev
â€¢ tail->next = NULL
â€¢ delete old tail
- No traversal needed
ğ–¦¹ Deletion by value: O(n)
â€¢ Walk to find the value
â€¢ Fix next and prev
â€¢ Delete the node
- Search takes linear time
ğ–¦¹ Searching for a value: O(n)
â€¢ Move node by node
- Same as singly list
ğ–¦¹ Forward traversal: O(n)
â€¢ Use next pointer

ğ–¦¹ Backward traversal: O(n)
â€¢ Use prev pointer
- Only DLL can do backward travel

12. Extra Advanced DLL Operations
ğ–¦¹ Reverse the list: O(n)
â€¢ Swap next and prev for each node
â€¢ Move head to last node
ğ–¦¹ Insert at position k: O(n)
â€¢ Walk to k
â€¢ Insert before or after
ğ–¦¹ Delete at position k: O(n)
â€¢ Walk to k
â€¢ Remove the node

13. Memory Usage
ğ–¦¹ DLL uses more memory than singly lists
â€¢ data
â€¢ next pointer
â€¢ prev pointer
ğ–¦¹ Extra pointer takes more space

14. Advantages of DLL
ğ–¦¹ Move in both directions
ğ–¦¹ Delete easier because prev exists
ğ–¦¹ Insert before any node easily
ğ–¦¹ Good for systems like:
â€¢ LRU cache
â€¢ Browser history
â€¢ Undo-redo
â€¢ Playlist navigation
ğ–¦¹ Fast tail deletion if tail pointer exists

15. Disadvantages of DLL
ğ–¦¹ Uses more memory
ğ–¦¹ More complex to code
ğ–¦¹ Must update two pointers
ğ–¦¹ Mistakes in pointers can break list

16. When to Use DLL
ğ–¦¹ Use DLL when:
â€¢ You need two-way movement
â€¢ You want quick delete after finding node
â€¢ You need undo/redo
â€¢ You want LRU cache
â€¢ You need easy navigation
ğ–¦¹ Do not use DLL when:
â€¢ You want simple structure
â€¢ Memory must be saved
â€¢ Only forward travel is needed
â€¢ Backward travel not needed

17. Doubly Linked List Example Program
[pink]#include[/pink] <iostream>
[pink]using[/pink] [pink]namespace[/pink] std;

[pink]class[/pink] [yellow]DLLNode[/yellow] {
[pink]public[/pink]:
    [pink]int[/pink] [yellow]data[/yellow];
    [blue]DLLNode*[/blue] [yellow]next[/yellow];
    [blue]DLLNode*[/blue] [yellow]prev[/yellow];

    [yellow]DLLNode[/yellow]([pink]int[/pink] [yellow]data[/yellow],
              [blue]DLLNode*[/blue] [yellow]next[/yellow] = [green]nullptr[/green],
              [blue]DLLNode*[/blue] [yellow]prev[/yellow] = [green]nullptr[/green]) {
        [pink]this[/pink]->[yellow]data[/yellow] = [yellow]data[/yellow];
        [pink]this[/pink]->[yellow]next[/yellow] = [yellow]next[/yellow];
        [pink]this[/pink]->[yellow]prev[/yellow] = [yellow]prev[/yellow];
    }
};

[pink]class[/pink] [yellow]DoublyLinkedList[/yellow] {
[pink]private[/pink]:
    [blue]DLLNode*[/blue] [yellow]head[/yellow];

[pink]public[/pink]:
    [yellow]DoublyLinkedList[/yellow]() {
        [yellow]head[/yellow] = [green]nullptr[/green];
    }

    [pink]~DoublyLinkedList[/pink]() {
        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green]) {
            [blue]DLLNode*[/blue] [yellow]nextNode[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
            [pink]delete[/pink] [yellow]temp[/yellow];
            [yellow]temp[/yellow] = [yellow]nextNode[/yellow];
        }
    }

    [pink]void[/pink] [yellow]printAll[/yellow]() {
        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green]) {
            [green]cout[/green] << [yellow]temp[/yellow]->[yellow]data[/yellow] << " <-> ";
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }
        [green]cout[/green] << "END\n";
    }

    [pink]void[/pink] [yellow]addNode[/yellow]([pink]int[/pink] [yellow]value[/yellow]) {
        [blue]DLLNode*[/blue] [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]DLLNode[/yellow]([yellow]value[/yellow]);

        [pink]if[/pink] ([yellow]head[/yellow] == [green]nullptr[/green]) {
            [yellow]head[/yellow] = [yellow]newNode[/yellow];
            [pink]return[/pink];
        }

        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow]->[yellow]next[/yellow] != [green]nullptr[/green]) {
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }

        [yellow]temp[/yellow]->[yellow]next[/yellow] = [yellow]newNode[/yellow];
        [yellow]newNode[/yellow]->[yellow]prev[/yellow] = [yellow]temp[/yellow];
    }

    [pink]void[/pink] [yellow]deleteNode[/yellow]([pink]int[/pink] [yellow]value[/yellow]) {
        [pink]if[/pink] ([yellow]head[/yellow] == [green]nullptr[/green]) {
            [green]cout[/green] << "NOTHING TO DELETE\n";
            [pink]return[/pink];
        }

        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green] &&
               [yellow]temp[/yellow]->[yellow]data[/yellow] != [yellow]value[/yellow]) {
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }

        [pink]if[/pink] ([yellow]temp[/yellow] == [green]nullptr[/green]) {
            [green]cout[/green] << "DATA NOT THERE\n";
            [pink]return[/pink];
        }

        [pink]if[/pink] ([yellow]temp[/yellow] == [yellow]head[/yellow]) {
            [yellow]head[/yellow] = [yellow]head[/yellow]->[yellow]next[/yellow];
            [pink]if[/pink] ([yellow]head[/yellow] != [green]nullptr[/green]) {
                [yellow]head[/yellow]->[yellow]prev[/yellow] = [green]nullptr[/green];
            }
        } [pink]else[/pink] {
            [yellow]temp[/yellow]->[yellow]prev[/yellow]->[yellow]next[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];

            [pink]if[/pink] ([yellow]temp[/yellow]->[yellow]next[/yellow] != [green]nullptr[/green]) {
                [yellow]temp[/yellow]->[yellow]next[/yellow]->[yellow]prev[/yellow] = [yellow]temp[/yellow]->[yellow]prev[/yellow];
            }
        }

        [pink]delete[/pink] [yellow]temp[/yellow];
    }
};

[pink]int[/pink] [yellow]main[/yellow]() {
    [yellow]DoublyLinkedList[/yellow] [yellow]dll[/yellow];

    ;
    ;
    ;

    [yellow]dll[/yellow].[yellow]printAll[/yellow]();

    ;
    [yellow]dll[/yellow].[yellow]printAll[/yellow]();

    ;

    [pink]return[/pink] 0;
}

18. What is a Circularly Linked List (CLL)?
ğ–¦¹ Last node points back to first node, forming a loop
ğ–¦¹ Each node has data and next pointer
ğ–¦¹ Can be singly circular (one next) or doubly circular (next and prev)
ğ–¦¹ No true head or tail; can start from any node
ğ–¦¹ A cursor node marks starting point for operations

19. Structure
ğ–¦¹ Singly Circular:
IMG_URL csll.png
ğ–¦¹ Doubly Circular:
IMG_URL cdll.png

21. Key Concepts
ğ–¦¹ Cursor marks special node for operations
â€¢ back â†’ element at cursor
â€¢ front â†’ element after cursor
ğ–¦¹ Traversal
â€¢ Forward: follow next, eventually cycles back
â€¢ Backward (doubly): follow prev, cycles back
ğ–¦¹ Head/Tail Access
â€¢ Singly circular: tail pointer may be enough
â€¢ Tailâ€™s next points to head

22. Advantages of Circular List
ğ–¦¹ Useful in round-robin scheduling
ğ–¦¹ Can implement playlists, queues, process scheduling
ğ–¦¹ In doubly circular, insertion/deletion at both ends is easy
ğ–¦¹ No end; can cycle infinitely

23. Operations and Complexity
ğ–¦¹ Singly Circular:
â€¢ Add after cursor: O(1)
- Create new node
- newNode->next = cursor->next
- cursor->next = newNode
â€¢ Remove after cursor: O(1)
- Only node â†’ cursor = NULL
- Else â†’ cursor->next = cursor->next->next
- Delete old node
â€¢ Advance cursor: O(1)
- cursor = cursor->next
â€¢ Access front/back: O(1)
- back() = cursor->elem
- front() = cursor->next->elem
ğ–¦¹ Doubly Circular:
â€¢ Insert/delete at head or tail: O(1)
- prev pointer allows direct access to previous node
â€¢ Traversal backward: O(n)
- Can move in reverse without loops

24. Examples of Use
ğ–¦¹ Round-robin process scheduling
â€¢ Each process is a node
â€¢ Cursor moves to next process after execution
ğ–¦¹ Digital Audio Player / Playlist
â€¢ Each song is a node
â€¢ Cursor points to current song
â€¢ Advance moves to next song
â€¢ Add/remove songs after cursor
ğ–¦¹ Example Playlist Sequence
â€¢ Empty list: []
â€¢ Add "StayinAlive": [StayinAlive*]
â€¢ Add "LeFreak": [LeFreak, StayinAlive*]
â€¢ Add "JiveTalkin": [JiveTalkin, LeFreak, StayinAlive*]
â€¢ Advance cursor twice: [StayinAlive, JiveTalkin, LeFreak*]
â€¢ Remove after cursor: [JiveTalkin, LeFreak*]
â€¢ Add "DiscoInferno": [DiscoInferno, JiveTalkin, LeFreak*]

25. Memory Usage
ğ–¦¹ Similar to singly or doubly linked lists
ğ–¦¹ Doubly circular uses extra memory for prev pointers

26. Advantages of Circular Lists
ğ–¦¹ No head/tail limits; perfect for cycling
ğ–¦¹ O(1) insertion and deletion after cursor (or tail in doubly circular)
ğ–¦¹ Forward/backward traversal (doubly circular)
ğ–¦¹ Efficient for playlists, queues, round-robin

27. Disadvantages
ğ–¦¹ Slightly more complex than SLL or DLL
ğ–¦¹ Singly circular: reverse traversal difficult
ğ–¦¹ Must maintain links carefully; broken link breaks cycle

28. Reverse A Linked List
IMG_URL reverse-ll.gif
ğ–¦¹ PSEUDOCODE
function reverseLinkedList(head):
    prev = NULL           // start with prev as NULL
    curr = head           // start at the first node
    
    while curr is not NULL:
        nextNode = curr.next   // remember the next node
        curr.next = prev       // reverse the link
        prev = curr            // move prev forward
        curr = nextNode        // move curr forward
    
    head = prev           // prev is the new head
    return head

29. Skip List
ğ–¦¹ A skip list speeds up search, insertion, and deletion in a sorted linked list
ğ–¦¹ Adds extra "express lanes" or higher-level pointers
ğ–¦¹ Normal linked list: check nodes one by one â†’ slow
ğ–¦¹ Skip list: jump ahead using higher levels, drop down when needed
ğ–¦¹ Example:
â€¢ Level 3: A ------------------> E
â€¢ Level 2: A --------> C ------> E
â€¢ Level 1: A -> B -> C -> D -> E

30. Properties
ğ–¦¹ Elements must be sorted for skipping to work
ğ–¦¹ Multiple levels: top levels few nodes, bottom level all nodes
ğ–¦¹ Randomized levels: each node gets level randomly, balances list probabilistically
ğ–¦¹ Average time: O(log n) for search, insertion, deletion
ğ–¦¹ Space: O(n)

31. Analogy
ğ–¦¹ Like a book with page numbers
â€¢ Normal: read page by page
â€¢ Skip list: table of contents + bookmarks â†’ jump ahead, fine-tune
ğ–¦¹ Faster than normal linked list for sorted data
ğ–¦¹ Simpler than balanced trees like AVL or Red-Black

32. Search â€“ Average O(log n), Worst O(n)
ğ–¦¹ Average:
â€¢ Multiple levels allow skipping many nodes
â€¢ Each step reduces remaining nodes roughly by half
â€¢ Levels â‰ˆ logâ‚‚(n)
â€¢ Horizontal moves small
- Total steps â‰ˆ logâ‚‚(n) â†’ O(log n)
ğ–¦¹ Worst case:
â€¢ All nodes at level 1 â†’ behaves like normal linked list
â€¢ Traverse all n nodes â†’ O(n)

33. Insertion â€“ Average O(log n)
ğ–¦¹ Search for correct position (average O(log n))
ğ–¦¹ Insert node at all its levels (update pointers)
ğ–¦¹ Randomized level assignment limits number of levels per node
- Average insertion â‰ˆ O(log n)
- Worst case rare: all nodes at level 1 â†’ O(n)

34. Deletion â€“ Average O(log n)
ğ–¦¹ Search for node (average O(log n))
ğ–¦¹ Update pointers of predecessors at all levels
ğ–¦¹ Same reasoning as insertion â†’ total cost â‰ˆ O(log n)

35. Space â€“ O(n)
ğ–¦¹ Each node stores array of next pointers = nodeâ€™s level
ğ–¦¹ Average node level small (â‰ˆ 2) â†’ extra memory per node constant
ğ–¦¹ Total nodes = n â†’ total space O(n)

36. What is a Skip List
ğ–¦¹ An advanced linked list with multiple levels of forward pointers
ğ–¦¹ Faster search, insertion, and deletion using express lanes
ğ–¦¹ Each node has a randomly assigned level
ğ–¦¹ Search starts from top level and goes down

37. Node Levels
ğ–¦¹ Each node can have multiple levels = number of forward pointers
ğ–¦¹ Higher levels skip more nodes
ğ–¦¹ Levels assigned randomly to balance the list
ğ–¦¹ Example:
â€¢ Nodes: 1 2 3 4 5 6 7
â€¢ Levels: 1â†’5, 2â†’2, 3â†’3, 4â†’1, 5â†’2, 6â†’1, 7â†’1

38. How Search Works
ğ–¦¹ Start at header node, topmost level
ğ–¦¹ Move forward while next nodeâ€™s key < search key
ğ–¦¹ Drop down one level if next is nullptr or â‰¥ key
ğ–¦¹ Repeat until level 0
ğ–¦¹ curr points to predecessor â†’ check level 0:
â€¢ curr = curr->forward[0]; if curr != nullptr && curr->key == key found
- Step forward at level 0 because curr ends as largest node < key

39. Why Skip List is Fast
ğ–¦¹ Multiple levels allow jumping over nodes
ğ–¦¹ Average search = O(log n)
ğ–¦¹ Worst case = O(n) if all nodes end at level 0
ğ–¦¹ Space = O(n)

40. Example Search (key = 5)
ğ–¦¹ Nodes & levels: 1(5), 2(2), 3(3), 4(1), 5(2), 6(1), 7(1)
ğ–¦¹ Steps:
â€¢ Start at node 1, level 5 â†’ forward[5]=6 â†’ 6>5 â†’ drop to level 4
â€¢ Level 4 â†’ forward[4]=5 â†’ candidate? curr still points to 1
â€¢ Move forward level 0: curr=curr->forward[0] â†’ points to 5 â†’ key==5 âœ…

41. Key Operations
ğ–¦¹ Search: Avg O(log n), Worst O(n)
ğ–¦¹ Insertion: Avg O(log n)
ğ–¦¹ Deletion: Avg O(log n)
ğ–¦¹ Space: O(n)

42. Express Lanes Analogy
ğ–¦¹ Level >0 pointers = express lanes
ğ–¦¹ Level 0 pointers = normal linked list
ğ–¦¹ Node 1 level 5 can jump over nodes 2,3,4,5 to reach 6
ğ–¦¹ Nodes exist at multiple levels via random assignment

43. C++ Implementation
ğ–¦¹ Includes header, random, time libraries
ğ–¦¹ [pink]class[/pink] [yellow]Node[/yellow] with [yellow]key[/yellow], [blue]forward[/blue], [yellow]nodeLevel[/yellow]
ğ–¦¹ [pink]class[/pink] [yellow]SkipList[/yellow] with [yellow]level[/yellow] and [yellow]header[/yellow]
ğ–¦¹ Random level generator: 0.5 probability to go up
ğ–¦¹ [pink]insert[/pink](key): find position, assign random level, update forward pointers
ğ–¦¹ [pink]search[/pink](key): move top-down, return found/not found
ğ–¦¹ [pink]printList[/pink](): print all levels
ğ–¦¹ [pink]main[/pink](): create skip list, insert keys, print list, search keys
â€¢ Code Example:
[pink]#include[/pink] <yellow>iostream</yellow>  
[pink]#include[/pink] <yellow>cstdlib</yellow>  
[pink]#include[/pink] <yellow>ctime</yellow>  
using namespace <green>std</green>;  

const int MAX_LEVEL = 4;  

[pink]class[/pink] [yellow]Node[/yellow] {  
public:  
    int key;  
    [blue]Node**[/blue] forward;  
    int nodeLevel;  
    [pink]Node[/pink](int key, int level) { /* create forward array */ }  
};  

[pink]class[/pink] [yellow]SkipList[/yellow] {  
private:  
    int level;  
    [blue]Node*[/blue] header;  
public:  
    [pink]SkipList[/pink]() { /* init header */ }  
    int randomLevel() { /* 0.5 probability */ }  
    void insert(int key) { /* insert node */ }  
    bool search(int key) { /* search node */ }  
    void printList() { /* print levels */ }  
};  

[pink]int[/pink] [pink]main[/pink]() {  
    srand(time(0));  
    SkipList list;  
    list.insert(3); list.insert(6); /* insert more */  
    list.printList();  
    list.search(9); list.search(15);  
    return 0;  
}

44. Self-Organizing Lists
ğ–¦¹ Normal linked list is slow for search because you check nodes one by one
ğ–¦¹ Self-organizing lists reorder nodes dynamically to speed up search for frequent items

45. Move-to-Front Method
ğ–¦¹ After finding an element, move it to the beginning
ğ–¦¹ Frequently searched items stay near the front
ğ–¦¹ Example: A B C D, search D â†’ D A B C

46. Transpose Method
ğ–¦¹ After finding an element, swap it with the previous node
ğ–¦¹ Element moves gradually toward front
ğ–¦¹ Example: A B C D, search D â†’ swap with C â†’ A B D C

47. Count Method
ğ–¦¹ Keep a count of how many times each element is accessed
ğ–¦¹ Sort list so most accessed elements are near front
ğ–¦¹ Example: D accessed 3 times, B accessed 1 time â†’ D comes before B

48. Ordering Method
ğ–¦¹ Keep list sorted by natural order (alphabetical, birthday, salary)
ğ–¦¹ Position of elements does not change dynamically
ğ–¦¹ Example: Alice, Bob, Charlie, David

49. How New Data is Inserted
ğ–¦¹ In move-to-front, transpose, count methods: new data goes to end of list
ğ–¦¹ In ordering method: insert at correct position to maintain order

50. Why This Helps
ğ–¦¹ Frequently searched items stay near front â†’ fewer steps to find
ğ–¦¹ Useful for repeated searches in a data stream
ğ–¦¹ In ordering method, can stop early if element doesnâ€™t exist because list is sorted

51. Inserting a Node in the Middle of a Doubly Linked List
ğ–¦¹ To insert in the middle, first find the middle node
ğ–¦¹ Use two pointers: slow and fast
â€¢ [yellow]slow[/yellow] moves 1 step at a time
â€¢ [yellow]fast[/yellow] moves 2 steps at a time
â€¢ When [yellow]fast[/yellow] reaches end (nullptr), [yellow]slow[/yellow] points to middle
- Code:
[pink]while[/pink] ([yellow]fast[/yellow] != [green]nullptr[/green] && [yellow]fast[/yellow]->next != [green]nullptr[/green]) {
    [yellow]slow[/yellow] = [yellow]slow[/yellow]->next;       // 1 step
    [yellow]fast[/yellow] = [yellow]fast[/yellow]->next->next; // 2 steps
}
ğ–¦¹ Once middle node is found, insert new node before or after it
â€¢ Adjust [yellow]prev[/yellow] and [yellow]next[/yellow] pointers of surrounding nodes

52. Adapting Binary Search to Linked Lists
ğ–¦¹ Linked lists donâ€™t allow direct index access like arrays
ğ–¦¹ Binary search needs O(n) to reach middle each time
ğ–¦¹ So total time = O(n) + O(n/2) + O(n/4) + ... â‰ˆ O(n)
- Not as efficient as array binary search (O(log n))
ğ–¦¹ Works logically but practically slower for large lists

53. Unrolled Linked List
ğ–¦¹ A linked list variation where each node stores multiple elements in an array plus a pointer to next node.
ğ–¦¹ Purpose: reduce pointer overhead, improve cache performance, and reduce wasted memory.
ğ–¦¹ Acts like a mix between arrays and linked lists: dynamic insertion/deletion like linked lists but stores chunks to reduce overhead.

54. Node Structure
ğ–¦¹ Each node has:
â€¢ [yellow]next[/yellow] pointer (and optionally [yellow]prev[/yellow] for doubly)
â€¢ [yellow]numElements[/yellow] â†’ number of actual elements
â€¢ [yellow]elements[][/yellow] â†’ array of capacity [yellow]maxElements[/yellow]
- Typically nodes aim to be at least half full for efficiency
- Example:
[pink]record[/pink] [yellow]node[/yellow] {
   [yellow]node next[/yellow];
   [pink]int[/pink] [yellow]numElements[/yellow];
   [yellow]array elements[/yellow];
}

55. Capacity / Block Size
ğ–¦¹ Choose [yellow]maxElements[/yellow] so each node fits well into cache lines
ğ–¦¹ Example: each node fills one cache line or a small multiple

56. List Layout
ğ–¦¹ Nodes chained: Node1 â†’ Node2 â†’ Node3 â€¦
ğ–¦¹ Each node has an array of elements, e.g., Node1: [1,2,3,4], Node2: [5,6,7,8]
ğ–¦¹ Doubly unrolled list: nodes also have [yellow]prev[/yellow] pointer

57. Search / Traversal
ğ–¦¹ Traverse nodes until correct node found, then search inside nodeâ€™s array
ğ–¦¹ Reduces pointer hops because nodes hold multiple elements
ğ–¦¹ Example: n elements, block size ~âˆšn â†’ ~âˆšn nodes, each ~âˆšn size â†’ search ~O(âˆšn)

58. Insertion
ğ–¦¹ Find node where insertion belongs
ğ–¦¹ If node has space â†’ insert in array (shift if needed)
ğ–¦¹ If node full â†’ split node, move half elements to new node, insert new element

59. Deletion
ğ–¦¹ Find elementâ€™s node, remove from array, shift items
ğ–¦¹ If node falls below threshold (e.g., < half full) â†’ merge with neighbor or rebalance

60. Advantages
ğ–¦¹ Reduced pointer overhead: one pointer per node instead of per element
ğ–¦¹ Better cache performance: contiguous memory access inside node
ğ–¦¹ More efficient than plain linked lists for dynamic sequences

61. Disadvantages / Trade-offs
ğ–¦¹ Slightly complex: splitting/merging nodes, managing arrays inside nodes
ğ–¦¹ Large block size with few elements wastes space
ğ–¦¹ Within-node search is linear unless extra indexing used
ğ–¦¹ Worst-case time may still be linear in number of nodes

62. Complexity Summary
ğ–¦¹ Let n = total elements, B = block size
ğ–¦¹ Number of nodes â‰ˆ n/B
ğ–¦¹ Search = O(n/B + B)
ğ–¦¹ Insert/Delete = O(B) (may involve split/merge)
ğ–¦¹ Space overhead per element reduced compared to plain linked list

63. Example: 16 elements, block size 4
ğ–¦¹ Nodes: Node1: [1,2,3,4] â†’ Node2: [5,6,7,8] â†’ Node3: [9,10,11,12] â†’ Node4: [13,14,15,16]
ğ–¦¹ Search 7: traverse Node1 â†’ Node2, then linear scan inside Node2 â†’ 5 comparisons vs 7 in normal linked list
ğ–¦¹ Worst-case search 16: 3 node traversals + 4 inside-node â†’ 7 comparisons vs 16 in normal linked list

64. Choosing Block Size B
ğ–¦¹ Too small â†’ behaves like normal linked list
ğ–¦¹ Too large â†’ inside-node search slow
ğ–¦¹ Sweet spot: B â‰ˆ âˆšn â†’ search O(âˆšn)
ğ–¦¹ Example: n=10,000 â†’ B=100 â†’ ~100 nodes, inside-node scan â‰¤ 100 â†’ ~200 comparisons

65. C++ Program for Unrolled Linked List
[pink]#include[/pink] <[green]iostream[/green]>
[pink]#include[/pink] <[green]vector[/green]>
[pink]using[/pink] [pink]namespace[/pink] [green]std[/green];

[pink]class[/pink] [yellow]Node[/yellow] {
[pink]public[/pink]:
    [green]vector[/green]<[blue]int[/blue]> [yellow]elements[/yellow];
    [yellow]Node[/yellow]* [yellow]next[/yellow];
    [blue]int[/blue] [yellow]capacity[/yellow];

    [pink]Node[/pink]([blue]int[/blue] [yellow]cap[/yellow]) {
        [yellow]capacity[/yellow] = [yellow]cap[/yellow];
        [yellow]next[/yellow] = [green]nullptr[/green];
    }
};

[pink]class[/pink] [yellow]UnrolledLinkedList[/yellow] {
[pink]private[/pink]:
    [yellow]Node[/yellow]* [yellow]head[/yellow];
    [blue]int[/blue] [yellow]nodeCapacity[/yellow];

[pink]public[/pink]:
    [pink]UnrolledLinkedList[/pink]([blue]int[/blue] [yellow]cap[/yellow]) {
        [yellow]nodeCapacity[/yellow] = [yellow]cap[/yellow];
        [yellow]head[/yellow] = [pink]new[/pink] [yellow]Node[/yellow]([yellow]nodeCapacity[/yellow]);
    }

    [pink]void[/pink] [yellow]insert[/yellow]([blue]int[/blue] [yellow]val[/yellow]) {
        [yellow]Node[/yellow]* [yellow]curr[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]curr[/yellow]->[yellow]next[/yellow] != [green]nullptr[/green])
            [yellow]curr[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];

        [pink]if[/pink] ([yellow]curr[/yellow]->[yellow]elements[/yellow].[green]size[/green]() < [yellow]curr[/yellow]->[yellow]capacity[/yellow]) {
            [yellow]curr[/yellow]->[yellow]elements[/yellow].[green]push_back[/green]([yellow]val[/yellow]);
        } [pink]else[/pink] {
            [yellow]Node[/yellow]* [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]Node[/yellow]([yellow]nodeCapacity[/yellow]);
            [yellow]newNode[/yellow]->[yellow]elements[/yellow].[green]push_back[/green]([yellow]val[/yellow]);
            [yellow]curr[/yellow]->[yellow]next[/yellow] = [yellow]newNode[/yellow];
        }
    }

    [pink]bool[/pink] [yellow]search[/yellow]([blue]int[/blue] [yellow]val[/yellow]) {
        [yellow]Node[/yellow]* [yellow]curr[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]curr[/yellow] != [green]nullptr[/green]) {
            [pink]if[/pink] (![yellow]curr[/yellow]->[yellow]elements[/yellow].[green]empty[/green]() && [yellow]val[/yellow] <= [yellow]curr[/yellow]->[yellow]elements[/yellow].[green]back[/green]()) {
                [pink]for[/pink] ([blue]int[/blue] [yellow]x[/yellow] : [yellow]curr[/yellow]->[yellow]elements[/yellow]) {
                    [pink]if[/pink] ([yellow]x[/yellow] == [yellow]val[/yellow]) {
                        [green]cout[/green] << "Found " << [yellow]val[/yellow] << " in node.\n";
                        [pink]return[/pink] [green]true[/green];
                    }
                }
                [pink]return[/pink] [green]false[/green];
            }
            [yellow]curr[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];
        }
        [green]cout[/green] << [yellow]val[/yellow] << " not found in list.\n";
        [pink]return[/pink] [green]false[/green];
    }

    [pink]void[/pink] [yellow]printList[/yellow]() {
        [yellow]Node[/yellow]* [yellow]curr[/yellow] = [yellow]head[/yellow];
        [blue]int[/blue] [yellow]nodeId[/yellow] = 1;
        [pink]while[/pink] ([yellow]curr[/yellow] != [green]nullptr[/green]) {
            [green]cout[/green] << "Node " << [yellow]nodeId[/yellow] << ": ";
            [pink]for[/pink] ([blue]int[/blue] [yellow]x[/yellow] : [yellow]curr[/yellow]->[yellow]elements[/yellow])
                [green]cout[/green] << [yellow]x[/yellow] << " ";
            [green]cout[/green] << [green]endl[/green];
            [yellow]curr[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];
            [yellow]nodeId[/yellow]++;
        }
    }
};

[pink]int[/pink] [pink]main[/pink]() {
    [blue]int[/blue] [yellow]nodeCapacity[/yellow] = 4;
    [yellow]UnrolledLinkedList[/yellow] [yellow]list[/yellow]([yellow]nodeCapacity[/yellow]);

    [pink]for[/pink] ([blue]int[/blue] [yellow]i[/yellow] = 1; [yellow]i[/yellow] <= 16; [yellow]i[/yellow]++)
        [yellow]list[/yellow].[yellow]insert[/yellow]([yellow]i[/yellow]);

    [yellow]list[/yellow].[yellow]printList[/yellow]();

     ;
     ;
     ;

    [pink]return[/pink] 0;
}

--END--