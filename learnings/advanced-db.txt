SOURCE: Elmasri & Navathe â€“ â€œDatabase System Conceptsâ€ by Abraham Silberschatz, Henry F. Korth and S. Sudarshan.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -[07/11/2025]
1. Database-Management System (DBMS)
ğ–¦¹ A DBMS is a collection of interrelated data and programs to access the data.
ğ–¦¹ The collection of data is called the database and contains information relevant to an enterprise.
ğ–¦¹ Main goal: Store and retrieve information conveniently and efficiently.

2. Purpose of Database Systems
ğ–¦¹ Used to manage large amounts of information.
ğ–¦¹ Involves defining storage structures and providing methods to manipulate data.
ğ–¦¹ Must ensure safety of data even during system crashes or unauthorized access attempts.
ğ–¦¹ Must prevent anomalies when data is shared by multiple users.

3. Importance of DBMS Concepts
ğ–¦¹ Information is vital in organizations.
ğ–¦¹ Computer scientists developed many concepts and techniques for effective data management.
ğ–¦¹ These concepts form the foundation of database systems.

4. Representative Applications of Database Systems
ğ–¦¹ Enterprise Information: Sales, accounting, human resources.
ğ–¦¹ Manufacturing: Supply chain, production tracking, inventory.
ğ–¦¹ Banking and Finance: Accounts, loans, transactions, stock trading.
ğ–¦¹ Universities: Student info, grades, course registrations.
ğ–¦¹ Airlines: Reservations and scheduling.
ğ–¦¹ Telecommunication: Call/data records, billing, prepaid balance.
ğ–¦¹ Web-Based Services: Social media: users, posts, follower networks.
ğ–¦¹ Document Databases: Articles, patents, research papers.
ğ–¦¹ Navigation Systems: Geographic locations, transport routes.

5. Purpose of Database Systems
ğ–¦¹ Universities maintain data about instructors, students, departments, and courses.
ğ–¦¹ A file-based system stores data in separate operating-system files with many separate application programs.
ğ–¦¹ New departments or rules require new files and new application programs.
ğ–¦¹ Over time, the system becomes large, complex, and hard to manage.

6. Problems in File-Processing Systems
ğ–¦¹ Data Redundancy and Inconsistency
   â€¢ Same data stored in multiple places increases storage and access cost.
   â€¢ Different copies of data may disagree (e.g., student address updated in one file but not another).
ğ–¦¹ Difficulty in Accessing Data
   â€¢ New data requests require new custom programs.
   â€¢ Retrieving needed information may require manual filtering or additional programming effort.
ğ–¦¹ Data Isolation
   â€¢ Data is stored in multiple files with different formats.
   â€¢ Hard to write new programs to fetch combined data.
ğ–¦¹ Integrity Problems
   â€¢ Data must satisfy constraints (e.g., account balance â‰¥ 0).
   â€¢ Constraints are implemented in many programs â†’ hard to update consistently.
ğ–¦¹ Atomicity Problems
   â€¢ Failures may leave data in inconsistent states.
   â€¢ A transaction (e.g., transferring money) must happen entirely or not at all.
ğ–¦¹ Concurrent-Access Anomalies
   â€¢ Multiple users updating data simultaneously can lead to incorrect results.
   â€¢ Example: Two clerks updating the same account or concurrent course registrations causing incorrect counts.
ğ–¦¹ Security Problems
   â€¢ Not all users should access all data.
   â€¢ Hard to enforce security rules when programs are added in an ad-hoc manner.

7. Motivation for Database Systems
ğ–¦¹ These problems led to the development of database systems in the 1960sâ€“1970s.
ğ–¦¹ Database systems provide solutions for redundancy control, efficient access, integrity enforcement, atomicity, concurrency control, and security.

8. View of Data
ğ–¦¹ A database system provides users with an abstract view of data.
ğ–¦¹ It hides details of how data is stored and maintained internally.

9. Data Models
ğ–¦¹ A data model is a set of concepts used to describe data, relationships, and constraints.
ğ–¦¹ Four major categories of data models:
   â€¢ Relational Model
     - Uses tables (relations) to represent data and relationships.
     - Each table has rows (records) and columns (attributes).
     - Most widely used model; basis of SQL and modern DBMSs.
   â€¢ Entityâ€“Relationship (E-R) Model
     - Uses entities (objects) and relationships among them.
     - Useful for database design and conceptual modeling.
   â€¢ Semi-Structured Data Model
     - Allows different data items of the same type to have different attributes.
     - Data formats like JSON and XML fall under this model.
   â€¢ Object-Based Data Model
     - Integrates object-oriented programming concepts with databases.
     - Supports objects, methods, encapsulation, and object identity within DB systems.

10. Relational Data Model
ğ–¦¹ Data is represented using tables with uniquely named columns.
ğ–¦¹ Each row of a table represents one record.
ğ–¦¹ Example: instructor table and department table in a university database.

11. Data Abstraction
ğ–¦¹ Used to simplify how users interact with stored data.
ğ–¦¹ Three levels of data abstraction:
   â€¢ Physical Level
     - Describes how data is actually stored (storage structures, indexes, byte layout).
   â€¢ Logical Level
     - Describes what data is stored and the relationships among data.
     - Hides physical-level details â†’ provides *physical data independence*.
   â€¢ View Level
     - Provides different views to different users.
     - Hides logical-level complexity and acts as a security boundary.

12. Instances and Schemas
ğ–¦¹ Instance = The data stored in the database at a specific moment.
ğ–¦¹ Schema = The overall structure or design of the database.
ğ–¦¹ Types of schemas:
   â€¢ Physical Schema â†’ storage-level design.
   â€¢ Logical Schema â†’ the logical structure (tables, relationships).
   â€¢ View Schemas â†’ user-specific views of data.
ğ–¦¹ Application programs should not depend on physical schema â†’ physical data independence.

13. Database Languages
ğ–¦¹ A database uses a Data-Definition Language (DDL) to define database schema.
ğ–¦¹ It uses a Data-Manipulation Language (DML) to express queries and updates.
ğ–¦¹ In practice, DDL and DML are part of a single database language such as SQL.
ğ–¦¹ Almost all relational database systems use SQL.

14. Data-Definition Language (DDL)
ğ–¦¹ Used to specify the database schema by defining structure and properties of data.
ğ–¦¹ Storage structure and access methods are defined using a special form of DDL called data storage and definition language.
   â€¢ These details define how data is stored internally and are hidden from end users.
ğ–¦¹ DDL allows specification of consistency constraints that must be satisfied by database values.
   â€¢ These constraints are checked whenever updates occur.
â €â €â €â €â €â €â €â €â €â£ â¢¤â ¤â¢¤â¡€â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â£€â£€â£€â¡œâ »â ¿â¢¾â£·â ¹â €â €â €â €â£€â£¤â£¤â¡€â €â €â €â €
â €â €â €â¢ â¡â â €â €â ƒâ €â €â €â ‰â €â €â €â¡ â â ›â ›â »â¢½â €â €â €â €
â €â €â €â ¸â£·â¡€â €â¢€â €â¢‚â €â¡€â €â €â €â œâ €â €â €â €â¡€â ¸â €â ¤â¢„â €
â €â €â €â €â ™â£—â£„â €â  â¡€â¢¢â ƒâ €â¢¸â Œâ €â¡ â¢Šâ €â Šâ €â €â €â €â €â¡‡
â €â €â €â£€â£€â£ˆâ£²â£•â£¦â¡ˆâ ¢â£»â¡€â¡â¢€â£´â¡¢â ‘â ‚â â €â €â €â €â¡ â ƒ
â €â£´â ¿â ½â â €â €â €â ˆâ ‰â¢’â£ºâ£·â£—â£‰â£â£€â£€â£€â €â  â ¤â â ˆâ €â €
â¢¸â €â €â €â €â €â €â €â¢€â  â¡–â â£¿â¢³â¡¬â¡â ’â ’â ¤â¢„â¡€â €â €â €â €â €
â ˆâ¢¦â¡€â €â €â¡€â „â ‚â â Šâ €â¢°â£¯â¡â â¢Œâ ‘â €â €â €â ˆâ ‘â¢„â €â €â €
â €â €â ‰â¡»â €â €â €â €â €â €â£²â¡Ÿâ¡Ÿâ €â €â €â ¢â¡€â €â €â €â €â¢¸â €â €â €
â €â €â €â¢§â£¤â¡„â¡€â €â¢€â¡”â£½â ƒâ¢§â¡„â €â €â €â °â£€â €â €â£€â â €â €â €
â €â €â €â ˆâ ³â ¬â ¥â ”â ‹â¡œâ¡Œâ €â ˜â£¿â£¦â£€â €â¡€â¡‡â ‰â ‰â €â €â €â €â €
â €â €â €â €â €â €â €â¢€â œâ¡°â €â €â €â ˆâ ›â ¯â ¥â ’â â €â €â €â €â €â €â €
â €â €â €â €â €â €â¡ â Šâ¡œâ €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â£›â Šâ €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €

â­ DSDL
ğ–¦¹ SQL is widely known as DDL (data definition language), DML (data manipulation language), and VDL (view definition language), but it has also been described as SDL (storage definition language).
ğ–¦¹ SDL defines how data is physically stored, not the data itself.
ğ–¦¹ Examples of SDL include vendor-specific commands like `SET storage_engine=MYISAM;` in MySQL.
ğ–¦¹ SDL is not part of the SQL standard; it deals with physical storage, indexing, and data placement.
ğ–¦¹ SQL focuses on conceptual and external schemas, while SDL handles internal schemas for storage optimization.
ğ–¦¹ Early SQL versions included SDL commands, but these were removed to keep SQL at conceptual and external levels.
ğ–¦¹ In practice, DBAs use functions, parameters, and storage specifications to control file storage and indexing.
ğ–¦¹ Modern SQL integrates DDL, DML, and VDL into a comprehensive language, but storage definitions remain separate.
ğ–¦¹ Three-schema architecture (1970s) inspired the distinction between DDL, VDL, and SDL.
ğ–¦¹ Historical references include "Database Sublanguage Faculty" and "View Translation Layer" (1980).
ğ–¦¹ Example: CREATE TABLE f (x int, y varchar(25));
   â€¢ SDL defines how x and y are stored.
   â€¢ DDL defines the table schema: f(x,y) as a relational tuple.
   â€¢ VDL defines the view, usually the table name itself.
ğ–¦¹ Many databases extend SDL to include indexes and storage backends, which are separate from the conceptual model.
ğ–¦¹ Other terms and systems related to SDL: DSDL (Data Storage Definition Language), CODASYL, RDL, NDL, IRDIS.

â­ Summary of Database Languages
ğ–¦¹ DDL defines the structure of the database: tables, columns, constraints, and indexes.
ğ–¦¹ VDL defines how data is presented via views without affecting physical storage.
ğ–¦¹ SDL defines physical storage details, including tablespaces, filegroups, and storage allocation.
ğ–¦¹ Each language serves a distinct purpose but may overlap in commands or functionality in modern DBMSs.
ğ–¦¹ DDL and VDL are usually visible to end users through queries, while SDL is managed by DBAs for performance and storage optimization.
ğ–¦¹ Examples:
   â€¢ DDL: CREATE TABLE Employees (EmpID INT PRIMARY KEY, Name VARCHAR(50), Department VARCHAR(30), Salary DECIMAL(10,2));
   â€¢ VDL: CREATE VIEW DeptSalary AS SELECT Department, AVG(Salary) AS AvgSalary FROM Employees GROUP BY Department;
   â€¢ SDL (Oracle): CREATE TABLE Employees (...) TABLESPACE Users STORAGE (INITIAL 5M NEXT 5M MAXEXTENTS UNLIMITED);
   â€¢ SDL (SQL Server): CREATE TABLE Employees (...) ON [Primary];
   â€¢ SDL (PostgreSQL): CREATE TABLE Employees (...) TABLESPACE pg_default;


15. Integrity Constraints in DDL
ğ–¦¹ Domain Constraints
   â€¢ Each attribute must have an associated domain (e.g., integer, character, date/time).
   â€¢ Acts as a basic integrity check performed whenever new data is inserted.
ğ–¦¹ Referential Integrity
   â€¢ Ensures that values in one relation match values in another.
   â€¢ Example: dept_name in course must exist in department relation.
   â€¢ If violated, the database system rejects the operation causing the violation.
ğ–¦¹ Authorization
   â€¢ Controls which users can perform which operations.
   â€¢ Common types:
     - Read authorization: can read data but not modify.
     - Insert authorization: can add new data.
     - Update authorization: can modify existing data.
     - Delete authorization: can remove data.
   â€¢ A user may have any combination of these permissions.

16. Data Dictionary
ğ–¦¹ DDL processing generates output stored in the data dictionary.
ğ–¦¹ The data dictionary stores metadata (data about data).
ğ–¦¹ Only the database system can directly access or update the data dictionary.
ğ–¦¹ The system consults the data dictionary before reading or modifying actual data.

17. SQL Data-Definition Language
ğ–¦¹ SQL provides a rich DDL to define tables with data types and integrity constraints.
ğ–¦¹ Example table creation:
   create table department
   (dept_name char(20),
    building char(15),
    budget numeric(12,2));
   â€¢ This creates a department table with three attributes and associated data types.
ğ–¦¹ SQL allows specifying constraints such as:
   â€¢ Primary key â†’ ensures uniqueness of dept_name.
   â€¢ Referential integrity â†’ ensures dept_name in instructor must appear in department table.

18. Data-Manipulation Language (DML)
ğ–¦¹ A DML enables users to access or manipulate data organized by the data model.
ğ–¦¹ Types of access provided by DML:
   â€¢ Retrieval of information stored in the database.
   â€¢ Insertion of new information into the database.
   â€¢ Deletion of information from the database.
   â€¢ Modification of existing information.
ğ–¦¹ Types of DML:
   â€¢ Procedural DML:
     - User specifies what data are needed and how to retrieve them.
      -- Step 1: Find employees in 'Sales' department
      OPEN cursor FOR
      SELECT * FROM Employees WHERE Department = 'Sales';
      -- Step 2: Fetch each row and process it
      FETCH NEXT FROM cursor INTO @EmpID, @Name, @Salary;
      WHILE @@FETCH_STATUS = 0
      BEGIN
          PRINT @Name + ' earns ' + CAST(@Salary AS VARCHAR);
          FETCH NEXT FROM cursor INTO @EmpID, @Name, @Salary;
      END
      CLOSE cursor;
   â€¢ Declarative (Nonprocedural) DML:
     - User specifies what data are needed without specifying how to retrieve them.
      SELECT Name, Salary
      FROM Employees
      WHERE Department = 'Sales';

ğ–¦¹ Declarative DMLs are easier to learn and use compared to procedural DMLs.
ğ–¦¹ Since declarative DML does not specify how to get the data, the database system must decide the efficient access method.
ğ–¦¹ A query is a statement requesting retrieval of information.
ğ–¦¹ The part of DML dealing with data retrieval is called a query language.
ğ–¦¹ Commonly, the terms "query language" and "data-manipulation language" are used interchangeably.
ğ–¦¹ SQL is the most widely used query language.
ğ–¦¹ Levels of abstraction apply to both defining data and manipulating data:
   â€¢ Physical level: focuses on efficient data access algorithms.
   â€¢ Higher levels: emphasize ease of use for users.
ğ–¦¹ The query processor translates DML queries into sequences of physical-level operations.

19. The SQL Data-Manipulation Language
ğ–¦¹ SQL is a nonprocedural query language.
ğ–¦¹ A query takes one or more tables as input and always returns a single table as output.
ğ–¦¹ Example query to retrieve names of instructors in the History department:
   â€¢ select instructor.name
     from instructor
     where instructor.dept_name = 'History';
   - Output: A table with a single column (name) and rows for instructors in the History department.
ğ–¦¹ Queries may retrieve data from multiple tables.
ğ–¦¹ Example query to find IDs and department names of instructors in departments with budget > 95000:
   â€¢ select instructor.ID, department.dept_name
     from instructor, department
     where instructor.dept_name = department.dept_name
       and department.budget > 95000;
   - Output: A table with instructor ID and department name for matching records.

20. Database Access from Application Programs
ğ–¦¹ SQL alone is not as powerful as a general-purpose programming language.
ğ–¦¹ SQL cannot perform:
   â€¢ User input operations.
   â€¢ Display/output operations.
   â€¢ Network communication.
ğ–¦¹ For such operations, application programs are written in host languages like C/C++, Java, or Python.
ğ–¦¹ These application programs contain embedded SQL queries to interact with the database.
ğ–¦¹ Examples of such application programs in a university system:
   â€¢ Course registration systems.
   â€¢ Class roster generation.
   â€¢ GPA calculation systems.
   â€¢ Payroll processing systems.
ğ–¦¹ To send DML statements from the host program to the database, application program interfaces are used.
ğ–¦¹ ODBC standard provides interfaces for C and other languages. (Remember pyodbc for Python)
ğ–¦¹ JDBC standard provides interfaces for Java.
ğ–¦¹ JDBC standard provides interfaces for Java.
ğ–¦¹ An Example using SQLAlchemy as well,
   from sqlalchemy import create_engine
   # Create an engine to a SQLite database
   engine = create_engine('sqlite:///school.db')
   # Using the engine to execute SQL
   with engine.connect() as conn:
       result = conn.execute("SELECT * FROM students")
       for row in result:
           print(row)

21. Database Design
ğ–¦¹ Databases manage large bodies of information used in an enterprise.
ğ–¦¹ The database may directly produce information or support another product or service.
ğ–¦¹ Database design mainly focuses on designing the database schema.
ğ–¦¹ A complete database application also needs broader application design beyond schemas.
â€¢ Query writing and schema design are primary focus areas initially.
ğ–¦¹ A high-level data model helps understand user data needs and structure.
ğ–¦¹ The first step is to gather and understand user requirements.
â€¢ The designer works with domain experts and users to collect these needs.
â€¢ The result is a clear specification of user requirements.
ğ–¦¹ The designer chooses a data model and converts requirements into a conceptual schema.
ğ–¦¹ The conceptual schema shows a detailed view of the enterprise.
â€¢ The designer checks if all data needs are met and removes redundancy.
- This stage focuses on data and relationships, not physical storage.
ğ–¦¹ In the relational model, design choices involve selecting attributes and grouping them into tables.
ğ–¦¹ Choosing attributes is a business decision, grouping them is a computer science task.
ğ–¦¹ Two main approaches:
â€¢ Entity-relationship model.
â€¢ Normalization algorithms to produce tables.
ğ–¦¹ A complete conceptual schema also defines functional requirements.
â€¢ Users describe operations like updating, searching, retrieving, and deleting data.
â€¢ The designer checks if the schema supports these operations.
ğ–¦¹ After conceptual design, two final phases occur:
â€¢ Logical design: Map conceptual schema to the systemâ€™s data model.
â€¢ Physical design: Define file organization and internal storage structures.
- Physical design focuses on how data is stored and accessed efficiently.

22. Database Engine
ğ–¦¹ A database system is divided into modules based on responsibilities.
ğ–¦¹ Main components are storage manager, query processor, and transaction manager.
ğ–¦¹ Storage manager handles large data stored on disks or SSDs.
â€¢ Data is moved between disk and main memory when needed.
- Disk access is slower, so data layout should reduce unnecessary data movement.
ğ–¦¹ Query processor helps users access data without needing to know physical storage details.
ğ–¦¹ Transaction manager ensures a group of operations acts as one complete unit.

23. Storage Manager
ğ–¦¹ Acts as the link between low-level stored data and application queries.
ğ–¦¹ Interacts with the file manager and translates DML into file-system level actions.
ğ–¦¹ Responsible for storing, retrieving, and updating data.
â€¢ Authorization and integrity manager checks user permissions and data rules.
â€¢ Transaction manager keeps data consistent during failures and concurrency.
â€¢ File manager handles disk space and data organization.
â€¢ Buffer manager fetches data to main memory and decides what to cache.
ğ–¦¹ Uses physical data structures:
â€¢ Data files store actual database data.
â€¢ Data dictionary stores database structure details.
â€¢ Indices provide fast access to specific data items.

24. The Query Processor
ğ–¦¹ Translates user queries into efficient execution steps.
â€¢ DDL interpreter records schema definitions in the data dictionary.
â€¢ DML compiler converts queries into evaluation plans and performs optimization.
â€¢ Query evaluation engine executes the chosen low-level instructions.

25. Transaction Management
ğ–¦¹ A transaction is a logical unit of work involving multiple database operations.
ğ–¦¹ Key requirements:
â€¢ Atomicity: All steps happen or none happen.
â€¢ Consistency: Data remains correct before and after execution.
â€¢ Durability: Results persist even after system failures.
ğ–¦¹ Recovery manager restores database state if failures occur.
ğ–¦¹ Concurrency-control manager ensures correctness when many transactions run at once.
ğ–¦¹ Together they form the transaction manager.

26. Database and Application Architecture
ğ–¦¹ Traditional systems used centralized servers with shared memory.
ğ–¦¹ Modern systems use parallel and distributed architectures to handle large data.
ğ–¦¹ Applications connecting to databases follow:
â€¢ Two-tier architecture: Client directly communicates with database server.
â€¢ Three-tier architecture: Client â†’ Application server â†’ Database server.
- Three-tier improves security and performance by keeping business logic centralized.

27. Database Users and User Interfaces
ğ–¦¹ Database users differ based on how they interact with the system.
ğ–¦¹ Naive users use predefined interfaces like web or mobile forms.
â€¢ They fill out forms or view reports without knowing database details.
â€¢ Example: A student registering for a class through an online form.
ğ–¦¹ Application programmers write programs that interact with the database.
ğ–¦¹ Sophisticated users use query languages or analysis tools to work directly with data.

28. Database Administrator (DBA)
ğ–¦¹ The DBA has central control over data and the programs accessing the data.
ğ–¦¹ Responsibilities include:
â€¢ Schema definition: Creating the database schema using DDL statements.
â€¢ Defining storage structure and access methods: Setting physical data organization and indices.
â€¢ Modifying schema and physical layout: Updating structure as needs change or to improve performance.
â€¢ Granting authorizations: Controlling who can access which parts of the database.
â€¢ Routine maintenance:
- Backing up data to prevent loss.
- Ensuring sufficient disk space.
- Monitoring database performance and managing heavy workloads.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -[08/11/2025]
29. Introduction to the Relational Model
ğ–¦¹ The relational model is widely used in commercial data-processing.
ğ–¦¹ Its simplicity makes it easier for programmers compared to earlier models.
â€¢ Earlier models include network and hierarchical models.
ğ–¦¹ The model has evolved with features like object-relational data types, stored procedures, and support for XML and semi-structured data.
ğ–¦¹ Its independence from low-level storage allows it to remain relevant despite new storage systems like column stores.

â €â €â €â €â €â €â €â €â €â €â €â €â €â¡€â£„â¡†â¡¦â¢”â¢”â¢´â¡¤â¡€â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â¢€â£”â¡ªâ¢Ÿâ¢—â¢•â¢…â£œâ£Œâ£¬â£¼â£¼â£´â£¥â£€â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â¢™â¢»â¡¶â£•â¢µâ£«â£¿â£·â¡¿â£¿â Ÿâ£¿â¡¿â¢¿â£¿â£¿â£¶â£„â €â €â €â €
â¢€â£€â¡€â €â €â €â €â €â ¿â£¯â¢â£µâ¡Ÿâ£¿â ƒâ¡¯â €â¡¿â¢â£¿â¢â£¿â£â ™â ¿â ›â£§â¡€â €â €
â¢¿â£¿â ¿â£¿â£¿â£¶â£¶â£´â£¾â£¿â ›â£¿â €â¡¿â¢¸â¡‡â¢¸â¡‡â¢¸â¡‡â¢¸â¢¿â ¿â €â  â €â£½â¡¿â£„â €
â¢€â£½â£­â£½â£¿â¡â Ÿâ ‰â¡‡â¢¸â €â£¿â €â ™â ­â ½â¢›â£³â£½â£§â£¿â¡â¡†â €â£‡â €â ‰â¢â â¡ƒ
â¢¼â£µâ Ÿâ ‰â â â €â£´â£Ÿâ ¢â €â ˜â €â ‡â¢”â£’â£›â ¿â¡¿â Ÿâ ƒâ €â ˆâ ¢â¡€â €â €â¢€â ©â ƒ
â ˆâ â €â €â €â €â¢¸â£Ÿâ¢¿â££â£•â „â¡€â €â €â¢€â£€â£€â£¤â£¤â£¤â ¤â ¤â ¤â ´â ›â ‹â â €â €
â €â €â €â €â €â €â €â »â£¿â£¿â£µâ£¥â ¦â â ‰â ‰â €â£ â£¾â¡Ÿâ â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â â €â €â €â €â €â ¸â¡›â »â €â €â €â €â €â €â €â €â €â €â €

â­ Column Store Storage
ğ–¦¹ Data is stored column-by-column instead of row-by-row
â€¢ Example layout:
  - ID: 1, 2, 3
  - Name: Rani, Arjun, Kavi
  - Age: 21, 24, 22
  - City: Chennai, Madurai, Trichy

â­ Row Store Storage
ğ–¦¹ Data is stored row-by-row
â€¢ Example layout:
  - 1, Rani, 21, Chennai
  - 2, Arjun, 24, Madurai
  - 3, Kavi, 22, Trichy

â­ Why Column Store
ğ–¦¹ Faster analytical queries
â€¢ Only required columns are read (e.g., AVG(Age) reads only Age column)
ğ–¦¹ Better compression
â€¢ Similar data within a column compresses efficiently
ğ–¦¹ Suitable for large data warehouses
â€¢ Used for OLAP, analytics, and business intelligence

â­ When Column Store Is Not Good
ğ–¦¹ Frequent row updates or inserts are slow
- Reconstructing full rows becomes costly
ğ–¦¹ Not ideal for OLTP transactional systems

â­ Examples of Column-Store Databases
â€¢ Amazon Redshift
â€¢ Google BigQuery
â€¢ Snowflake
â€¢ ClickHouse
â€¢ Apache Cassandra (wide-column model)
â€¢ SAP HANA
â€¢ PostgreSQL via cstore_fdw extension

30. Structure of Relational Databases
ğ–¦¹ A relational database is a collection of tables, each with a unique name.
ğ–¦¹ Each table contains rows (tuples) and columns (attributes).
â€¢ Example tables: instructor, course, prereq.
â€¢ Each row represents a relationship among attribute values.
ğ–¦¹ The term relation refers to a table, tuple refers to a row, and attribute refers to a column.
ğ–¦¹ A relation instance is the specific set of rows present at a given time.
ğ–¦¹ The order of rows does not matter because a relation is a set of tuples.

31. Attributes and Domains
ğ–¦¹ Each attribute has a domain, which is the set of allowed values.
ğ–¦¹ Domains must be atomic (indivisible units).
â€¢ Example: If phone number stores multiple numbers in one field, it is non-atomic.
â€¢ Atomicity depends on how values are used, not just how they appear.
ğ–¦¹ Null represents unknown or non-existing values.
â€¢ Nulls can cause complications and should be minimized.

32. Suitability and Limitations
ğ–¦¹ The strict structure of relational databases allows efficient storage and processing.
ğ–¦¹ This structure suits stable and well-defined applications.
ğ–¦¹ It is less suitable for situations where data types and structures change frequently.
â€¢ Modern systems try to balance efficient structured storage with flexibility.

33. Database Schema
ğ–¦¹ Database schema is the logical design of the database.
ğ–¦¹ Database instance is the data in the database at a specific moment.
ğ–¦¹ Relation schema lists attributes and their domains.
ğ–¦¹ Relation instance is the current set of tuples and can change over time while the schema usually does not.
ğ–¦¹ Same name may refer to either schema or instance; context makes the meaning clear.
ğ–¦¹ Common attributes in different relation schemas help link data between relations.

34. Example Schemas in a University Database
ğ–¦¹ department(dept name, building, budget)
ğ–¦¹ section(courseid, secid, semester, year, building, roomnumber, timeslot id)
ğ–¦¹ teaches(ID, courseid, secid, semester, year)
ğ–¦¹ Additional relations: student, advisor, takes, classroom, timeslot.

35. Keys
ğ–¦¹ Tuples in a relation must be uniquely identifiable.
ğ–¦¹ Superkey: A set of attributes that uniquely identifies a tuple.
â€¢ Example: instructor.ID is a superkey.
ğ–¦¹ Candidate key: A minimal superkey with no unnecessary attributes.
ğ–¦¹ Primary key: A chosen candidate key used as the main tuple identifier.
â€¢ Primary keys should use attributes that rarely change.
ğ–¦¹ Primary key attributes are listed first in the schema and are underlined.
â€¢ Example: classroom(building, roomnumber, capacity) uses building + roomnumber as primary key.

36. Foreign Keys and Referential Integrity
ğ–¦¹ A foreign key in one relation refers to the primary key of another relation.
â€¢ Example: instructor.dept name references department.dept name.
ğ–¦¹ The referencing relation is the one containing the foreign key; the referenced relation contains the primary key.
ğ–¦¹ Foreign keys ensure related data remains valid across relations.
ğ–¦¹ Referential integrity ensures values in the referencing relation also exist in the referenced relation, even if the referenced attribute is not a primary key.

37. Schema Diagrams
ğ–¦¹ Schema diagrams visually represent a database schema along with its primary and foreign key constraints.
ğ–¦¹ Each relation is shown as a box containing its name and attributes.
â€¢ Primary key attributes are underlined.
â€¢ Foreign key relationships are shown using arrows from referencing attributes to referenced primary keys.
ğ–¦¹ A two-headed arrow indicates a referential integrity constraint that is not a foreign key constraint.
ğ–¦¹ Example: In the diagram, section.time slot id links to time slot.time slot id with a two-headed arrow to show referential integrity.
ğ–¦¹ Many database systems provide graphical tools to create such diagrams.
ğ–¦¹ Schema diagrams should not be confused with entity-relationship diagrams.
IMG_URL schema-diagram.png

38. Relational Query Languages
ğ–¦¹ A query language allows users to request information from a database.
ğ–¦¹ Query languages are usually higher-level than standard programming languages.
ğ–¦¹ Types of query languages:
â€¢ Imperative query languages
- User specifies a sequence of operations and state changes to get the desired result.
â€¢ Functional query languages
- Computation is expressed as evaluation of functions without side effects.
â€¢ Declarative query languages
- User specifies what information is required, not how to obtain it. The system figures out the steps.
ğ–¦¹ Examples of â€œpureâ€ query languages:
â€¢ Relational algebra (functional) â€“ theoretical basis of SQL.
â€¢ Tuple relational calculus and domain relational calculus (declarative).
ğ–¦¹ Practical query languages like SQL combine imperative, functional, and declarative styles.

39. The Relational Algebra
ğ–¦¹ Relational algebra uses operations on relations to produce new relations.
ğ–¦¹ Unary operations work on one relation (select, project, rename).
ğ–¦¹ Binary operations work on two relations (union, Cartesian product, set difference).
ğ–¦¹ Relational algebra is the theoretical basis for SQL, but users do not write queries directly in it.
ğ–¦¹ Relations are sets, so duplicates are not allowed in formal relational algebra.

40. The Select Operation (Ïƒ)
ğ–¦¹ Selects tuples that satisfy a given condition.
ğ–¦¹ Written as: Ïƒ(condition)(relation)
ğ–¦¹ Conditions may use =, â‰ , <, â‰¤, >, â‰¥ and logical connectives (âˆ§, âˆ¨, Â¬).
â€¢ Example: Ïƒdeptname="Physics"(instructor)
- Returns only instructors in the Physics department.

41. The Project Operation (Î )
ğ–¦¹ Selects specific attributes (columns) from a relation.
ğ–¦¹ Written as: Î attribute_list(relation)
ğ–¦¹ Duplicate rows are removed.
â€¢ Example: Î ID,name,salary(instructor)
- Produces a relation with only these columns.

42. Composition of Relational Operations
ğ–¦¹ The result of one relational operation can be used as input to another.
ğ–¦¹ Allows nested expressions.
â€¢ Example: Î name(Ïƒdeptname="Physics"(instructor))

43. The Cartesian Product (Ã—)
ğ–¦¹ Combines tuples from two relations into all possible pairs.
ğ–¦¹ Written as: r1 Ã— r2
ğ–¦¹ Produces a large relation with concatenated attributes.
â€¢ If both relations share attribute names, relation names are prefixed to distinguish them.

44. The Join Operation (â‹ˆ)
ğ–¦¹ Combines related tuples from two relations based on a condition.
ğ–¦¹ Defined as: r â‹ˆÎ¸ s = ÏƒÎ¸(r Ã— s)
â€¢ Example: instructor â‹ˆ instructor.ID = teaches.ID teaches
- Combines instructor and teaches only when IDs match.
ğ–¦¹ More useful than Cartesian product because it avoids unrelated pairings.

45. Set Operations (âˆª, âˆ©, âˆ’)
ğ–¦¹ Work only on compatible relations (same number and type of attributes).
ğ–¦¹ Union (r âˆª s): Tuples in either relation.
ğ–¦¹ Intersection (r âˆ© s): Tuples common to both relations.
ğ–¦¹ Difference (r âˆ’ s): Tuples in r but not in s.
â€¢ Example: Î courseid(Ïƒsemester="Fall"âˆ§year=2017(section)) âˆª Î courseid(Ïƒsemester="Spring"âˆ§year=2018(section))

46. The Assignment Operation (â†)
ğ–¦¹ Stores the result of an expression in a temporary relation variable.
ğ–¦¹ Used to simplify complex queries.
â€¢ Example:
courses_fall â† Î courseid(...)
courses_spring â† Î courseid(...)
courses_fall âˆ© courses_spring

47. The Rename Operation (Ï)
ğ–¦¹ Gives a name to the result of an expression or renames attributes.
ğ–¦¹ Written as: Ïnew_name(expression) or Ïnew_name(A1,A2,...,An)(expression)
â€¢ Used when the same relation must be referenced more than once in a query.

48. Equivalent Queries
ğ–¦¹ Different relational algebra expressions can produce the same result.
ğ–¦¹ Example:
Ïƒdeptname="Physics"(instructor â‹ˆ instructor.ID=teaches.ID teaches)
(Ïƒdeptname="Physics"(instructor)) â‹ˆ instructor.ID=teaches.ID teaches
ğ–¦¹ Query optimizers choose efficient equivalent expressions during execution.

49. Introduction to SQL
ğ–¦¹ SQL is a widely used database language.
ğ–¦¹ It can define, modify, and secure data in a database, not just query it.
ğ–¦¹ The focus is on SQLâ€™s main ideas, not a full user guide.
ğ–¦¹ SQL features may vary between systems.
ğ–¦¹ Users are encouraged to try example SQL queries on real databases.

50. Overview of the SQL Query Language
ğ–¦¹ SQL was first developed by IBM in the 1970s under the name SEQUEL.
ğ–¦¹ It became SQL (Structured Query Language) and is now the standard for relational databases.
ğ–¦¹ ANSI and ISO established SQL standards with updates over time (SQL-86 to SQL:2016).
ğ–¦¹ Main components of SQL:
â€¢ Data-definition language (DDL) â€“ defines and modifies table structures.
â€¢ Data-manipulation language (DML) â€“ retrieves and updates data.
â€¢ Integrity â€“ defines rules to ensure data accuracy.
â€¢ View definition â€“ defines virtual tables (views).
â€¢ Transaction control â€“ defines transaction start and end points.
â€¢ Embedded and dynamic SQL â€“ allows SQL use in programming languages.
â€¢ Authorization â€“ controls user access rights.
ğ–¦¹ SQL implementations differ slightly, with some supporting only certain features.

51. SQL Data Definition
ğ–¦¹ The data-definition language (DDL) specifies database structures.
ğ–¦¹ It defines details such as:
â€¢ Table schemas
â€¢ Data types for each attribute
â€¢ Integrity constraints
â€¢ Indexes to maintain
â€¢ Security and authorization settings
â€¢ Physical storage structure
ğ–¦¹ The focus here is on basic types and table definitions.

52. Basic Types in SQL
ğ–¦¹ SQL supports several built-in data types:
â€¢ char(n): Fixed-length string.
â€¢ varchar(n): Variable-length string.
â€¢ int or integer: Whole numbers.
â€¢ smallint: Smaller integer type.
â€¢ numeric(p,d): Fixed-point number with defined precision.
â€¢ real, double precision: Floating-point types.
â€¢ float(n): Floating-point with at least n digits of precision.
ğ–¦¹ Each type may allow a null value, representing unknown or missing data.
ğ–¦¹ char stores fixed-length strings by adding spaces; varchar stores only the actual string.
ğ–¦¹ Comparing char and varchar can behave differently across systems.
ğ–¦¹ varchar is preferred to avoid comparison issues.
ğ–¦¹ nvarchar supports multilingual data using Unicode; some databases also allow Unicode in varchar.

53. Basic Schema Definition
ğ–¦¹ Tables are created using the create table command.
â€¢ Example:
  create table department
  (dept_name varchar(20),
   building varchar(15),
   budget numeric(12,2),
   primary key (dept_name));
ğ–¦¹ Each attribute has a name, data type, and optional constraints.
ğ–¦¹ Common integrity constraints:
â€¢ primary key (A1, A2, ...): Ensures uniqueness and non-null values.
â€¢ foreign key (A1, A2, ...) references table: Ensures values match existing records in another table.
â€¢ not null: Prevents null values for that attribute.
ğ–¦¹ SQL rejects updates that break integrity constraints.
ğ–¦¹ Tables are empty when created; data is added using insert, update, and delete commands.
ğ–¦¹ drop table r; removes a table and its schema.
ğ–¦¹ delete from r; removes all data but keeps the table structure.
ğ–¦¹ alter table allows structure changes:
â€¢ alter table r add A D; adds a new attribute with null values.
â€¢ alter table r drop A; removes an attribute.
ğ–¦¹ Some systems do not allow attribute deletion but allow table deletion.

54. Basic Structure of SQL Queries
ğ–¦¹ An SQL query has three main clauses: select, from, and where.
ğ–¦¹ The from clause lists input tables (relations).
ğ–¦¹ The where clause filters rows based on a condition.
ğ–¦¹ The select clause specifies which columns or expressions to display.
ğ–¦¹ A query takes input relations, processes them, and returns a new relation as output.

55. Queries on a Single Relation
ğ–¦¹ Example: To find all instructor names:
â€¢ select name from instructor;
- Returns one column, "name", from the instructor table.
ğ–¦¹ Example: To find department names of all instructors:
â€¢ select dept_name from instructor;
- Duplicate department names may appear if multiple instructors belong to the same department.
ğ–¦¹ SQL allows duplicate tuples in tables and query results for efficiency.
ğ–¦¹ To remove duplicates, use distinct:
â€¢ select distinct dept_name from instructor;
ğ–¦¹ To explicitly keep duplicates, use all (though it is the default):
â€¢ select all dept_name from instructor;
ğ–¦¹ The select clause can also contain arithmetic operations:
â€¢ select ID, name, dept_name, salary * 1.1 from instructor;
- This multiplies salary by 1.1 but does not modify stored data.
ğ–¦¹ The where clause filters rows that meet certain conditions.
ğ–¦¹ Example: Find names of instructors in the Computer Science department with salary > 70000:
â€¢ select name from instructor where dept_name = 'Comp. Sci.' and salary > 70000;
ğ–¦¹ Logical connectives (and, or, not) and comparison operators (<, <=, >, >=, =, <>) can be used in conditions.
ğ–¦¹ Conditions can compare numbers, strings, or special types like dates.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -[09/11/2025]
56. Queries on Multiple Relations
ğ–¦¹ Queries can combine data from multiple tables.
ğ–¦¹ Example: Retrieve instructor names with department names and building names:
â€¢ select name, instructor.dept_name, building
  from instructor, department
  where instructor.dept_name = department.dept_name;
- Matches each instructor with the corresponding department using dept_name.
ğ–¦¹ When an attribute name appears in multiple tables, prefix it with the table name.
ğ–¦¹ Example: instructor.dept_name distinguishes it from department.dept_name.
ğ–¦¹ Each table listed in the from clause must have a unique name.
ğ–¦¹ Typical SQL query format:
â€¢ select A1, A2, â€¦, An
  from r1, r2, â€¦, rm
  where P;
- Ai: attributes to output
- ri: tables used
- P: condition to filter results
ğ–¦¹ If the where clause is omitted, all possible combinations (Cartesian product) are returned.

57. Operational Understanding of SQL Queries
ğ–¦¹ Logical order of execution:
â€¢ 1. from â€“ create a Cartesian product of all tables.
â€¢ 2. where â€“ filter rows using conditions.
â€¢ 3. select â€“ display the chosen columns or expressions.
ğ–¦¹ The from clause forms combinations of all tuples from listed tables.
ğ–¦¹ Example schema for instructor Ã— teaches:
(instructor.ID, instructor.name, instructor.dept_name, instructor.salary,
 teaches.ID, teaches.course_id, teaches.sec_id, teaches.semester, teaches.year)
ğ–¦¹ Cartesian product pairs each row from one table with every row in the other.
ğ–¦¹ It can produce huge results and usually includes unrelated tuples.
ğ–¦¹ To get meaningful combinations, add a condition in the where clause to match related tuples.
ğ–¦¹ Example: Match instructors with the courses they teach:
â€¢ select name, course_id
  from instructor, teaches
  where instructor.ID = teaches.ID;
- Returns only instructors who have taught a course.
ğ–¦¹ Example: Restrict to Computer Science department:
â€¢ select name, course_id
  from instructor, teaches
  where instructor.ID = teaches.ID and dept_name = 'Comp. Sci.';
ğ–¦¹ General meaning of an SQL query:
â€¢ Step 1: Create Cartesian product of tables in from clause.
â€¢ Step 2: Apply filtering condition from where clause.
â€¢ Step 3: Output attributes listed in select clause.
ğ–¦¹ Omitting the where clause causes a full Cartesian product, which can be very large and inefficient.

58. Additional Basic Operations
ğ–¦¹ SQL supports several additional operations to enhance query flexibility and output formatting.

59. The Rename Operation
ğ–¦¹ The as clause allows renaming of attributes or tables in SQL.
â€¢ Syntax: old-name as new-name
â€¢ Can be used in both select and from clauses.
ğ–¦¹ Example of renaming an attribute:
â€¢ select name as instructor_name, course_id from instructor, teaches where instructor.ID = teaches.ID;
ğ–¦¹ Example of renaming relations for convenience:
â€¢ select T.name, S.course_id from instructor as T, teaches as S where T.ID = S.ID;
- T and S act as aliases for instructor and teaches.
ğ–¦¹ Renaming is necessary when:
â€¢ Two tables have attributes with the same name.
â€¢ Expressions are used in select and need a name.
â€¢ Shorter or more meaningful names are desired.
ğ–¦¹ Renaming the same relation helps compare tuples within it.
â€¢ Example: Find instructors whose salary is greater than any instructor in the Biology department:
  select distinct T.name
  from instructor as T, instructor as S
  where T.salary > S.salary and S.dept_name = 'Biology';
ğ–¦¹ The alias names (like T and S) are also called correlation names or table aliases.
ğ–¦¹ Some SQL systems (like Oracle) omit the keyword as in the from clause.

60. String Operations
ğ–¦¹ String literals are enclosed in single quotes ('example').
â€¢ To include a single quote inside, use two single quotes: 'It''s right'.
ğ–¦¹ String comparison using '=' is case-sensitive in standard SQL.
â€¢ 'comp. sci.' = 'Comp. Sci.' returns false in standard SQL.
â€¢ Some systems like MySQL treat strings as case-insensitive by default.
ğ–¦¹ Common string functions:
â€¢ Concatenation using || 
â€¢ upper(s), lower(s), trim(s)
â€¢ substring extraction and length calculation
ğ–¦¹ Pattern matching uses the like operator.
â€¢ % matches any substring.
â€¢ _ matches any single character.
â€¢ Examples:
  - 'Intro%' matches strings beginning with 'Intro'.
  - '%Comp%' matches any string containing 'Comp'.
  - '___' matches any three-character string.
ğ–¦¹ Example query:
â€¢ select dept_name from department where building like '%Watson%';
ğ–¦¹ To include % or _ as literal characters, use escape:
â€¢ like 'ab\%cd%' escape '\'
- Matches strings beginning with â€œab%cdâ€.
ğ–¦¹ To find mismatches, use not like.
ğ–¦¹ Some systems like PostgreSQL offer similar to for advanced pattern matching (similar to regular expressions).

61. Attribute Specification in the Select Clause
ğ–¦¹ The asterisk (*) selects all attributes.
â€¢ Example:
  select instructor.* from instructor, teaches where instructor.ID = teaches.ID;
- Selects all columns from instructor.
ğ–¦¹ select * selects all attributes from all relations in the from clause.

62. Ordering the Display of Tuples
ğ–¦¹ The order by clause controls the sort order of query results.
â€¢ Example: List instructors in the Physics department alphabetically:
  select name from instructor where dept_name = 'Physics' order by name;
ğ–¦¹ Default order is ascending (asc).
â€¢ Use desc for descending order.
ğ–¦¹ Multiple attributes can be used for sorting.
â€¢ Example: Sort by salary (descending), then by name (ascending):
  select * from instructor order by salary desc, name asc;

63. Where-Clause Predicates
ğ–¦¹ The between operator simplifies range checks.
â€¢ Example:
  select name from instructor where salary between 90000 and 100000;
- Equivalent to: salary <= 100000 and salary >= 90000.
ğ–¦¹ Use not between for the opposite condition.
ğ–¦¹ SQL allows tuple comparisons using row constructors (v1, v2, ... , vn).
â€¢ Example:
  select name, course_id
  from instructor, teaches
  where (instructor.ID, dept_name) = (teaches.ID, 'Biology');
- Compares multiple attributes as one tuple.
ğ–¦¹ Tuple comparisons are evaluated lexicographically.

64. Set Operations
ğ–¦¹ SQL supports union, intersect, and except operations, similar to set operations in mathematics.
ğ–¦¹ Example tables:
â€¢ c1: courses taught in Fall 2017.
â€¢ c2: courses taught in Spring 2018.

65. The Union Operation
ğ–¦¹ Combines results of two queries, removing duplicates by default.
â€¢ Example:
  (select course_id from section where semester = 'Fall' and year = 2017)
  union
  (select course_id from section where semester = 'Spring' and year = 2018);
ğ–¦¹ Use union all to retain duplicates.
- The number of duplicates equals total occurrences in both results.

66. The Intersect Operation
ğ–¦¹ Returns tuples common to both query results, removing duplicates by default.
â€¢ Example:
  (select course_id from section where semester = 'Fall' and year = 2017)
  intersect
  (select course_id from section where semester = 'Spring' and year = 2018);
ğ–¦¹ Use intersect all to retain duplicates.
- Number of duplicates equals the minimum number of occurrences in both sets.
ğ–¦¹ Some systems like MySQL do not support intersect directly.

67. The Except Operation
ğ–¦¹ Returns tuples from the first query not found in the second.
â€¢ Example:
  (select course_id from section where semester = 'Fall' and year = 2017)
  except
  (select course_id from section where semester = 'Spring' and year = 2018);
ğ–¦¹ Automatically removes duplicates before performing set difference.
ğ–¦¹ Use except all to keep duplicates.
- Result count = copies in first - copies in second (if positive).
ğ–¦¹ Some systems (like Oracle) use minus instead of except.
ğ–¦¹ MySQL does not implement except; subqueries can be used as alternatives.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -[10/11/2025]
68. Null Values
ğ–¦¹ Null values create special issues in arithmetic, comparison, and set operations.
ğ–¦¹ Any arithmetic expression with a null input results in null.
â€¢ Example: if r.A is null, then r.A + 5 is also null.
ğ–¦¹ Comparisons with null values do not result in true or false but in unknown.
- Example: â€œ1 < nullâ€ is neither true nor false, so its result is unknown.
ğ–¦¹ SQL introduces a third logical value: unknown.
ğ–¦¹ Boolean operations are extended to handle unknown.
â€¢ and: true and unknown â†’ unknown; false and unknown â†’ false; unknown and unknown â†’ unknown.
â€¢ or: true or unknown â†’ true; false or unknown â†’ unknown; unknown or unknown â†’ unknown.
â€¢ not: not unknown â†’ unknown.
ğ–¦¹ If a where condition evaluates to false or unknown, the tuple is not included in the result.
ğ–¦¹ Null checks use special predicates:
â€¢ is null â†’ true if the value is null.
â€¢ is not null â†’ true if the value is not null.
ğ–¦¹ Example:
  select name
  from instructor
  where salary is null;
ğ–¦¹ The predicate is unknown can test if a comparison result is unknown.
â€¢ Example:
  select name
  from instructor
  where salary > 10000 is unknown;
ğ–¦¹ When using select distinct, tuples are considered identical if both have nulls in the same attributes.
â€¢ Example: ('A', null) and ('A', null) are treated as identical.
ğ–¦¹ For distinct, union, intersection, and except, nulls in the same position are treated as equal.
ğ–¦¹ In normal comparisons, null = null is unknown, but in duplicate elimination it is treated as equal.
ğ–¦¹ Some databases do not support is unknown and is not unknown.

69. Aggregate Functions
ğ–¦¹ Aggregate functions take a collection of values and return a single value.
ğ–¦¹ Standard aggregate functions:
â€¢ avg â€“ average value
â€¢ min â€“ minimum value
â€¢ max â€“ maximum value
â€¢ sum â€“ total
â€¢ count â€“ number of items
ğ–¦¹ sum and avg require numeric inputs; others can work on non-numeric data too.

70. Basic Aggregation
ğ–¦¹ Aggregates can summarize information from relations.
â€¢ Example: Find the average salary in the Computer Science department.
  select avg(salary)
  from instructor
  where dept_name = 'Comp. Sci.';
ğ–¦¹ The result is one value (e.g., avg salary = 77333.33).
ğ–¦¹ We can rename the output attribute using as:
  select avg(salary) as avg_salary
  from instructor
  where dept_name = 'Comp. Sci.';
ğ–¦¹ Duplicate tuples affect aggregate results.
- Duplicates are normally included in averages unless distinct is specified.
ğ–¦¹ To eliminate duplicates in aggregation, use distinct.
â€¢ Example: Count unique instructors teaching in Spring 2018:
  select count(distinct ID)
  from teaches
  where semester = 'Spring' and year = 2018;
ğ–¦¹ count(*) counts all tuples in a relation.
â€¢ Example:
  select count(*)
  from course;
ğ–¦¹ distinct cannot be used with count(*).
ğ–¦¹ all keyword keeps duplicates but is optional since it is the default.

71. Aggregation with Grouping
ğ–¦¹ group by divides tuples into groups based on attribute values.
ğ–¦¹ Each group is processed separately for aggregation.
â€¢ Example: Find average salary per department.
  select dept_name, avg(salary) as avg_salary
  from instructor
  group by dept_name;
ğ–¦¹ Without group by, the whole table is treated as one group.
ğ–¦¹ Only attributes in the group by clause can appear in select without being aggregated.
ğ–¦¹ Example of valid query:
  select dept_name, count(distinct ID) as instr_count
  from instructor, teaches
  where instructor.ID = teaches.ID and semester = 'Spring' and year = 2018
  group by dept_name;
ğ–¦¹ Example of invalid query:
  select dept_name, ID, avg(salary)
  from instructor
  group by dept_name;
- Error: ID not in group by and not aggregated.
ğ–¦¹ Comments in SQL can be written as /* comment */ or -- comment.

72. The Having Clause
ğ–¦¹ having filters groups after aggregation, similar to where for individual tuples.
ğ–¦¹ Example: Find departments where average salary > 42000.
  select dept_name, avg(salary) as avg_salary
  from instructor
  group by dept_name
  having avg(salary) > 42000;
ğ–¦¹ Any non-aggregated attribute in having must also appear in group by.
ğ–¦¹ SQL query evaluation order with grouping:
â€¢ 1. Evaluate from clause to get relation.
â€¢ 2. Apply where condition if present.
â€¢ 3. Group tuples using group by (if absent, all tuples form one group).
â€¢ 4. Apply having clause to remove groups not meeting the condition.
â€¢ 5. Use select to compute and display results.
ğ–¦¹ Example with both where and having:
  select course_id, semester, year, sec_id, avg(tot_cred)
  from student, takes
  where student.ID = takes.ID and year = 2017
  group by course_id, semester, year, sec_id
  having count(ID) >= 2;

73. Aggregation with Null and Boolean Values
ğ–¦¹ Null values affect aggregate results.
ğ–¦¹ sum, avg, min, and max ignore null values; count(*) counts all rows.
â€¢ Example: select sum(salary) from instructor;
  - Null salaries are ignored in the total.
ğ–¦¹ If all values are null, count(*) = 0 and others (sum, avg, etc.) return null.
ğ–¦¹ SQL:1999 introduced Boolean type (true, false, unknown).
ğ–¦¹ Aggregate functions on Boolean values:
â€¢ some â€“ returns true if at least one value is true (logical OR)
â€¢ every â€“ returns true only if all values are true (logical AND)

74. Nested Subqueries
ğ–¦¹ SQL allows queries to be nested within other queries.
ğ–¦¹ A subquery is a select-from-where statement inside another query.
ğ–¦¹ Common uses include checking set membership, comparing sets, and calculating set size.
â€¢ Subqueries can appear in where, from, or select clauses.
- Subqueries returning one value are called scalar subqueries.

75. Set Membership
ğ–¦¹ The in operator checks if a value is present in a set.
ğ–¦¹ The not in operator checks if a value is not in a set.
â€¢ Example using in:
  select distinct course_id from section
  where semester='Fall' and year=2017 and
  course_id in (select course_id from section where semester='Spring' and year=2018);
- Finds courses taught in both Fall 2017 and Spring 2018.
â€¢ Example using not in:
  select distinct course_id from section
  where semester='Fall' and year=2017 and
  course_id not in (select course_id from section where semester='Spring' and year=2018);
- Finds courses taught in Fall 2017 but not in Spring 2018.
ğ–¦¹ The in and not in operators can also work with fixed lists of values.
â€¢ Example:
  select name from instructor where name not in ('Mozart','Einstein');
ğ–¦¹ Membership tests can include multiple attributes.
â€¢ Example:
  select count(distinct ID)
  from takes
  where (course_id, sec_id, semester, year) in
  (select course_id, sec_id, semester, year from teaches where teaches.ID='10101');
- Counts students who took any section taught by a specific instructor.

76. Set Comparison
ğ–¦¹ Subqueries can be compared to sets using some or all.
â€¢ > some means â€œgreater than at least one value.â€
â€¢ > all means â€œgreater than all values.â€
â€¢ Example using some:
  select name from instructor
  where salary > some (select salary from instructor where dept_name='Biology');
- Finds instructors earning more than at least one Biology instructor.
â€¢ Example using all:
  select name from instructor
  where salary > all (select salary from instructor where dept_name='Biology');
- Finds instructors earning more than every Biology instructor.
ğ–¦¹ The keyword any is a synonym for some.
ğ–¦¹ Example with group comparison:
  select dept_name
  from instructor
  group by dept_name
  having avg(salary) >= all (select avg(salary)
                             from instructor
                             group by dept_name);
- Finds departments with the highest average salary.

77. Test for Empty Relations
ğ–¦¹ The exists operator checks if a subquery returns any rows.
â€¢ Example:
  select course_id
  from section as S
  where semester='Fall' and year=2017 and
  exists (select * from section as T
          where semester='Spring' and year=2018 and S.course_id=T.course_id);
- Finds courses offered in both semesters.
ğ–¦¹ Subqueries using values from outer queries are called correlated subqueries.
ğ–¦¹ The not exists operator checks if a subquery returns no rows.
â€¢ Example:
  select S.ID, S.name
  from student as S
  where not exists ((select course_id from course where dept_name='Biology')
                    except
                    (select T.course_id from takes as T where S.ID=T.ID));
- Finds students who have taken all Biology courses.
ğ–¦¹ exists can replace tuple constructors not supported by all databases.

78. Test for the Absence of Duplicate Tuples
ğ–¦¹ The unique operator checks if a subquery result has no duplicate tuples.
â€¢ Example:
  select T.course_id
  from course as T
  where unique (select R.course_id
                from section as R
                where T.course_id=R.course_id and R.year=2017);
- Finds courses offered at most once in 2017.
ğ–¦¹ The not unique operator checks for duplicate tuples.
â€¢ Example:
  select T.course_id
  from course as T
  where not unique (select R.course_id
                    from section as R
                    where T.course_id=R.course_id and R.year=2017);
- Finds courses offered at least twice in 2017.
ğ–¦¹ If any attribute is null, unique may return true even when duplicates exist.

79. Subqueries in the From Clause
ğ–¦¹ A subquery can be treated as a temporary relation in the from clause.
â€¢ Example:
  select dept_name, avg_salary
  from (select dept_name, avg(salary) as avg_salary
        from instructor
        group by dept_name)
  where avg_salary > 42000;
- Finds departments with average salary above 42,000.
ğ–¦¹ Subqueries in from can be named and their columns renamed using as.
â€¢ Example:
  select dept_name, avg_salary
  from (select dept_name, avg(salary)
        from instructor
        group by dept_name)
  as dept_avg(dept_name, avg_salary)
  where avg_salary > 42000;
ğ–¦¹ Most SQL systems require a name for subqueries in from.
ğ–¦¹ Example for maximum total salary per department:
  select max(tot_salary)
  from (select dept_name, sum(salary)
        from instructor
        group by dept_name)
  as dept_total(dept_name, tot_salary);
ğ–¦¹ The lateral keyword allows a subquery to access outer variables in the same from clause.
â€¢ Example:
  select name, salary, avg_salary
  from instructor I1,
       lateral (select avg(salary) as avg_salary
                from instructor I2
                where I2.dept_name = I1.dept_name);

80. The With Clause
ğ–¦¹ Defines temporary relations used within a query.
â€¢ Example:
  with max_budget(value) as
  (select max(budget) from department)
  select budget
  from department, max_budget
  where department.budget = max_budget.value;
- Finds departments with the maximum budget.
ğ–¦¹ Makes complex queries easier to read and reuse.
â€¢ Example:
  with dept_total(dept_name, value) as
  (select dept_name, sum(salary)
   from instructor
   group by dept_name),
  dept_total_avg(value) as
  (select avg(value)
   from dept_total)
  select dept_name
  from dept_total, dept_total_avg
  where dept_total.value > dept_total_avg.value;
- Finds departments where total salary is above the average total.

81. Scalar Subqueries
ğ–¦¹ A scalar subquery returns a single value.
ğ–¦¹ Can appear in select, where, or having clauses.
â€¢ Example:
  select dept_name,
         (select count(*)
          from instructor
          where department.dept_name = instructor.dept_name)
         as num_instructors
  from department;
- Lists each department and its instructor count.
ğ–¦¹ If a scalar subquery returns more than one value, it causes an error at runtime.

82. Scalar Without a From Clause
ğ–¦¹ Some queries compute values without referencing tables.
â€¢ Example:
  (select count(*) from teaches)/(select count(*) from instructor);
- Finds average number of sections per instructor.
ğ–¦¹ Some systems require a dummy table like dual.
â€¢ Example:
  select (select count(*) from teaches)/(select count(*) from instructor)
  from dual;
ğ–¦¹ Multiply by 1.0 if a floating-point result is needed.

83. SQL and Multiset Relational Algebra (Part 3)
ğ–¦¹ Subqueries have no direct equivalent in relational algebra.
ğ–¦¹ Many subqueries can be rewritten using semijoin (â‹‰) and antijoin (â‹‰).
â€¢ r â‹‰ s returns tuples in r with matching tuples in s.
â€¢ r â‹‰ s returns tuples in r with no matching tuples in s.
ğ–¦¹ These are efficient and often used internally by databases.
ğ–¦¹ Rewriting subqueries is complex, so modern systems extend relational algebra to allow subqueries in predicates and projections.

84. Deletion in SQL
ğ–¦¹ SQL can delete whole tuples from a table, not individual attribute values.
ğ–¦¹ Syntax: delete from r where P;
â€¢ r is the relation, P is the predicate.
- If where clause is omitted, all tuples in the relation are deleted.
ğ–¦¹ Delete operates on one relation at a time; multiple relations require separate delete commands.
ğ–¦¹ The predicate in the where clause can be complex, including nested selects.
ğ–¦¹ Examples:
â€¢ Delete all instructors in the Finance department: delete from instructor where dept_name = 'Finance';
â€¢ Delete instructors with salary between $13,000 and $15,000.
â€¢ Delete instructors associated with departments in the Watson building using a nested select.
ğ–¦¹ Nested selects can reference the same relation being deleted.
â€¢ Example: delete instructors with salary below the average salary.

85. Insertion in SQL
ğ–¦¹ Insert data by specifying a tuple or using a query result.
ğ–¦¹ Attribute values must match the domain and number of attributes in the relation.
ğ–¦¹ Basic syntax: insert into course values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);
ğ–¦¹ Attributes can be specified explicitly in the insert statement.
ğ–¦¹ Insert using query results:
â€¢ Example: make students in Music department with >144 credits instructors with $18,000 salary.
ğ–¦¹ SQL evaluates the select fully before insertion to avoid infinite loops or duplicates.
ğ–¦¹ Partial attribute insertion assigns null to unspecified attributes.
â€¢ Example: insert into student values ('3003', 'Green', 'Finance', null);
ğ–¦¹ Bulk loader utilities allow fast insertion of many tuples from formatted files.

86. Updates in SQL
ğ–¦¹ Update changes values in existing tuples without changing all attributes.
ğ–¦¹ Syntax: update relation set attribute = value where condition;
ğ–¦¹ Example: increase all instructor salaries by 5%.
ğ–¦¹ Conditional updates using where clause:
â€¢ Example: increase salary by 5% only for instructors earning less than $70,000.
ğ–¦¹ Nested selects can be used in update statements, referencing the same relation.
â€¢ Example: increase salary by 5% for those below the average salary.
ğ–¦¹ Multiple conditional updates may require careful ordering.
â€¢ Example: 3% raise for salaries >$100,000, 5% for others.
ğ–¦¹ Case statements allow combining multiple conditions in one update.
â€¢ Syntax: 
  case
    when pred1 then result1
    when pred2 then result2
    ...
    else result0
  end
ğ–¦¹ Scalar subqueries can be used in set clause.
â€¢ Example: set student tot_cred = sum of credits from successfully completed courses.
ğ–¦¹ Handle nulls using case expression or coalesce function.
â€¢ Example: tot_cred = coalesce(sum(credits), 0)

87. Intermediate SQL
ğ–¦¹ Study of more complex SQL queries
ğ–¦¹ View definitions, transactions, integrity constraints
ğ–¦¹ SQL data definition and authorization details

88. Join Expressions
ğ–¦¹ Combines information from multiple relations
ğ–¦¹ Provides a more natural way to write queries than Cartesian product
ğ–¦¹ Can express queries difficult with only Cartesian product

89. The Natural Join
ğ–¦¹ Matches tuples with same values in common attributes
ğ–¦¹ Example: student natural join takes matches on ID
ğ–¦¹ Result includes only students who have taken courses
ğ–¦¹ Attributes common to both relations appear once
ğ–¦¹ Query equivalence: 
â€¢ select name, courseid from student, takes where student.ID = takes.ID
â€¢ select name, courseid from student natural join takes
- Both give same results
ğ–¦¹ Multiple natural joins can be combined:
â€¢ select A1, A2,â€¦, An from r1 natural join r2 natural join ... natural join rm where P
ğ–¦¹ Using join with specific columns:
â€¢ Example: select name, title from (student natural join takes) join course using (courseid)
- Ensures only specified attributes are matched

90. Join Conditions
ğ–¦¹ General join using arbitrary conditions with ON clause
ğ–¦¹ Example: select * from student join takes on student.ID = takes.ID
ğ–¦¹ ON condition can replicate WHERE clause behavior
ğ–¦¹ Improves readability and handles outer joins differently
ğ–¦¹ ON condition supports any SQL predicate for flexible joins

91. Outer Joins
ğ–¦¹ Preserves tuples that would be lost in inner joins
ğ–¦¹ Types of outer joins:
â€¢ Left outer join: preserves tuples from left relation
â€¢ Right outer join: preserves tuples from right relation
â€¢ Full outer join: preserves tuples from both relations
ğ–¦¹ Preserves unmatched tuples by filling non-matching attributes with nulls
ğ–¦¹ Example: student natural left outer join takes includes students with no courses
ğ–¦¹ Query to find students who have not taken any course:
â€¢ select ID from student natural left outer join takes where courseid is null
ğ–¦¹ Right outer join works symmetrically, order of relations affects result attribute order

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -[11/11/2025]
92. Purpose of Views  
ğ–¦¹ Not all users should see full data in all relations  
ğ–¦¹ Views allow showing only selected attributes  
â€¢ Example: Clerk can see ID, name, dept_name but not salary  

93. Personalized Virtual Relations  
ğ–¦¹ Views help present data in a more intuitive structure for specific users  
â€¢ Example: List Physics department course sections in Fall 2017 with building and room info  

94. Virtual Relation Behavior  
ğ–¦¹ Results of a view are not stored permanently  
ğ–¦¹ Data is computed whenever the view is used  
- Prevents outdated or inconsistent data  

95. View Definition  
ğ–¦¹ Defined using [pink]create view[/pink] command  
â€¢ Syntax: [pink]create view[/pink] [yellow]v as <query expression>[/yellow];  
â€¢ Example: [pink]create view[/pink] [yellow]faculty as[/yellow] [pink]select[/pink] [yellow]ID, name, dept_name[/yellow] [pink]from[/pink] [yellow]instructor[/yellow];  

96. Example of Course Section View  
ğ–¦¹ Can define view for Physics Fall 2017 sections  
â€¢ View stores query definition, not results  
â€¢ Recomputed when accessed  

97. Persistence of Views  
ğ–¦¹ Views remain available until explicitly dropped  
ğ–¦¹ Unlike [pink]with[/pink] clause which is local to a single query  

98. Using Views in Queries  
ğ–¦¹ View name used like a table name  
â€¢ Example: [pink]select[/pink] [yellow]course_id[/yellow] [pink]from[/pink] [yellow]physics_fall_2017[/yellow] [pink]where[/pink] [yellow]building = 'Watson'[/yellow];  
ğ–¦¹ Attribute names can be explicitly set in view definition  

99. Views Recomputed Automatically  
ğ–¦¹ View content is conceptually the result of the defining query  
ğ–¦¹ When used in a query, the view definition replaces the view name  
ğ–¦¹ Views can be defined based on other views  

100. Materialized Views  
ğ–¦¹ Some systems allow storing view results physically  
ğ–¦¹ View is kept updated when base data changes  
- Called materialized view maintenance  
â€¢ Can improve performance for frequent queries  
â€¢ May become stale if maintenance is delayed  

101. Updating Views Issues  
ğ–¦¹ Updates through views must translate to actual base table updates  
ğ–¦¹ Some updates may fail or cause missing required data  
â€¢ Example: inserting into view without salary leads to null salary or rejection  

102. Complex View Update Problems  
ğ–¦¹ Joins in view can make updates ambiguous  
ğ–¦¹ Some desired updates cannot be correctly performed through the view  

103. Conditions for Updatable Views (with examples)  
ğ–¦¹ [pink]FROM[/pink] clause references only one base relation  
â€¢ Example (Updatable):  
  [pink]create view[/pink] [yellow]cs_instructors as[/yellow]  
  [pink]select[/pink] [yellow]ID, name, dept_name[/yellow]  
  [pink]from[/pink] [yellow]instructor[/yellow]  
  [pink]where[/pink] [yellow]dept_name = 'Comp. Sci'[/yellow];  
- Only one base table is used: instructor  
â€¢ Example (Not Updatable):  
  [pink]create view[/pink] [yellow]instructor_info as[/yellow]  
  [pink]select[/pink] [yellow]instructor.ID, name, building[/yellow]  
  [pink]from[/pink] [yellow]instructor, department[/yellow]  
  [pink]where[/pink] [yellow]instructor.dept_name = department.dept_name[/yellow];  
- Uses two tables, so updates cannot be done directly  
ğ–¦¹ [pink]SELECT[/pink] clause has only attribute names (no aggregates or expressions)  
â€¢ Example (Updatable):  
  [pink]create view[/pink] [yellow]history_instructors as[/yellow]  
  [pink]select[/pink] [yellow]ID, name, dept_name, salary[/yellow]  
  [pink]from[/pink] [yellow]instructor[/yellow]  
  [pink]where[/pink] [yellow]dept_name = 'History'[/yellow];  
- Only attribute names are selected  
â€¢ Example (Not Updatable):  
  [pink]create view[/pink] [yellow]dept_salary_total as[/yellow]  
  [pink]select[/pink] [yellow]dept_name, sum(salary)[/yellow]  
  [pink]from[/pink] [yellow]instructor[/yellow]  
  [pink]group by[/pink] [yellow]dept_name[/yellow];  
- Uses aggregate [pink]sum[/pink][yellow](salary)[/yellow], so cannot be updated  
ğ–¦¹ Attributes not shown must allow nulls and not be part of primary key  
â€¢ Example (Updatable if missing attributes allow nulls):  
  [pink]create view[/pink] [yellow]instructor_basic as[/yellow]  
  [pink]select[/pink] [yellow]ID, name[/yellow]  
  [pink]from[/pink] [yellow]instructor[/yellow];  
- Allowed only if dept_name and salary accept nulls and are not primary key components  
â€¢ Example (Not Updatable if missing attributes are NOT NULL or part of key):  
  [pink]create view[/pink] [yellow]instructor_without_id as[/yellow]  
  [pink]select[/pink] [yellow]name, dept_name[/yellow]  
  [pink]from[/pink] [yellow]instructor[/yellow];  
- Cannot insert because ID is primary key and required, so missing attribute breaks rule  
ğ–¦¹ No [pink]GROUP BY[/pink] or [pink]HAVING[/pink]  
â€¢ Example (Updatable):  
  [pink]create view[/pink] [yellow]bio_instructors as[/yellow]  
  [pink]select[/pink] [yellow]*[/yellow]  
  [pink]from[/pink] [yellow]instructor[/yellow]  
  [pink]where[/pink] [yellow]dept_name = 'Biology'[/yellow];  
- Simple selection, no grouping  
â€¢ Example (Not Updatable):  
  [pink]create view[/pink] [yellow]building_instructor_count as[/yellow]  
  [pink]select[/pink] [yellow]building, count(ID)[/yellow]  
  [pink]from[/pink] [yellow]department, instructor[/yellow]  
  [pink]where[/pink] [yellow]instructor.dept_name = department.dept_name[/yellow]  
  [pink]group by[/pink] [yellow]building[/yellow];  
- [pink]GROUP BY[/pink] used, view is not updatable  

104. With Check Option  
ğ–¦¹ Ensures inserted/updated tuples still satisfy view conditions  
ğ–¦¹ If not satisfied, modification is rejected  

105. Alternative: Using Triggers  
ğ–¦¹ [pink]Instead of[/pink] clause in triggers can handle custom update actions on views  
ğ–¦¹ Allows more controlled and logical view-based modifications  

106. Definition of a Transaction  
ğ–¦¹ A transaction is a sequence of SQL query and/or update statements  
ğ–¦¹ A transaction starts automatically when an SQL statement runs  
ğ–¦¹ The transaction ends only when [pink]commit[/pink] or [pink]rollback[/pink] is issued  

107. Commit Work  
ğ–¦¹ [pink]commit work[/pink] makes all updates permanent  
ğ–¦¹ After [pink]commit[/pink], a new transaction starts automatically  
â€¢ Similar to saving changes in a document  

108. Rollback Work  
ğ–¦¹ [pink]rollback work[/pink] cancels all updates done in the current transaction  
ğ–¦¹ Restores the database to state before transaction began  
â€¢ Similar to closing a document without saving  

109. Transaction Safety on Failures  
ğ–¦¹ If a failure occurs before [pink]commit[/pink], the system rolls back the transaction  
ğ–¦¹ Failures may include power loss, errors, or crashes  
â€¢ Ensures database does not remain in a partial or inconsistent state  

110. Banking Example of Atomicity  
ğ–¦¹ Money transfer updates two accounts: subtract from source, add to destination  
â€¢ If system crashes midway, balances may become inconsistent  
- Transactions ensure either both updates happen or none happen  

111. University Application Example  
ğ–¦¹ Updating takes and student.tot_cred must occur together  
â€¢ If one update happens and the other fails, student data becomes inconsistent  
- Performing both inside a transaction prevents partial updates  

112. Atomicity Concept  
ğ–¦¹ A transaction is atomic (indivisible)  
ğ–¦¹ Either all changes of a transaction are applied or none  
â€¢ Prevents database from being left in a partially updated state  

113. Program Ending Without Commit or Rollback  
ğ–¦¹ Behavior depends on implementation  
ğ–¦¹ Some systems [pink]commit[/pink], some [pink]roll back[/pink]  
â€¢ Not standardized in SQL  

114. Autocommit Behavior  
ğ–¦¹ Many systems (e.g., MySQL, PostgreSQL) automatically [pink]commit[/pink] each statement  
ğ–¦¹ Must turn autocommit off to group multiple statements into a transaction  
â€¢ Command often: [pink]set autocommit off[/pink]  

115. SQL:1999 Transaction Block Syntax  
ğ–¦¹ [pink]begin atomic[/pink] â€¦ [pink]end[/pink] encloses multiple statements as one transaction  
ğ–¦¹ Only some databases (e.g., SQL Server) support this syntax  

116. Alternative Transaction Control Syntax  
ğ–¦¹ Some systems support [pink]begin[/pink] to start a transaction  
ğ–¦¹ Must explicitly end with [pink]commit work[/pink] or [pink]rollback work[/pink]  

117. Oracle Commit Behavior  
ğ–¦¹ Oracle does not autocommit DML statements by default  
ğ–¦¹ If [pink]commit[/pink] is not issued, changes are rolled back when disconnecting  
â€¢ Local configuration may override default behavior  

118. Integrity Constraints  
ğ–¦¹ Integrity constraints ensure data consistency when authorized users modify the database.  
ğ–¦¹ They prevent accidental damage to data, unlike security constraints which prevent unauthorized access.  
ğ–¦¹ Examples of integrity constraints:  
â€¢ An instructor name cannot be null.  
â€¢ Instructor IDs must be unique.  
â€¢ Every course's department name must match an existing department.  
â€¢ A departmentâ€™s budget must be greater than 0.  
ğ–¦¹ In principle, an integrity constraint can be any logical condition on the database, but systems restrict them to efficiently testable constraints.  
ğ–¦¹ Integrity constraints are usually defined during schema design and included in [pink]create table[/pink] statements.  
ğ–¦¹ Constraints can be added later using: [pink]alter table[/pink] [yellow]table-name add constraint constraint-definition[/yellow].  
- The DBMS checks whether current data satisfies the constraint before adding.  

119. Constraints on a Single Relation  
ğ–¦¹ [pink]create table[/pink] can include integrity-constraint statements alongside attribute definitions.  
ğ–¦¹ Common constraints available:  
â€¢ [pink]not null[/pink]  
â€¢ [pink]unique[/pink]  
â€¢ [pink]check[/pink][yellow](predicate)[/yellow]  
ğ–¦¹ These constraints restrict allowed values for attributes and maintain correctness.  

120. Not Null Constraint  
ğ–¦¹ By default, SQL allows null for any attribute unless restricted.  
ğ–¦¹ [pink]not null[/pink] disallows null values for an attribute.  
â€¢ Example: [yellow]name varchar(20) not null[/yellow]  
â€¢ Example: [yellow]budget numeric(12,2) not null[/yellow]  
ğ–¦¹ Attempting to insert null into such attributes results in an error.  
ğ–¦¹ Primary keys automatically disallow null values; they need not be explicitly marked [pink]not null[/pink].  

121. Unique Constraint  
ğ–¦¹ [pink]unique[/pink][yellow](A1, A2, ..., Am)[/yellow] specifies that these attributes together must form a superkey.  
ğ–¦¹ No two tuples can have the same combination of values for the listed attributes.  
ğ–¦¹ Attributes under [pink]unique[/pink] may still contain null unless also declared [pink]not null[/pink].  

122. Check Clause  
ğ–¦¹ [pink]check[/pink][yellow](predicate)[/yellow] ensures that every tuple satisfies the given logical condition.  
â€¢ Example: [pink]check[/pink][yellow](budget > 0)[/yellow] ensures department budgets are positive.  
â€¢ Example with enumerated behavior:  
  [yellow]semester varchar(6)[/yellow] [pink]check[/pink] [yellow](semester in ('Fall', 'Winter', 'Spring', 'Summer'))[/yellow]  
ğ–¦¹ If a [pink]check[/pink] expression evaluates to unknown due to null values, the tuple is allowed.  
ğ–¦¹ Constraints applying to single attributes are usually placed beside attribute declarations; complex ones appear at the end of [pink]create table[/pink].  

123. Referential Integrity  
ğ–¦¹ Ensures that a value in one relation (referencing relation) must exist in another relation (referenced relation).  
ğ–¦¹ Declared using [pink]foreign key[/pink] clauses.  
â€¢ Example: [pink]foreign key[/pink] [yellow](dept name)[/yellow] [pink]references[/pink] [yellow]department[/yellow]  
ğ–¦¹ Referenced attributes must form a primary key or [pink]unique[/pink] key.  
ğ–¦¹ Actions on violation:  
â€¢ [pink]on delete cascade[/pink]: deleting the referenced tuple deletes referencing tuples.  
â€¢ [pink]on update cascade[/pink]: updates propagate to referencing relations.  
â€¢ [pink]set null[/pink] or [pink]set default[/pink] may be used instead of cascade.  
ğ–¦¹ Foreign key attributes may be null unless explicitly forbidden.  

124. Assigning Names to Constraints  
ğ–¦¹ Constraints can be named using [pink]constraint[/pink] [yellow]constraint-name[/yellow] before the constraint definition.  
â€¢ Example: [pink]constraint[/pink] [yellow]minsalary[/yellow] [pink]check[/pink][yellow](salary > 29000)[/yellow]  
ğ–¦¹ Named constraints can later be dropped using:  
â€¢ [pink]alter table[/pink] [yellow]table-name drop constraint constraint-name[/yellow]  

125. Constraint Checking During Transactions  
ğ–¦¹ Some transactions temporarily violate constraints before later steps restore correctness.  
ğ–¦¹ Constraints may be declared initially deferred so they are checked only at the end of the transaction.  
ğ–¦¹ Constraints may also be deferrable, meaning they can be switched between immediate and deferred checking using [pink]set constraints[/pink].  

126. Complex Check Conditions and Assertions  
ğ–¦¹ [pink]check[/pink] predicates can theoretically contain subqueries, but most systems do not support this.  
ğ–¦¹ Assertions express global database conditions:  
â€¢ [pink]create assertion[/pink] [yellow]name[/yellow] [pink]check[/pink][yellow](predicate)[/yellow]  
ğ–¦¹ Assertions are tested at creation and on all updates.  
ğ–¦¹ Assertions may impose high performance costs, so few systems support them.  
ğ–¦¹ Equivalent behavior can be implemented using triggers.  

127. SQL Data Types and Schemas  
ğ–¦¹ SQL supports various built-in and user-defined data types.  
ğ–¦¹ Additional date/time types, type conversion, default values, large objects, user-defined types, and key generation are included.  

128. Date and Time Types in SQL  
ğ–¦¹ [yellow]date[/yellow] stores year, month, and day.  
ğ–¦¹ [yellow]time[/yellow] stores hour, minute, and second.  
 â€¢ [yellow]time(p)[/yellow] allows specifying fractional seconds.  
 â€¢ [yellow]time with timezone[/yellow] stores time-zone data.  
ğ–¦¹ [yellow]timestamp[/yellow] stores date and time together.  
 â€¢ [yellow]timestamp(p)[/yellow] allows fractional seconds.  
 â€¢ [yellow]timestamp with timezone[/yellow] stores time-zone data.  
ğ–¦¹ Example values:  
 â€¢ [yellow]date '2018-04-25'[/yellow]  
 â€¢ [yellow]time '09:30:00'[/yellow]  
 â€¢ [yellow]timestamp '2018-04-25 10:29:01.45'[/yellow]  
ğ–¦¹ [pink]extract[/pink][yellow](field from d)[/yellow] retrieves parts like year, month, hour, etc.  
ğ–¦¹ Functions:  
 â€¢ [pink]current date[/pink] returns current date.  
 â€¢ [pink]current time[/pink] returns time with timezone.  
 â€¢ [pink]localtime[/pink] returns time without timezone.  
 â€¢ [pink]current timestamp[/pink] and [pink]localtimestamp[/pink] return date plus time.  
ğ–¦¹ Some systems offer [yellow]datetime[/yellow] without timezone.  
ğ–¦¹ SQL supports arithmetic and comparison on date/time.  
ğ–¦¹ [yellow]interval[/yellow] type supports calculations like:  
 â€¢ [yellow]x - y[/yellow] returns days between dates.  
 â€¢ Adding/subtracting interval modifies date or time.  

129. Type Conversion and Formatting Functions  
ğ–¦¹ Automatic type conversion sometimes occurs; explicit conversion uses [pink]cast[/pink][yellow](e as t)[/yellow].  
ğ–¦¹ Casting helps achieve correct ordering or calculations.  
 â€¢ Example: [pink]cast[/pink][yellow](ID as numeric(5))[/yellow] ensures numeric sorting.  
ğ–¦¹ Formatting functions change output display but not stored data.  
 â€¢ MySQL: [pink]format[/pink]  
 â€¢ Oracle/PostgreSQL: [pink]to char[/pink], [pink]to number[/pink], [pink]to date[/pink]  
 â€¢ SQL Server: [pink]convert[/pink]  
ğ–¦¹ [pink]coalesce[/pink] returns first non-null value.  
 â€¢ Example: [pink]coalesce[/pink][yellow](salary, 0)[/yellow] displays 0 instead of null.  
ğ–¦¹ [pink]decode[/pink] (Oracle) replaces values based on matching patterns.  
 â€¢ Can replace null with 'N/A' when needed.  

130. Default Values  
ğ–¦¹ Attributes can have default values in table definitions.  
ğ–¦¹ Example:  
 â€¢ [yellow]tot cred numeric(3,0) default 0[/yellow]  
ğ–¦¹ Inserting without specifying tot cred assigns default value automatically.  

131. Large-Object Types  
ğ–¦¹ [yellow]clob[/yellow] stores large character data.  
ğ–¦¹ [yellow]blob[/yellow] stores large binary data (images, video, etc.).  
ğ–¦¹ Example:  
 â€¢ [yellow]book review clob(10KB)[/yellow]  
 â€¢ [yellow]image blob(10MB)[/yellow]  
 â€¢ [yellow]movie blob(2GB)[/yellow]  
ğ–¦¹ Large objects are usually accessed through locators rather than loading all data at once.  

132. User-Defined Types (Distinct Types)  
ğ–¦¹ [pink]create type[/pink] defines custom types separate from built-in types.  
ğ–¦¹ Example:  
 â€¢ [pink]create type[/pink] [yellow]Dollars as numeric(12,2) final[/yellow];  
ğ–¦¹ Used to prevent errors, such as mixing currency types.  
ğ–¦¹ Operations between different distinct types require explicit [pink]cast[/pink].  
ğ–¦¹ [pink]drop type[/pink] and [pink]alter type[/pink] modify or remove user-defined types.  

133. Domains  
ğ–¦¹ [pink]create domain[/pink] defines new domains with constraints.  
ğ–¦¹ Example:  
 â€¢ [pink]create domain[/pink] [yellow]DDollars as numeric(12,2) not null[/yellow];  
ğ–¦¹ Domains support constraints and default values.  
ğ–¦¹ Domains are not strictly typed; compatible types may mix.  
ğ–¦¹ Example constraint:  
 â€¢ [pink]create domain[/pink] [yellow]YearlySalary numeric(8,2)[/yellow]  
   [pink]check[/pink][yellow](value >= 29000.00)[/yellow];  
ğ–¦¹ Domains can also restrict values using [pink]in[/pink] clause.  

134. Generating Unique Key Values  
ğ–¦¹ Automatically assigns unique numeric identifiers.  
ğ–¦¹ Example syntax:  
 â€¢ [yellow]ID number(5) generated always as identity[/yellow]  
ğ–¦¹ [pink]always[/pink] means user cannot manually insert value.  
ğ–¦¹ [pink]by default[/pink] allows manual insertion or automatic generation.  
ğ–¦¹ Equivalent features:  
 â€¢ PostgreSQL: [yellow]serial[/yellow]  
 â€¢ MySQL: [yellow]auto increment[/yellow]  
 â€¢ SQL Server: [yellow]identity[/yellow]  
ğ–¦¹ [pink]create sequence[/pink] generates unique values for multiple tables.  

135. Create Table Extensions  
ğ–¦¹ [pink]create table[/pink] ... [pink]like[/pink] duplicates schema.  
 â€¢ Example: [pink]create table[/pink] [yellow]temp instructor like instructor[/yellow];  
ğ–¦¹ [pink]create table[/pink] ... [pink]as[/pink] stores query results into a new table.  
 â€¢ Example:  
   [pink]create table[/pink] [yellow]t1 as ([/yellow][pink]select[/pink] [yellow]*[/yellow] [pink]from[/pink] [yellow]instructor[/yellow] [pink]where[/pink] [yellow]dept name = 'Music')[/yellow] [pink]with data[/pink];  
ğ–¦¹ Table created with data stores current results; views reflect dynamic data.  
136. Schemas, Catalogs, and Environments  
ğ–¦¹ SQL uses a hierarchy: catalogs contain schemas, schemas contain tables and objects.  
ğ–¦¹ Similar to folders and subfolders in file systems.  
ğ–¦¹ Users connect to a specific catalog before performing operations.  

137. Authorization  
ğ–¦¹ Users can be given specific rights called privileges.  
ğ–¦¹ Data privileges include:  
â€¢ Read data ([pink]select[/pink])  
â€¢ Insert new data ([pink]insert[/pink])  
â€¢ Update data ([pink]update[/pink])  
â€¢ Delete data ([pink]delete[/pink])  
ğ–¦¹ A user may receive any combination of privileges on specific relations or views.  
ğ–¦¹ When a query or update is submitted, the system checks if the user has proper authorization.  
ğ–¦¹ Users may also be granted schema permissions to create, modify, or drop relations.  
ğ–¦¹ Some users may further grant or revoke privileges from others.  
ğ–¦¹ The database administrator has full authority over all users and schema objects.  

138. Granting and Revoking of Privileges  
ğ–¦¹ SQL privileges include [pink]select[/pink], [pink]insert[/pink], [pink]update[/pink], and [pink]delete[/pink].  
ğ–¦¹ [pink]all privileges[/pink] can be used to grant all allowed privileges at once.  
ğ–¦¹ A user who creates a relation automatically gets all privileges on it.  
ğ–¦¹ Privileges are granted using:  
â€¢ [pink]grant[/pink] [yellow]<privileges> on <relation/view> to <user/role list>[/yellow];  
ğ–¦¹ Example:  
â€¢ [pink]grant select on[/pink] [yellow]department to Amit, Satoshi[/yellow]; (allows reading)  
ğ–¦¹ [pink]update[/pink] privilege can be given on all attributes or specific attributes:  
â€¢ [pink]grant update[/pink][yellow](budget)[/yellow] [pink]on[/pink] [yellow]department to Amit, Satoshi[/yellow];  
ğ–¦¹ [pink]insert[/pink] privilege may specify attributes; missing attributes get default or null values.  
ğ–¦¹ [pink]delete[/pink] privilege allows removal of tuples.  
ğ–¦¹ [yellow]public[/yellow] refers to all users.  
ğ–¦¹ To revoke privileges:  
â€¢ [pink]revoke[/pink] [yellow]<privileges> on <relation/view> from <user/role list>[/yellow];  

139. Roles  
ğ–¦¹ Roles allow grouping privileges and assigning them to multiple users.  
ğ–¦¹ Suitable where many users need the same permissions.  
ğ–¦¹ Users are assigned roles; roles store the actual privileges.  
ğ–¦¹ Roles prevent security issues caused by shared user accounts.  
ğ–¦¹ Roles are created using:  
â€¢ [pink]create role[/pink] [yellow]instructor[/yellow];  
ğ–¦¹ Privileges are granted to roles like users:  
â€¢ [pink]grant select on[/pink] [yellow]takes to instructor[/yellow];  
ğ–¦¹ Roles can be granted to users or other roles:  
â€¢ [pink]grant[/pink] [yellow]instructor to dean[/yellow];  
â€¢ [pink]grant[/pink] [yellow]dean to Satoshi[/yellow];  
ğ–¦¹ A userâ€™s effective privileges include:  
â€¢ Privileges granted directly  
â€¢ Privileges from assigned roles (including indirectly inherited roles)  

140. Authorization on Views  
ğ–¦¹ Users may be given privileges on views to restrict which parts of a relation they can see.  
ğ–¦¹ The system checks authorization before expanding a view into its underlying relations.  
ğ–¦¹ A user must already have required privileges on base relations to receive certain privileges on a view.  
ğ–¦¹ Example: View for Geology department faculty:  
â€¢ [pink]create view[/pink] [yellow]geo_instructor as ([/yellow][pink]select[/pink] [yellow]*[/yellow] [pink]from[/pink] [yellow]instructor[/yellow] [pink]where[/pink] [yellow]dept_name = 'Geology'[/yellow]);  
ğ–¦¹ If the user lacks [pink]select[/pink] on [yellow]instructor[/yellow], the system denies creation of such a view.  
ğ–¦¹ Functions and procedures can also have [pink]execute[/pink] privilege.  
ğ–¦¹ [pink]sql security invoker[/pink] causes a function to run under the callerâ€™s privileges instead of the creatorâ€™s.  

141. Authorization on Schema  
ğ–¦¹ Schema modifications such as creating or deleting relations are allowed only by the schema owner.  
ğ–¦¹ [pink]references[/pink] privilege is required to declare foreign keys referencing another relation.  
â€¢ Example:  
[pink]grant references[/pink][yellow](dept_name)[/yellow] [pink]on[/pink] [yellow]department to Mariano[/yellow];  
ğ–¦¹ Foreign keys and [pink]check[/pink] constraints referencing another relation may limit updates, so [pink]references[/pink] privilege is needed.  

142. Transfer of Privileges  
ğ–¦¹ A user granted a privilege may or may not be allowed to grant it further.  
ğ–¦¹ To allow granting to others, use [pink]with grant option[/pink]:  
â€¢ [pink]grant select on[/pink] [yellow]department to Amit with grant option[/yellow];  
ğ–¦¹ Privileges can be represented as an authorization graph showing who granted privileges to whom.  

143. Revoking of Privileges  
ğ–¦¹ Revocation may cause others to lose privileges if those privileges were passed on.  
ğ–¦¹ This behavior is called cascading revocation.  
ğ–¦¹ Example:  
â€¢ [pink]revoke select on[/pink] [yellow]department from Amit, Satoshi[/yellow];  
ğ–¦¹ If [pink]restrict[/pink] is specified, [pink]revoke[/pink] fails if cascading is required:  
â€¢ [pink]revoke select on[/pink] [yellow]department from Amit restrict[/yellow];  
ğ–¦¹ [pink]grant option[/pink] can be revoked without removing the privilege itself.  

144. Row-Level Authorization  
ğ–¦¹ Some systems allow controlling access to specific tuples.  
ğ–¦¹ Oracle VPD attaches a predicate to a relation so only permitted rows are returned.  
ğ–¦¹ Example predicate:  
â€¢ [yellow]ID = sys_context('USERENV','SESSION_USER')[/yellow]  
ğ–¦¹ This ensures users see only their own rows.  
ğ–¦¹ May change meaning of queries if not carefully designed (for example, aggregates apply only to visible rows).  

145. Accessing SQL from a Programming Language  
ğ–¦¹ SQL is a powerful declarative query language, easier than general-purpose languages.  
ğ–¦¹ General-purpose languages are needed because:  
â€¢ Some queries cannot be expressed in SQL alone.  
- Embedding SQL in languages like C, Java, or Python solves this.  
â€¢ Nondeclarative actions like printing reports or GUI interactions cannot be done in SQL.  
- Applications often combine SQL with general-purpose languages.  
ğ–¦¹ Two approaches to access SQL from a programming language:  
â€¢ Dynamic SQL: Queries constructed at runtime as strings, executed, and results retrieved.  
â€¢ Embedded SQL: SQL statements identified at compile time, translated by a preprocessor.  

146. Standards for Connecting to SQL  
ğ–¦¹ JDBC: Java API for connecting to databases.  
ğ–¦¹ ODBC: Originally for C, extended to many languages like C++, C#, Ruby, Go, PHP.  
ğ–¦¹ Python Database API: Allows Python programs to connect to databases.  
ğ–¦¹ ADO.NET: For Visual Basic .NET and C#, similar to JDBC, can access non-relational sources.  

147. JDBC Overview  
ğ–¦¹ JDBC allows Java programs to connect to database servers.  
ğ–¦¹ Requires importing [yellow]java.sql.*[/yellow].  
ğ–¦¹ Steps to use JDBC:  
â€¢ Connect to database using [yellow]DriverManager.getConnection()[/yellow].  
â€¢ Use [yellow]Statement[/yellow] object to send SQL statements.  
â€¢ Retrieve results via [yellow]ResultSet[/yellow].  
â€¢ Handle exceptions and manage resources.  

148. Connecting to the Database  
ğ–¦¹ [yellow]getConnection()[/yellow] parameters:  
â€¢ URL of the server, protocol, port, and database name.  
â€¢ Database user identifier (string).  
â€¢ Password (string).  
ğ–¦¹ [yellow]Connection[/yellow] object handle is created for interaction.  
ğ–¦¹ JDBC driver must be loaded to translate JDBC calls to database-specific calls.  

149. Shipping SQL Statements  
ğ–¦¹ Use [yellow]Statement[/yellow] object to execute SQL.  
â€¢ [yellow]executeQuery()[/yellow] for queries returning [yellow]ResultSet[/yellow].  
â€¢ [yellow]executeUpdate()[/yellow] for [pink]insert[/pink], [pink]update[/pink], [pink]delete[/pink], [pink]create table[/pink]; returns number of affected tuples.  
ğ–¦¹ DDL statements return zero.  

150. Exceptions and Resource Management  
ğ–¦¹ Use [yellow]try-catch[/yellow] to handle [yellow]SQLExceptions[/yellow] and general [yellow]Exceptions[/yellow].  
ğ–¦¹ Resources like connections and statements must be closed to avoid exhaustion.  
ğ–¦¹ Prefer [yellow]try-with-resources[/yellow] in Java to automatically close resources.  

151. Retrieving Query Results  
ğ–¦¹ [yellow]ResultSet[/yellow] fetches tuples one at a time.  
â€¢ [yellow]next()[/yellow] method checks and retrieves next tuple.  
â€¢ [yellow]getString()[/yellow], [yellow]getFloat()[/yellow], etc., retrieve attribute values by name or position.  

152. Prepared Statements  
ğ–¦¹ [yellow]PreparedStatement[/yellow] allows parameterized queries with â€œ?â€ placeholders.  
ğ–¦¹ Parameters set using methods like [yellow]setString()[/yellow] and [yellow]setInt()[/yellow].  
ğ–¦¹ Advantages:  
â€¢ Efficient execution of repeated queries.  
â€¢ Prevents SQL injection by escaping user input.  
ğ–¦¹ Never concatenate user input directly into SQL statements.  

153. Callable Statements  
ğ–¦¹ [yellow]CallableStatement[/yellow] invokes SQL stored procedures and functions.  
ğ–¦¹ [yellow]registerOutParameter()[/yellow] registers return types and out parameters.  
ğ–¦¹ [yellow]get[/yellow] methods retrieve results similar to [yellow]ResultSet[/yellow].  
154. Metadata Features  
ğ–¦¹ [yellow]ResultSetMetaData[/yellow] provides info about result sets:  
â€¢ Number of columns, column names, types.  
ğ–¦¹ [yellow]DatabaseMetaData[/yellow] provides info about database and system:  
â€¢ Tables, columns, primary keys, foreign keys, authorizations, limits.  
ğ–¦¹ Metadata allows writing generic programs without hard-coded schema.  

155. Other JDBC Features  
ğ–¦¹ Updatable result sets allow updating tuples in database via result sets.  
ğ–¦¹ Transaction control:  
â€¢ [yellow]setAutoCommit(false)[/yellow] disables automatic commit.  
â€¢ [yellow]commit()[/yellow] and [yellow]rollback()[/yellow] control transactions manually.  
ğ–¦¹ Handling large objects:  
â€¢ [yellow]getBlob()[/yellow], [yellow]getClob()[/yellow] fetch locators to large objects.  
â€¢ [yellow]setBlob()[/yellow], [yellow]setClob()[/yellow] store data from streams.  
ğ–¦¹ Row sets can be collected, shipped, scanned, and modified.  

156. Database Access from Python  
ğ–¦¹ Python can access databases using drivers like [yellow]psycopg2[/yellow] for PostgreSQL.  
ğ–¦¹ Prepared statements in Python use [yellow]"%s"[/yellow] for parameters and require [yellow]commit()[/yellow] to save updates.  
â€¢ Parameter values are provided as a list.  
- Updates are not committed automatically; [yellow]commit()[/yellow] must be called.  
ğ–¦¹ Exceptions are caught using [yellow]try-except[/yellow] blocks.  
â€¢ Provides information about errors.  
ğ–¦¹ Query results can be iterated using a [yellow]for[/yellow] loop.  
â€¢ Individual row attributes can be accessed via indexing.  
ğ–¦¹ Different drivers exist for different databases: [yellow]MySQLdb[/yellow] for MySQL, [yellow]cx_Oracle[/yellow] for Oracle, [yellow]pyodbc[/yellow] for ODBC.  
â€¢ Minor differences exist across drivers in the [yellow]connect()[/yellow] function parameters.  

157. ODBC  
ğ–¦¹ ODBC defines an API to connect to databases, send queries, and receive results.  
ğ–¦¹ Each database provides a library that communicates with the server when API calls are made.  
ğ–¦¹ Steps to use ODBC in C:  
â€¢ Allocate SQL environment ([yellow]HENV[/yellow]), then connection handle ([yellow]HDBC[/yellow]).  
â€¢ Open connection using [yellow]SQLConnect[/yellow] with server, user, and password.  
â€¢ Send SQL commands using [yellow]SQLExecDirect[/yellow].  
â€¢ Bind C variables to query attributes using [yellow]SQLBindCol[/yellow].  
â€¢ Fetch result tuples using [yellow]SQLFetch[/yellow] in a loop.  
â€¢ Free statement handle, disconnect, and free environment at the end.  
ğ–¦¹ SQL statements can use placeholders [yellow]"?"[/yellow] for parameters.  
â€¢ Statements can be prepared and executed multiple times with different values.  
ğ–¦¹ Automatic commit is on by default.  
â€¢ Turn off with [yellow]SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)[/yellow].  
â€¢ Transactions can be committed with [yellow]SQLTransact(conn, SQL_COMMIT)[/yellow] or rolled back with [yellow]SQLTransact(conn, SQL_ROLLBACK)[/yellow].  
ğ–¦¹ ODBC defines conformance levels:  
â€¢ Core: basic functionality.  
â€¢ Level 1: fetch catalog info like relations and attribute types.  
â€¢ Level 2: advanced features like arrays of parameter values and detailed catalog info.  
ğ–¦¹ SQL Call Level Interface (CLI) is similar to ODBC.  

158. Embedded SQL  
ğ–¦¹ SQL can be embedded in host languages like C, C++, Java, COBOL, Pascal, PL/I, and Fortran.  
ğ–¦¹ A preprocessor converts embedded SQL into host-language code before compilation.  
â€¢ [yellow]EXEC SQL <statement>;[/yellow] identifies embedded SQL.  
ğ–¦¹ Host language variables can be used in SQL with a colon prefix ([yellow]:[/yellow]).  
ğ–¦¹ Cursors allow iteration over query results.  
â€¢ Fetch rows into host language variables.  
â€¢ Updates can be performed using cursors with optional [pink]WHERE[/pink] clauses.  
ğ–¦¹ Embedded SQL allows some SQL errors to be caught at preprocessing.  
ğ–¦¹ Queries in embedded SQL are easier to read than dynamic SQL.  
ğ–¦¹ Disadvantages:  
â€¢ Preprocessor generates extra host code, complicating debugging.  
â€¢ Syntax clashes with host language may occur in future versions.  
ğ–¦¹ Most modern systems prefer dynamic SQL.  
â€¢ Microsoft LINQ is an exception, integrating queries into the host language.  

159. Embedded Databases  
ğ–¦¹ Embedded databases exist entirely within an application.  
â€¢ Accessible only through the application.  
ğ–¦¹ Examples include Java DB, SQLite, HSQLDB, and embedded MySQL.  
ğ–¦¹ They lack full server features but are suitable for small databases or internal applications.  
ğ–¦¹ Embedded databases are different from embedded SQL.  
â€¢ Embedded SQL connects to server-based databases, not internal-only databases.  

160. Functions and Procedures  
ğ–¦¹ SQL allows developers to write their own functions and procedures and store them in the database.  
ğ–¦¹ Functions are useful with specialized data types like images or geometric objects.  
â€¢ Example: line-segment overlap check in a map database, image similarity functions.  
ğ–¦¹ Procedures and functions allow business logic to be stored in the database.  
â€¢ Example: rules for course limits, instructor teaching load, maximum majors for a student.  
- Advantages: multiple applications can access them, single point of change for business rules.  
ğ–¦¹ SQL allows definitions in SQL or external languages like Java, C, or C++.  
ğ–¦¹ Most databases implement nonstandard syntax, e.g., Oracle PL/SQL, SQL Server T-SQL, PostgreSQL PL/pgSQL.  
- Concepts remain applicable despite syntax differences.  

161. Declaring and Invoking SQL Functions and Procedures  
ğ–¦¹ Functions can return values or tables and be used in SQL queries.  
â€¢ Example: [yellow]dept_count[/yellow] function returns the number of instructors in a department.  
â€¢ Table functions return a set of rows like parameterized views.  
ğ–¦¹ Complex user-defined functions can cause performance issues if applied to many tuples.  
ğ–¦¹ Procedures can have [pink]IN[/pink] and [pink]OUT[/pink] parameters.  
â€¢ [pink]IN[/pink]: input values; [pink]OUT[/pink]: values returned by the procedure.  
ğ–¦¹ Procedures can be called from SQL, embedded SQL, or dynamic SQL (e.g., JDBC).  
ğ–¦¹ SQL supports multiple procedures/functions with the same name if argument number or types differ.  

162. Language Constructs for Procedures and Functions  
ğ–¦¹ SQL supports general-purpose programming constructs in procedures/functions.  
ğ–¦¹ Variables declared using [pink]declare[/pink], assigned with [pink]set[/pink].  
ğ–¦¹ Compound statements: [pink]begin[/pink] â€¦ [pink]end[/pink]; [pink]begin atomic[/pink] â€¦ [pink]end[/pink] ensures single transaction.  
ğ–¦¹ Loops: [pink]while[/pink], [pink]repeat[/pink], [pink]for[/pink] over query results.  
â€¢ [pink]Leave[/pink] exits loop; [pink]iterate[/pink] moves to next tuple.  
ğ–¦¹ Conditional statements: [pink]if-then-elseif-else[/pink], [pink]case[/pink] statements.  
ğ–¦¹ Exception handling:  
â€¢ [pink]Declare[/pink] conditions and handlers.  
â€¢ [pink]signal[/pink] raises exceptions; handlers specify actions ([pink]exit[/pink] or [pink]continue[/pink]).  
â€¢ Predefined conditions: [pink]sqlexception[/pink], [pink]sqlwarning[/pink], [pink]not found[/pink].  
ğ–¦¹ Example: [yellow]registerStudent[/yellow] function registers a student in a course section, checks capacity, returns success/error codes.  

163. External Language Routines  
ğ–¦¹ SQL procedural features vary across databases; syntax is not standardized.  
ğ–¦¹ Alternative: define procedures/functions in an external language (Java, C#, C, C++).  
â€¢ More efficient; can perform computations not possible in SQL.  
ğ–¦¹ Syntax example: [pink]create procedure/function in C with external file path[/pink].  
ğ–¦¹ External routines must handle null values, return values, exceptions.  
â€¢ Extra parameters like [yellow]sqlstate[/yellow], return value indicators may be needed.  
ğ–¦¹ Risks of external routines:  
â€¢ Compiled outside database may corrupt internal structures or bypass access control.  
ğ–¦¹ Execution strategies:  
â€¢ Unsafe languages (C) may require separate process, causing overhead from interprocess communication.  
â€¢ Safe languages (Java, C#) can run in sandbox within database process, reducing overhead.  
ğ–¦¹ Modern databases supporting sandboxed external routines:  
â€¢ Oracle, IBM DB2: Java functions within database process.  
â€¢ SQL Server CLR: C# or VB procedures.  
â€¢ PostgreSQL: functions in Perl, Python, Tcl.  

164. Triggers  
ğ–¦¹ A trigger is a statement executed automatically as a side effect of a database modification.  
ğ–¦¹ To define a trigger:  
â€¢ Specify the event and condition for execution.  
â€¢ Specify the actions to be taken when executed.  
ğ–¦¹ Once entered, the database executes the trigger whenever the event occurs and condition is satisfied.  

165. Need for Triggers  
ğ–¦¹ Triggers implement integrity constraints not possible with standard SQL constraints.  
ğ–¦¹ Useful for alerting humans or starting tasks automatically.  
â€¢ Example: update student total credits when a course is taken.  
â€¢ Example: reorder inventory automatically when it falls below minimum.  
ğ–¦¹ Triggers cannot usually perform external updates; separate processes handle actions outside the database.  
â€¢ Some systems support sending emails from SQL queries or triggers.  

166. Triggers in SQL  
ğ–¦¹ SQL standard defines triggers; most databases have nonstandard syntax.  
ğ–¦¹ Triggers ensure referential integrity using [pink]after insert[/pink], [pink]delete[/pink], or [pink]update[/pink] events.  
â€¢ Transition variables ([yellow]referencing new row/old row[/yellow]) store affected row values.  
â€¢ [pink]when[/pink] clause specifies the condition for trigger execution.  
â€¢ [pink]begin atomic[/pink] â€¦ [pink]end[/pink] groups multiple SQL statements.  
ğ–¦¹ Example: [pink]rollback transaction[/pink] if inserted time slot id is invalid.  
ğ–¦¹ Triggers can execute on updates to specific attributes.  
â€¢ Example: [pink]update[/pink] [yellow]student tot_cred[/yellow] when grade changes from null or 'F' to a passing grade.  
ğ–¦¹ Triggers can be [pink]before[/pink] or [pink]after[/pink] events.  
â€¢ [pink]Before[/pink] triggers can correct or prevent invalid actions.  
â€¢ Example: replace blank grades with null using [pink]set[/pink] statement.  
ğ–¦¹ Statement-level triggers operate once per SQL statement; row-level triggers operate for each affected row.  
ğ–¦¹ Triggers can be enabled, disabled, or dropped.  

167. Inventory Replenishment Example  
ğ–¦¹ Relations: [yellow]inventory(item, level)[/yellow], [yellow]minlevel(item, level)[/yellow], [yellow]reorder(item, amount)[/yellow], [yellow]orders(item, amount)[/yellow].  
ğ–¦¹ Trigger placed to reorder when inventory falls below minimum level.  
â€¢ Ensures order placed only when level falls from above minimum to below minimum.  
ğ–¦¹ SQL-based systems widely use triggers; standard syntax varies across systems (pre-SQL:1999 triggers were not standard).  

168. When Not to Use Triggers  
ğ–¦¹ Some tasks are better handled by other techniques than triggers.  
â€¢ Example: [pink]on delete cascade[/pink] feature is simpler with foreign-key cascade than with triggers.  
ğ–¦¹ Materialized views can be maintained automatically by the database, reducing need for triggers.  
ğ–¦¹ Triggers can be used for database replication, but modern systems provide built-in replication features.  

169. Special Considerations for Triggers  
ğ–¦¹ Triggers may cause unintended execution during data loading or replication.  
â€¢ Can be disabled during backup load or use [yellow]"not for replication"[/yellow] options.  
ğ–¦¹ Triggers must be written carefully to avoid runtime errors and infinite chains of triggers.  
â€¢ Some databases limit chain length (e.g., 16 or 32 triggers) or flag errors when a trigger references its own table.  
ğ–¦¹ Triggers are useful but should be avoided when alternatives exist.  

170. Recursive Queries  
ğ–¦¹ Recursive queries find all direct and indirect prerequisites for a course.  
â€¢ Example: CS-347 has CS-319 as direct prerequisite; CS-315 and CS-101 are prerequisites for CS-319; CS-190 is prerequisite for CS-315; CS-101 already listed.  
ğ–¦¹ Transitive closure contains all pairs (course, prerequisite) for direct or indirect prerequisites.  
â€¢ Useful for hierarchies like organizational units or machine parts.  

171. Transitive Closure Using Iteration  
ğ–¦¹ Iterative approach finds direct prerequisites, then prerequisites of those courses, until no new courses are added.  
ğ–¦¹ Function [yellow]findAllPrereqs(cid)[/yellow] computes all prerequisites for a given course.  
â€¢ Uses three temporary tables: [yellow]c_prereq (results)[/yellow], [yellow]new_c_prereq (previous iteration)[/yellow], [yellow]temp (intermediate storage)[/yellow].  
â€¢ Inserts direct prerequisites into [yellow]new_c_prereq[/yellow], then repeats:  
  - Add [yellow]new_c_prereq[/yellow] to [yellow]c_prereq[/yellow].  
  - Find prerequisites of courses in [yellow]new_c_prereq[/yellow] not already in [yellow]c_prereq[/yellow] and store in [yellow]temp[/yellow].  
  - Replace [yellow]new_c_prereq[/yellow] with [yellow]temp[/yellow] and clear [yellow]temp[/yellow].  
â€¢ Loop ends when [yellow]new_c_prereq[/yellow] is empty.  
ğ–¦¹ The [pink]except[/pink] clause prevents duplicates and handles cycles in prerequisites.  
â€¢ Applicable to other recursive relationships like flight reachability.  

172. Recursion in SQL  
ğ–¦¹ Recursive views define direct and indirect prerequisites in a single query.  
â€¢ Example: [pink]with recursive[/pink] [yellow]rec_prereq(course_id, prereq_id) as (base query union recursive query)[/yellow] [pink]select[/pink] [yellow]*[/yellow] [pink]from[/pink] [yellow]rec_prereq[/yellow].  
ğ–¦¹ Base query selects direct prerequisites; recursive query joins [yellow]rec_prereq[/yellow] with [yellow]prereq[/yellow] to find indirect prerequisites.  
ğ–¦¹ Recursive view iteratively adds tuples until a fixed point is reached (no new tuples).  
ğ–¦¹ To find prerequisites of a specific course, add a [pink]where[/pink] clause to filter [yellow]course_id[/yellow].  
ğ–¦¹ Database systems may optimize execution without computing full [yellow]rec_prereq[/yellow] first.  

173. Restrictions on Recursive Queries  
ğ–¦¹ Recursive queries must be monotonic.  
â€¢ Result on a larger view instance must include all results from a smaller instance.  
ğ–¦¹ Nonmonotonic constructs are not allowed:  
â€¢ Aggregation on recursive view.  
â€¢ [pink]not exists[/pink] on a subquery using recursive view.  
â€¢ Set difference ([pink]except[/pink]) with right-hand side using recursive view.  
ğ–¦¹ Nonmonotonic queries make the meaning of the view hard to define; SQL requires monotonic queries.  

174. Additional Notes on Recursive Queries  
ğ–¦¹ SQL supports permanent recursively defined views using [pink]create recursive view[/pink].  
ğ–¦¹ Some databases use alternative syntax for recursion (e.g., Oracle [pink]start with[/pink] / [pink]connect by prior[/pink] for hierarchical queries).  
â€¢ Oracle 12.c supports standard syntax with [pink]union all[/pink] and [pink]recursive[/pink] keyword omitted.  

175. Advanced Aggregation Features  
ğ–¦¹ SQL aggregation is powerful but basic features can be inefficient for some tasks.  
ğ–¦¹ Advanced features help handle ranking, windowing, pivoting, rollup, and cube operations efficiently.  

176. Ranking  
ğ–¦¹ Ranking finds the position of a value within a set, e.g., student GPA ranks.  
â€¢ [pink]rank()[/pink] assigns the same rank to equal values and skips ranks for ties.  
â€¢ [pink]dense_rank()[/pink] assigns consecutive ranks without gaps.  
â€¢ [pink]nulls first/last[/pink] controls how nulls are ranked.  
â€¢ SQL example: [pink]select[/pink] [yellow]ID,[/yellow] [pink]rank()[/pink] [yellow]over (order by GPA desc)[/yellow] [pink]as[/pink] [yellow]s_rank[/yellow] [pink]from[/pink] [yellow]student_grades[/yellow] [pink]order by[/pink] [yellow]s_rank[/yellow];  
ğ–¦¹ Ranking can be done within partitions (e.g., department):  
â€¢ Use [pink]partition by[/pink]: [pink]select[/pink] [yellow]ID, dept_name,[/yellow] [pink]rank()[/pink] [yellow]over (partition by dept_name order by GPA desc)[/yellow] [pink]as[/pink] [yellow]dept_rank[/yellow] [pink]from[/pink] [yellow]dept_grades[/yellow] [pink]order by[/pink] [yellow]dept_name, dept_rank[/yellow];  
ğ–¦¹ Top n ranking can be obtained using a containing query with [pink]where[/pink] clause.  
ğ–¦¹ Nonstandard SQL syntax exists for top n queries but may break ties arbitrarily.  
ğ–¦¹ Other ranking functions:  
â€¢ [pink]percent_rank[/pink] = [yellow](r-1)/(n-1)[/yellow]  
â€¢ [pink]cume_dist[/pink] = [yellow]p/n[/yellow] (cumulative distribution)  
â€¢ [pink]row_number[/pink] = unique number for each row  
ğ–¦¹ [pink]ntile(n)[/pink] divides tuples into n equal buckets.  

177. Windowing  
ğ–¦¹ Window queries compute aggregates over ranges of tuples.  
â€¢ Useful for trend analysis and moving averages.  
ğ–¦¹ Example with fixed range:  
â€¢ [pink]select[/pink] [yellow]year, avg(num_credits)[/yellow] [pink]over (order by year rows 3 preceding)[/pink] [pink]as[/pink] [yellow]avg_total_credits[/yellow] [pink]from[/pink] [yellow]tot_credits[/yellow];  
ğ–¦¹ Example with all prior years:  
â€¢ [pink]select[/pink] [yellow]year, avg(num_credits)[/yellow] [pink]over (order by year rows unbounded preceding)[/pink] [pink]as[/pink] [yellow]avg_total_credits[/yellow] [pink]from[/pink] [yellow]tot_credits[/yellow];  
ğ–¦¹ Windows can start and end before or after current row:  
â€¢ [yellow]rows between 3 preceding and 2 following[/yellow]  
ğ–¦¹ Partitioning allows separate windows for each group:  
â€¢ [pink]select[/pink] [yellow]dept_name, year, avg(num_credits)[/yellow] [pink]over (partition by dept_name order by year rows between 3 preceding and current row)[/pink] [pink]as[/pink] [yellow]avg_total_credits[/yellow] [pink]from[/pink] [yellow]tot_credits_dept[/yellow];  
ğ–¦¹ [pink]range[/pink] keyword covers all tuples with a specific sort attribute value.  

178. Pivoting  
ğ–¦¹ Pivoting transforms rows into columns (cross-tabulation).  
â€¢ Example: [yellow]sales(item_name, color, clothes_size, quantity)[/yellow] â†’ pivot on color.  
ğ–¦¹ SQL pivot example:  
â€¢ [pink]select[/pink] [yellow]*[/yellow] [pink]from[/pink] [yellow]sales[/yellow] [pink]pivot[/pink] [yellow](sum(quantity) for color in ('dark','pastel','white'))[/yellow];  
ğ–¦¹ Pivot attributes are renamed to values of another attribute.  
ğ–¦¹ Aggregate functions handle multiple tuples per cell (e.g., [pink]sum[/pink]).  

179. Rollup and Cube  
ğ–¦¹ Rollup generates hierarchical aggregates for multiple groupings.  
â€¢ Example: [pink]group by[/pink] [yellow]rollup(item_name, color)[/yellow] â†’ groupings: (item_name,color), (item_name), ()  
â€¢ Nulls represent missing attributes in higher-level groupings.  
ğ–¦¹ Cube generates all combinations of groupings.  
â€¢ Example: [pink]group by[/pink] [yellow]cube(item_name,color,clothes_size)[/yellow] â†’ 8 groupings including empty.  
ğ–¦¹ Multiple rollups and cubes can be combined.  
ğ–¦¹ For custom groupings, use grouping sets:  
â€¢ [pink]group by[/pink] [yellow]grouping_sets((color,clothes_size),(clothes_size,item_name))[/yellow];  
ğ–¦¹ Distinguish rollup/cube-generated nulls using [pink]grouping()[/pink] function:  
â€¢ [pink]case[/pink] [pink]when[/pink] [pink]grouping[/pink][yellow](item_name)=1[/yellow] [pink]then[/pink] [yellow]'all'[/yellow] [pink]else[/pink] [yellow]item_name[/yellow] [pink]end[/pink]  
ğ–¦¹ [pink]coalesce[/pink] cannot differentiate rollup/cube nulls from normal nulls.

180. Overview of the Design Process
ğ–¦¹ Creating a database application involves designing the database schema, programs that access/update data, and a security scheme.
ğ–¦¹ User needs are central to the design process.
ğ–¦¹ Focus here is on designing the database schema; other design tasks are briefly outlined.

181. Design Phases
ğ–¦¹ Small applications may allow direct design of relations, attributes, and constraints.
ğ–¦¹ Real-world applications are complex; no one person may understand all data needs.
ğ–¦¹ Database designer must interact with users, represent needs in a high-level model, and translate to lower-level design.
â€¢ High-level data model provides a conceptual framework to specify data requirements and structure.
ğ–¦¹ Initial phase: characterize fully the data needs of users.
â€¢ Interact extensively with domain experts.
â€¢ Outcome: specification of user requirements, usually textual.
ğ–¦¹ Next: choose a data model and translate requirements into a conceptual schema.
â€¢ Conceptual schema gives a detailed overview of the enterprise.
â€¢ E-R model represents entities, attributes, relationships, and constraints.
â€¢ Usually results in an entity-relationship diagram (ERD).
ğ–¦¹ Review schema to confirm all data requirements are satisfied and remove redundancy.
ğ–¦¹ Conceptual schema also indicates functional requirements, such as operations on data (update, search, delete).
ğ–¦¹ Moving from abstract model to implementation:
â€¢ Logical-design phase: map conceptual schema to implementation data model (usually relational).
â€¢ Physical-design phase: specify physical features like file organization and indexes.
ğ–¦¹ Physical schema can change easily; logical schema changes are harder and affect queries and updates.

182. Design Alternatives
ğ–¦¹ Database design requires deciding how to represent entities like people, places, products.
â€¢ Entity: distinctly identifiable item (e.g., instructors, students, courses, course offerings/sections).
ğ–¦¹ Entities are related in various ways (e.g., student takes course, instructor teaches course).
ğ–¦¹ Avoid two major pitfalls:
1. Redundancy:
â€¢ Repeating information unnecessarily (e.g., storing course title with each section).
- Can lead to inconsistencies when updates occur.
2. Incompleteness:
â€¢ Difficult or impossible to model certain aspects if design lacks entities (e.g., course entity missing).
- Workarounds like nulls are unattractive and may conflict with primary key constraints.
ğ–¦¹ Multiple good designs exist; choices affect modeling quality.
â€¢ Example: representing a sale as a relationship or an entity.

183. The Entity-Relationship Model
ğ–¦¹ E-R model helps specify an enterprise schema representing the logical structure of a database.
ğ–¦¹ Useful for mapping real-world enterprises to a conceptual schema.
ğ–¦¹ Three basic concepts: entity sets, relationship sets, attributes.
ğ–¦¹ E-R diagram provides a clear graphical representation of the schema.
ğ–¦¹ Tools exist for creating E-R diagrams.
IMG_URL er-diagram.png

184. Entity Sets
ğ–¦¹ Entity: distinguishable real-world object (e.g., person, course).
ğ–¦¹ Each entity has properties; some values uniquely identify it (e.g., person id, course id).
ğ–¦¹ Entity set: collection of entities of the same type sharing attributes (e.g., all instructors, all students).
ğ–¦¹ Extension: actual collection of entities in an entity set.
ğ–¦¹ Entity sets may overlap (e.g., a person may be both student and instructor).
ğ–¦¹ Attributes describe each entity; values can differ per entity (e.g., ID, name, dept name, salary).
ğ–¦¹ Simple attributes considered here; composite/multivalued discussed later.
ğ–¦¹ Primary key attribute uniquely identifies each entity (underlined in ERD).
ğ–¦¹ Entity sets represented in ERD as rectangles with entity name and attributes.
IMG_URL entity-set.png

185. Relationship Sets
ğ–¦¹ Relationship: association among entities (e.g., advisor associates instructor Katz with student Shankar).
ğ–¦¹ Relationship set: collection of relationships of the same type.
IMG_URL relationship-set.png
ğ–¦¹ Relationship instance: specific association between named entities.
ğ–¦¹ Represented in ERD as diamonds linked to entity sets (rectangles).
ğ–¦¹ Relationships may involve more than two entity sets.
ğ–¦¹ Participation: entity sets involved in a relationship set.
ğ–¦¹ Role: function an entity plays in a relationship; explicit role names needed in recursive relationships.
â€¢ Example: prereq relationship between courses C1 and C2.
IMG_URL role-indicators.png
ğ–¦¹ Relationship sets can have descriptive attributes (e.g., grade in takes relationship).
â€¢ Attributes represented by undivided rectangles linked with dashed lines to diamonds.
IMG_URL er-with-attribute.png
ğ–¦¹ Complex ER designs may require multiple diagrams; entity sets may repeat without attributes to avoid redundancy.
ğ–¦¹ Nonbinary relationship sets exist; degree = number of entity sets involved.
â€¢ Example: ternary relationship proj guide among instructor, student, and project.
â€¢ Instance indicates which student is guided by which instructor on which project.

186. Complex Attributes
ğ–¦¹ Each attribute has a set of permitted values called the domain or value set.
â€¢ Example: course id domain = all text strings of certain length; semester domain = {Fall, Winter, Spring, Summer}.
ğ–¦¹ Attributes can be classified into different types.
IMG_URL complex-attributes.png

187. Simple and Composite Attributes
ğ–¦¹ Simple attributes are indivisible and not divided into subparts.
ğ–¦¹ Composite attributes can be divided into subparts (component attributes).
â€¢ Example: name = first name + middle initial + last name.
â€¢ Example: address = street + city + state + postal code; street can be further divided into street number, street name, apartment number.
- Composite attributes help group related attributes and make modeling cleaner.

188. Single-valued and Multivalued Attributes
ğ–¦¹ Single-valued attributes have only one value per entity.
â€¢ Example: student ID.
ğ–¦¹ Multivalued attributes have multiple values for an entity.
â€¢ Example: phone number for instructors; dependent names listing all dependents.

189. Derived Attributes
ğ–¦¹ Derived attributes can be computed from other attributes or entities.
â€¢ Example: students advised = count of students linked to an instructor.
â€¢ Example: age = current date - date of birth.
- Derived attributes are not stored; base attributes are stored.
IMG_URL derived-complex.png

190. Null Values
ğ–¦¹ An attribute can take a null value when an entity has no value for it.
â€¢ Null may indicate "not applicable", "missing", or "unknown".
â€¢ Example: middle initial null if person has no middle name.
â€¢ Example: apartment number null if not applicable, missing, or unknown.

191. Mapping Cardinalities
ğ–¦¹ Mapping cardinalities describe the number of entities associated via a relationship set.
â€¢ Most useful for binary relationship sets but can apply to relationships with more than two entity sets.

192. Types of Mapping Cardinalities
ğ–¦¹ One-to-one: Each entity in A associates with at most one entity in B, and vice versa.
ğ–¦¹ One-to-many: Each entity in A associates with zero or more entities in B; each entity in B associates with at most one entity in A.
IMG_URL one-to-many.png
ğ–¦¹ Many-to-one: Each entity in A associates with at most one entity in B; each entity in B associates with zero or more entities in A.
ğ–¦¹ Many-to-many: Each entity in A associates with zero or more entities in B; each entity in B associates with zero or more entities in A.
IMG_URL one-to-many-many.png
- The choice depends on the real-world scenario being modeled.
â€¢ Example: Advisor relationship set:
- Many-to-many if students have multiple instructors.
- One-to-many if each student has only one instructor, and instructors advise multiple students.

193. Representation in E-R Diagrams
ğ–¦¹ One-to-one: Draw directed lines from the relationship set to both entity sets.
ğ–¦¹ One-to-many: Draw directed line to the "one" side; undirected line to the "many" side.
ğ–¦¹ Many-to-one: Draw directed line to the "one" side; undirected line to the "many" side.
ğ–¦¹ Many-to-many: Draw undirected lines to both entity sets.
IMG_URL one-to-many-to-many-to-one.png

194. Participation Constraints
ğ–¦¹ Total participation: Every entity in an entity set must participate in at least one relationship.
ğ–¦¹ Partial participation: Some entities may not participate in any relationship.
â€¢ Example: Student must have an advisor (total participation); an instructor may have zero or more students (partial participation).
ğ–¦¹ Indicated using double lines for total participation in E-R diagrams.
IMG_URL strong-participation.png

195. Cardinality Limits
ğ–¦¹ Lines may have minimum and maximum cardinalities in the form l..h.
â€¢ Minimum 1 indicates total participation.
â€¢ Maximum 1 indicates at most one relationship; maximum âˆ— indicates no limit.
â€¢ Example: advisor-student line 1..1 = each student has exactly one advisor; advisor-instructor line 0..* = instructor can have zero or more students.
ğ–¦¹ Misinterpretation caution: 0..* does not mean many-to-one; it allows multiple relationships on that side.
ğ–¦¹ One-to-one occurs if both edges have maximum value 1; 1..* on the left edge implies instructor must advise at least one student.
IMG_URL cardinality.png

196. Nonbinary Relationship Sets
ğ–¦¹ Some many-to-one relationships can be specified.
â€¢ Example: In a project, a student can have at most one instructor as a guide.
ğ–¦¹ Only one arrow out of a nonbinary relationship set is allowed to avoid ambiguity.

197. Primary Key
ğ–¦¹ A primary key uniquely distinguishes entities within an entity set and relationships within a relationship set.

198. Entity Sets
ğ–¦¹ Individual entities are conceptually distinct and must be uniquely identified using their attributes.
ğ–¦¹ No two entities can have identical values for all attributes.
ğ–¦¹ Keys for entity sets include superkey, candidate key, and primary key, similar to relation schemas.
ğ–¦¹ Keys also help to identify relationships uniquely.

199. Relationship Sets
ğ–¦¹ To distinguish relationships in a relationship set R involving entity sets E1, E2, â€¦, En, use the primary keys of the participating entity sets.
â€¢ If R has no attributes: primary-key(E1) âˆª primary-key(E2) âˆª â€¦ âˆª primary-key(En) forms a superkey.
â€¢ If R has attributes a1, a2, â€¦, am: primary-key(E1) âˆª â€¦ âˆª primary-key(En) âˆª {a1, â€¦, am} forms a superkey.
ğ–¦¹ If primary key attribute names are not unique, rename using entity set name or role name.
ğ–¦¹ For binary relationships:
â€¢ Many-to-many: union of primary keys from both sides forms primary key.
â€¢ One-to-many or many-to-one: primary key of the "many" side is used.
â€¢ One-to-one: primary key of either entity set can be used.
ğ–¦¹ For nonbinary relationships: only one arrow out is allowed to avoid ambiguity.
â€¢ Primary key = union of primary keys of entity sets without incoming arrow.
â€¢ If multiple-arrow situations exist, convert nonbinary relationship to entity set or use functional dependencies.

200. Weak Entity Sets
ğ–¦¹ Weak entity sets depend on another entity set called the identifying entity set.
ğ–¦¹ A weak entity cannot have a primary key alone; use the primary key of the identifying entity set plus discriminator attributes.
ğ–¦¹ Every weak entity must be associated with an identifying entity (existence dependent).
ğ–¦¹ The identifying relationship is many-to-one from the weak entity set to the identifying entity set and has total participation.
ğ–¦¹ Example: section entity is weak, depends on course entity.
â€¢ Primary key of section = {course id, sec id, year, semester}.
ğ–¦¹ In E-R diagrams:
â€¢ Weak entity = double rectangle, discriminator underlined with dashed line.
â€¢ Identifying relationship = double diamond.
â€¢ Total participation = double lines.
â€¢ Arrow points from weak entity to identifying entity.
ğ–¦¹ Weak entities can participate in other relationships and can have multiple identifying entity sets.
â€¢ Primary key in that case = union of primary keys of identifying entity sets + discriminator.
IMG_URL weak-entity.png

201. Removing Redundant Attributes in Entity Sets
ğ–¦¹ In E-R design, after selecting entity sets, choose attributes that capture required values.
ğ–¦¹ Redundant attributes occur when attributes in entity sets are repeated in relationship sets.
ğ–¦¹ Example: instructor and department
â€¢ instructor attributes: ID (primary key), name, dept name, salary
â€¢ department attributes: dept name (primary key), building, budget
â€¢ Relationship: inst dept relates instructor to department
- dept name is redundant in instructor and should be removed.
ğ–¦¹ Removing redundant attributes avoids incorrect assumptions about relationships (e.g., one instructor having only one department).
ğ–¦¹ student entity set also does not need dept name, since relationship student dept exists.
ğ–¦¹ Example: section and time slot
â€¢ section attributes: course id, sec id, semester, year, building, room number, time slot id; primary key = (course id, sec id, year, semester)
â€¢ time slot attributes: time slot id (primary key), multivalued composite attribute {(day, start time, end time)}
â€¢ Relationship: sec time slot
- time slot id is redundant in section and should be removed.
ğ–¦¹ Example: section and classroom
â€¢ classroom attributes: building, room number, capacity; primary key = (building, room number)
â€¢ Relationship: sec class
- {building, room number} are redundant in section and should be removed.
ğ–¦¹ A good E-R design has no redundant attributes.

202. University Example: Entity Sets and Attributes
ğ–¦¹ classroom: building, room number, capacity
ğ–¦¹ department: dept name, building, budget
ğ–¦¹ course: course id, title, credits
ğ–¦¹ instructor: ID, name, salary
ğ–¦¹ section: course id, sec id, semester, year
ğ–¦¹ student: ID, name, tot cred
ğ–¦¹ time slot: time slot id, {(day, start time, end time)}

203. University Example: Relationship Sets
ğ–¦¹ inst dept: relates instructors to departments
ğ–¦¹ stud dept: relates students to departments
ğ–¦¹ teaches: relates instructors to sections
ğ–¦¹ takes: relates students to sections, with descriptive attribute grade
ğ–¦¹ course dept: relates courses to departments
ğ–¦¹ sec course: relates sections to courses
ğ–¦¹ sec class: relates sections to classrooms
ğ–¦¹ sec time slot: relates sections to time slots
ğ–¦¹ advisor: relates students to instructors
ğ–¦¹ prereq: relates courses to prerequisite courses
ğ–¦¹ No entity set has attributes made redundant by relationships.

204. E-R Diagram for University
ğ–¦¹ Each instructor must have exactly one department (total participation): double line from instructor to inst dept; arrow to department.
ğ–¦¹ Every course must be in some department: double line from course to course dept; arrow to department.
ğ–¦¹ Every student must be majoring in a department: double line from student to stud dept; arrow to department.
ğ–¦¹ Relationship takes has descriptive attribute grade.
ğ–¦¹ Each student has at most one advisor.
ğ–¦¹ section is a weak entity set, with sec id, semester, year as discriminator; sec course is identifying relationship linking section to course.
IMG_URL er-university.png

205. Reducing E-R Diagrams to Relational Schemas
ğ–¦¹ E-R and relational models are abstract representations of real-world enterprises.
ğ–¦¹ Each entity set and relationship set in E-R design corresponds to a unique relation schema.
ğ–¦¹ Constraints in E-R design map to constraints in relational schemas.

206. Representation of Strong Entity Sets
ğ–¦¹ A strong entity set with simple attributes a1, a2, â€¦, an is represented as a relation schema with n attributes.
ğ–¦¹ The primary key of the entity set becomes the primary key of the relation schema.
ğ–¦¹ Example: student(ID, name, tot_cred); ID is primary key.
ğ–¦¹ Instructor, student, and course schemas differ from previous chapters since dept name is excluded.

207. Representation of Strong Entity Sets with Complex Attributes
ğ–¦¹ Composite attributes are split into component attributes; no separate attribute for the composite itself.
â€¢ Example: instructor name â†’ first name, middle initial, last name; address â†’ street number, street name, apt number, city, state, postal code.
ğ–¦¹ Multivalued attributes require a separate relation schema.
ğ–¦¹ Derived attributes are not represented directly but can be implemented as functions or methods.
ğ–¦¹ Example: instructor(ID, first name, middle initial, last name, street number, street name, apt number, city, state, postal code, date of birth).
ğ–¦¹ Multivalued attribute example: phone number
â€¢ instructor phone(ID, phone number)
- Primary key = (ID, phone number); ID references instructor as foreign key.
ğ–¦¹ If entity set has only primary key B and multivalued attribute M, relation schema contains B and attribute A corresponding to M.
â€¢ Example: time slot(time slot id, day, start time, end time)
- end time may be omitted from primary key for uniqueness.

208. Representation of Weak Entity Sets
ğ–¦¹ Weak entity set A with attributes a1, a2, â€¦, am depends on strong entity set B with primary key b1, b2, â€¦, bn.
ğ–¦¹ Relation schema for A: {a1, a2, â€¦, am} âˆª {b1, b2, â€¦, bn}.
ğ–¦¹ Primary key = combination of discriminator of A and primary key of B.
ğ–¦¹ Foreign key: attributes b1, b2, â€¦, bn reference B's primary key.
ğ–¦¹ Example: section(course id, sec id, semester, year); course id references course.

209. Representation of Relationship Sets
ğ–¦¹ Relationship set R with entity primary keys {a1, â€¦, am} and descriptive attributes {b1, â€¦, bn} is represented by schema {a1, â€¦, am} âˆª {b1, â€¦, bn}.
ğ–¦¹ Primary key selection follows binary relationship rules.
ğ–¦¹ Foreign-key constraints: attributes from entity sets reference their respective schemas.
ğ–¦¹ Example: advisor relationship between instructor(ID) and student(ID)
â€¢ Schema: advisor(s ID, i ID)
â€¢ Primary key = s ID; foreign keys: s ID â†’ student, i ID â†’ instructor
ğ–¦¹ Role indicators used as attribute names when entity sets repeat, e.g., prereq(course id, prereq id).
ğ–¦¹ Many-to-one relationships: primary key from one related entity set used.

210. Redundancy of Schemas
ğ–¦¹ Relationship sets linking weak entity sets to strong entity sets often produce redundant schemas.
ğ–¦¹ Example: sec course schema duplicates section schema attributes; can be eliminated.

211. Combination of Schemas
ğ–¦¹ Many-to-one relationship AB with total participation of A allows combining A and AB schemas.
â€¢ Example: inst dept â†’ combine with instructor â†’ instructor(ID, name, dept name, salary)
â€¢ stud dept â†’ combine with student â†’ student(ID, name, dept name, tot cred)
â€¢ course dept â†’ combine with course â†’ course(course id, title, dept name, credits)
â€¢ sec class â†’ combine with section â†’ section(course id, sec id, semester, year, building, room number)
â€¢ sec time slot â†’ combine with section â†’ section(course id, sec id, semester, year, building, room number, time slot id)
ğ–¦¹ One-to-one relationships can combine with either entity set.
ğ–¦¹ Partial participation uses nulls for missing attributes.
ğ–¦¹ Foreign-key constraints referencing the merged entity set are enforced implicitly; others remain in combined schema.

212. Extended E-R Features  
ğ–¦¹ Some database aspects are better expressed using extended E-R features: specialization, generalization, higher- and lower-level entity sets, attribute inheritance, and aggregation.  
ğ–¦¹ Example: A university database defines a person entity set with attributes ID, name, street, and city.

213. Specialization  
ğ–¦¹ Specialization designates subgroupings within an entity set based on distinctive features.  
â€¢ Example: person can be specialized into employee and student.  
- Employee may have salary, student may have tot cred.  
ğ–¦¹ Specialization can be applied repeatedly.  
â€¢ Example: student can be specialized into graduate (office number) and undergraduate (residential college).  
â€¢ Example: employee can be specialized into instructor (rank) and secretary (hours per week).  
ğ–¦¹ An entity may belong to multiple specializations.  
â€¢ Example: a temporary employee who is a secretary.  
ğ–¦¹ Depicted in E-R diagram using hollow arrow-head (ISA relationship).  
ğ–¦¹ Specialization types:  
â€¢ Overlapping: entity may belong to multiple specialized sets.  
â€¢ Disjoint: entity may belong to at most one specialized set.  

214. Generalization  
ğ–¦¹ Generalization synthesizes multiple lower-level entity sets into a higher-level entity set based on common features.  
â€¢ Example: instructor and secretary share common attributes (ID, name, salary) â†’ generalized into employee.  
ğ–¦¹ Generalization is the inverse of specialization.  
ğ–¦¹ Higher-level entity set is called superclass; lower-level sets are subclasses.  
ğ–¦¹ Emphasizes similarities among lower-level sets and reduces attribute repetition.
IMG_URL spec-gen.png

215. Attribute Inheritance  
ğ–¦¹ Lower-level entity sets inherit attributes of higher-level sets.  
â€¢ Example: student and employee inherit ID, name, street, city from person.  
â€¢ Example: instructor and secretary inherit attributes from employee and person.  
ğ–¦¹ Lower-level entity sets also inherit participation in relationships of higher-level sets.  
â€¢ Example: if person participates in person dept with department, all subclasses also participate.  
ğ–¦¹ Outcome:  
â€¢ Higher-level set has common attributes and relationships.  
â€¢ Lower-level sets have distinctive features.  
ğ–¦¹ Single inheritance: entity set is a lower-level in only one ISA relationship.  
ğ–¦¹ Multiple inheritance: entity set is a lower-level in multiple ISA relationships â†’ forms a lattice.
IMG_URL spec-gen.png

216. Constraints on Specializations  
ğ–¦¹ Specializations may have disjointness and completeness constraints.  
â€¢ Total specialization: each higher-level entity belongs to at least one lower-level set.  
â€¢ Partial specialization: some higher-level entities may not belong to any lower-level set.  
ğ–¦¹ Partial specialization is default.  
ğ–¦¹ Total specialization represented in E-R diagram using keyword â€œtotalâ€ and dashed line to hollow arrowhead.  
ğ–¦¹ Constraints affect insertions/deletions:  
â€¢ In total specialization, inserting an entity in higher-level set requires insertion in a lower-level set.  
â€¢ Deleting from higher-level set requires deletion from all associated lower-level sets.  

217. Aggregation  
ğ–¦¹ Aggregation treats relationships as higher-level entities to express relationships among relationships.  
â€¢ Example: proj guide (instructor, student, project) â†’ evaluation entity related via eval for relationship.  
IMG_URL wo-aggregation.png
ğ–¦¹ Avoid combining proj guide and eval for into single relationship due to possible missing evaluations.  
ğ–¦¹ Aggregation allows modeling eval for as a relationship between proj guide (as higher-level entity) and evaluation.
IMG_URL w-aggregation.png

218. Reduction to Relation Schemas - Generalization  
ğ–¦¹ Method 1: Create schema for higher-level set and each lower-level set.  
â€¢ Include lower-level attributes plus primary key attributes of higher-level set.  
â€¢ Create foreign-key constraints from lower-level sets to higher-level set.  
â€¢ Example:  
person (ID, name, street, city)  
employee (ID, salary)  
student (ID, tot cred)  
ğ–¦¹ Method 2: If generalization is disjoint and complete, do not create schema for higher-level set.  
â€¢ Include higher-level attributes in each lower-level schema.  
â€¢ Example:  
employee (ID, name, street, city, salary)  
student (ID, name, street, city, tot cred)  
ğ–¦¹ Method 2 drawbacks:  
â€¢ Foreign-key constraints on higher-level set become difficult.  
â€¢ Overlapping generalizations may store duplicate values.  
â€¢ Incomplete generalization requires extra higher-level schema.

219. Reduction to Relation Schemas - Aggregation  
ğ–¦¹ Create schema for relationship set involving aggregation.  
â€¢ Include primary key attributes from aggregated relationship and related entity sets.  
â€¢ Include any descriptive attributes.  
ğ–¦¹ Treat aggregation as any other entity set.  
ğ–¦¹ Primary key of aggregation is primary key of defining relationship set.  
ğ–¦¹ No separate relation is required; use relation created from defining relationship.

220. Entity-Relationship Design Issues
ğ–¦¹ Entity sets and relationship sets are not precisely defined.
ğ–¦¹ Multiple ways exist to define entities and relationships.
IMG_URL erroneous.png

221. Common Mistakes in E-R Diagrams
ğ–¦¹ Using primary key of one entity as an attribute in another entity instead of a relationship.
â€¢ Example: dept_name as an attribute of student is incorrect; use stud_dept relationship instead.
- Avoids duplication and keeps relationships explicit.
ğ–¦¹ Using primary-key attributes of related entities as attributes of the relationship set.
â€¢ Example: ID of student and instructor should not be attributes of advisor relationship.
ğ–¦¹ Using single-valued attributes in relationships requiring multivalued attributes.
â€¢ Example: Adding assignment and marks to takes relationship only allows one assignment per student-section pair.
- Correct alternatives: model assignment as weak entity with marks relationship or use multivalued composite attribute {assignment_marks} in takes.
ğ–¦¹ Break large E-R diagrams into pieces; show attributes of entity set only in first occurrence.
IMG_URL correct-one.png

222. Use of Entity Sets versus Attributes
ğ–¦¹ Consider instructor with phone_number attribute.
ğ–¦¹ Phone can be modeled as:
â€¢ Attribute phone_number of instructor (one phone per instructor).
â€¢ Entity set phone with attributes phone_number and location.
â€¢ Relationship inst_phone between instructor and phone.
ğ–¦¹ Treating phone as entity allows multiple phones and extra information (type, location, shared users).
ğ–¦¹ Attribute like name should remain an attribute, not an entity.
ğ–¦¹ Decision depends on real-world semantics.
IMG_URL entity-sets-vs-attributes.png

223. Use of Entity Sets versus Relationship Sets
ğ–¦¹ Decide whether to model as entity set or relationship set.
â€¢ Example: replaces takes relationship by registration entity set with section_reg and student_reg relationships.
ğ–¦¹ Use relationship set to describe actions between entities.
ğ–¦¹ Some attributes may be better expressed as relationships.
IMG_URL entity-sets-vs-relationship-sets.png

224. Binary versus n-ary Relationship Sets
ğ–¦¹ Binary relationships are common; n-ary can often be replaced by multiple binary relationships.
â€¢ Example: ternary parent relationship can be split into mother and father binary relationships.
ğ–¦¹ For abstract n-ary relationship R between A, B, C:
â€¢ Create entity set E representing R.
â€¢ Create binary relationships RA, RB, RC from E to A, B, C.
â€¢ Assign any attributes of R to E.
ğ–¦¹ This increases complexity and storage.
ğ–¦¹ N-ary relationships show participation more clearly.
ğ–¦¹ Some constraints may not translate to binary relationships.
â€¢ Example: proj_guide cannot be split naturally without losing pairing information.
IMG_URL binary-vs-nary.png

225. Alternative Notations for Modeling Data
ğ–¦¹ Diagrammatic representation helps communication between data modelers and domain experts.
ğ–¦¹ Common notations: E-R diagrams and UML class diagrams.
ğ–¦¹ No universal standard; different books and tools use different notations.
ğ–¦¹ Symbols used: entity set, relationship set, weak entity, primary key, cardinality, attributes (simple, composite, multivalued, derived), ISA generalization, total/disjoint participation, role indicator.
IMG_URL symbols-in-er.png

226. Alternative E-R Notations
ğ–¦¹ Attributes can be shown in ovals; primary keys underlined.
ğ–¦¹ Relationship attributes connected to diamonds.
ğ–¦¹ Cardinality: âˆ— and 1, or crowâ€™s-foot notation; total participation with vertical bar, partial with circle.
ğ–¦¹ Generalization represented with triangles.
ğ–¦¹ Chenâ€™s notation uses ovals and diamonds.
ğ–¦¹ IDEF1X standard (1993) uses crowâ€™s-foot, vertical bars for total participation, hollow circles for partial.
ğ–¦¹ Modern notation aligns with UML class diagrams; compact and tool-friendly.
ğ–¦¹ Some tools allow entity view (without relationship attributes) or relational view (with attributes).
IMG_URL alternative-notations.png

227. The Unified Modeling Language (UML)
ğ–¦¹ UML models various software components beyond data: user interactions, functional modules.
ğ–¦¹ Key diagrams:
â€¢ Class diagram: similar to E-R diagrams, shows attributes and methods.
â€¢ Use case diagram: user-system interactions.
â€¢ Activity diagram: flow of tasks.
â€¢ Implementation diagram: system components and interconnections.
ğ–¦¹ UML objects have attributes and methods; access: + public, - private, # protected.
ğ–¦¹ Binary relationships shown as lines; nonbinary relationships via diamond notation.
ğ–¦¹ Cardinality constraints l..h; placement reversed from E-R diagrams.
ğ–¦¹ Supports generalization, disjoint/overlapping, composition (existence dependent) and aggregation (may exist independently).
ğ–¦¹ UML does not support composite/multivalued attributes; derived attributes map to methods.
ğ–¦¹ Interfaces and object-oriented features represented in UML class diagrams.
IMG_URL er-uml.png

228. Other Aspects of Database Design
ğ–¦¹ Database design is not only schema design.
ğ–¦¹ Functional requirements:
â€¢ Define transactions and queries.
â€¢ Plan user interfaces.
â€¢ Implement authorization at database or application level.
ğ–¦¹ Data flow and workflow:
â€¢ Workflows combine tasks and data.
â€¢ Interact with database; track tasks and routing.
â€¢ Helps understand business processes for database design.
ğ–¦¹ Schema evolution:
â€¢ Database needs evolve over time; schema may require updates.
â€¢ Distinguish fundamental constraints (permanent) vs. changeable constraints.
â€¢ Good design anticipates future changes to minimize modifications.
ğ–¦¹ Database design is human-oriented:
â€¢ End users are people.
â€¢ Designers interact with domain experts to understand requirements.

SOURCE: Raghu Ramakrishnan & Johannes Gehrke â€“ "Database Management Systems", McGraw-Hill
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -[12/11/2025]
1. File organization and basic data access
ğ–¦¹ A collection of records is stored in files, and each file consists of pages.
ğ–¦¹ The file layer arranges data to support fast access to needed records.
ğ–¦¹ A file organization is a way of arranging records on disk.
â€¢ Each organization makes some operations efficient and others slower.
ğ–¦¹ Example: Sorting employee records by age makes age-based retrieval fast.
â€¢ But maintaining sorted order is expensive when records change.
ğ–¦¹ If we want to retrieve employees with salary > 5000, we must scan the whole file.
ğ–¦¹ Indexing helps support multiple query types efficiently.
ğ–¦¹ Choosing the right file organization affects performance.
ğ–¦¹ Choosing good indexes is one of the most effective performance improvements.

2. Data on external storage
ğ–¦¹ Database data must persist across program executions, so it is stored on external storage.
ğ–¦¹ Data is stored on disks or tapes and brought into memory when needed.
ğ–¦¹ A page is the unit of data transfer between disk and memory, often 4KB or 8KB.
ğ–¦¹ Page I/O cost dominates the total cost of operations, so DBMS optimizes to reduce it.
ğ–¦¹ Disks allow random page access at a roughly fixed cost.
â€¢ Reading pages sequentially is faster than reading them in random order.
ğ–¦¹ Tapes allow only sequential access and are mainly used for archival storage.
ğ–¦¹ Every record has a unique record id (rid).
â€¢ Using rid, the system can locate the disk page containing the record.

3. Buffer manager and disk space manager
ğ–¦¹ The buffer manager handles moving pages between disk and memory.
â€¢ When a page is needed, the file layer requests it from the buffer manager.
ğ–¦¹ The disk space manager allocates and tracks disk pages.
â€¢ When new space is needed, it allocates pages.
â€¢ When pages are no longer needed, it marks them free and reuses them later.
ğ–¦¹ The files and access methods layer relies on these managers for storage and retrieval.

4. File organizations and indexing
ğ–¦¹ A file of records is handled by the files and access methods layer.
ğ–¦¹ The file layer can create, delete, insert records, delete records, and scan through all records.
â€¢ A relation is stored as a file of records.
ğ–¦¹ Records are stored across disk pages, and the file layer tracks allocated pages and available space.
ğ–¦¹ The simplest file organization is a heap file where records are stored in random order.
ğ–¦¹ An index is a data structure that supports fast retrieval based on search key fields.
â€¢ Additional indexes can be created on different search keys to support different search operations.

5. Data entries in an index
ğ–¦¹ A data entry (k*) in an index contains enough information to locate records with search key value k.
ğ–¦¹ Searching the index finds data entries, which are then used to locate data records.
ğ–¦¹ Three alternatives for storing data entries:
â€¢ Alternative (1): The data entry is the actual data record.
â€¢ Alternative (2): The data entry is a (k, rid) pair, where rid is the record id.
â€¢ Alternative (3): The data entry is a (k, rid-list) pair, where rid-list contains all matching record ids.
ğ–¦¹ Alternative (1) means the index itself is a file of data records.
ğ–¦¹ Alternatives (2) and (3) store pointers and are independent of how the main data file is organized.
ğ–¦¹ Alternative (3) uses space efficiently but has variable-length entries.
ğ–¦¹ Only one index should use Alternative (1) to avoid storing records multiple times.

6. Clustered indexes
ğ–¦¹ An index is clustered if the order of data records matches the index order.
ğ–¦¹ If the index uses Alternative (1), it is clustered by definition.
ğ–¦¹ Alternatives (2) and (3) are clustered only if the data file itself is sorted by the search key.
ğ–¦¹ In practice, files are rarely kept sorted, so clustered indexes usually use Alternative (1).
ğ–¦¹ A clustered index returns data pages that are close together for range queries, reducing page I/O.
ğ–¦¹ An unclustered index may require many separate page fetches for range queries.

7. Primary and secondary indexes
ğ–¦¹ An index on fields that include the primary key is called a primary index.
ğ–¦¹ Indexes on other fields are secondary indexes.
ğ–¦¹ Terminology varies; some define primary index as Alternative (1) and secondary as Alternatives (2) or (3).
ğ–¦¹ A primary index does not have duplicate search key values.
ğ–¦¹ Secondary indexes may contain duplicates.
ğ–¦¹ If no duplicates exist, the index is called a unique index.
IMG_URL primary-secondary-indices.png

8. Index data structures
ğ–¦¹ Data entries can be organized using hashing or tree-based structures.
ğ–¦¹ Either hashing or tree indexing can be used with any of the three data entry alternatives.

9. Hash-based indexing
ğ–¦¹ Hashing groups records into buckets based on a hash function applied to the search key.
ğ–¦¹ Each bucket consists of a primary page and possibly overflow pages linked in a chain.
ğ–¦¹ Searching:
â€¢ Apply the hash function to identify the correct bucket.
â€¢ Retrieve all pages in that bucket to find matching records.
ğ–¦¹ Insertion:
â€¢ Insert the record into its bucket.
â€¢ Overflow pages are added if the bucket is full.
ğ–¦¹ If we do not know the search key value, we must scan the entire file.
ğ–¦¹ Hash-based indexes usually allow retrieval of a page in one to two disk I/Os.
ğ–¦¹ Example:
â€¢ File of employees hashed on age uses Alternative (1), storing actual data records.
â€¢ Auxiliary index on sal uses Alternative (2), storing (sal, rid) pairs.
IMG_URL hash-index.png

10. Tree-based indexing
ğ–¦¹ Data entries are stored in sorted order by search key.
ğ–¦¹ A hierarchical tree structure guides searches to the correct leaf page.
ğ–¦¹ Leaf level contains the data entries.
ğ–¦¹ Non-leaf nodes contain search key values and pointers to child nodes.
â€¢ Pointer to the left of key k leads to entries less than k.
â€¢ Pointer to the right of key k leads to entries greater than or equal to k.
ğ–¦¹ Leaf pages are linked to allow efficient scanning across a range of values.
ğ–¦¹ The search cost equals the height of the tree plus the number of leaf pages that satisfy the condition.
ğ–¦¹ B+ tree maintains equal path length from root to every leaf, ensuring balance.
ğ–¦¹ Tree height is usually small (often 3 or 4), so retrieval typically takes only a few disk I/Os.
ğ–¦¹ Fan-out refers to the average number of children of a non-leaf node.
â€¢ If fan-out is F and height is h, number of leaf pages is approximately F^h.
ğ–¦¹ With large fan-out (e.g., F â‰¥ 100), a tree of height 4 can index around 100 million leaf pages efficiently.
IMG_URL tree-index.png

11. Fan-out and tree height
ğ–¦¹ The average number of children for a non-leaf node is called the fan-out.
ğ–¦¹ If every non-leaf node has n children, a tree of height h has n^h leaf pages.
ğ–¦¹ In practice, nodes have varying numbers of children, but the average F can approximate leaf pages as F^h.
ğ–¦¹ Typically, F is at least 100, so a tree of height 4 can have 100 million leaf pages.
ğ–¦¹ Searching such a tree requires 4 I/Os.
â€¢ This is much faster than a binary search, which would require over 25 I/Os for the same number of pages.

12. Comparison of File Organizations
ğ–¦¹ Basic file organizations considered:
â€¢ Heap file (randomly ordered records)
â€¢ Sorted file (records sorted on age, sal)
â€¢ Clustered B+ tree file (search key age, sal)
â€¢ Heap file with unclustered B+ tree index (age, sal)
â€¢ Heap file with unclustered hash index (age, sal)
- Choice of file organization affects operation costs. Sorting or indexing can improve performance for some operations.

13. Operations on Files
ğ–¦¹ Scan: Fetch all records from disk into memory.
ğ–¦¹ Search with Equality Selection: Fetch records matching exact values (e.g., age=23, sal=50).
ğ–¦¹ Search with Range Selection: Fetch records in a range (e.g., age>35).
ğ–¦¹ Insert: Find appropriate page, add record, write back, may affect other pages.
ğ–¦¹ Delete: Locate page and record, remove record, write back, may affect other pages.

14. Cost Model
ğ–¦¹ B = number of data pages, R = records per page.
ğ–¦¹ D = average time to read/write a page, C = average time to process a record.
ğ–¦¹ H = time to apply hash function, F = fan-out for tree indexes.
ğ–¦¹ I/O usually dominates cost; CPU is less significant.
ğ–¦¹ Simplified model counts pages read/written; ignores blocked access and other factors.

15. Heap Files
ğ–¦¹ Scan cost: B(D + RC)
ğ–¦¹ Equality selection (candidate key): 0.5B(D + RC)
ğ–¦¹ Equality selection (non-key): B(D + RC)
ğ–¦¹ Range selection: B(D + RC)
ğ–¦¹ Insert at end: 2D + C
ğ–¦¹ Delete by rid: D + C + D
- Deletion by condition may require scanning and modifying multiple pages.

16. Sorted Files
ğ–¦¹ Scan cost: B(D + RC)
ğ–¦¹ Equality selection matching sort order: Dlog2B + Clog2R
â€¢ Multiple matching records are contiguous; sequential retrieval is efficient.
ğ–¦¹ Range selection: Search first record (Dlog2B + Clog2R), then sequentially fetch pages.
ğ–¦¹ Insert: Search + read/write subsequent pages; cost ~ search + B(D + RC)
ğ–¦¹ Delete: Search + read/write subsequent pages to compact; same cost as insert.
- Sorting helps locate records efficiently but increases insertion/deletion cost.

17. Clustered Files
ğ–¦¹ Average page occupancy: 67%, total pages ~1.5B
ğ–¦¹ Scan: 1.5B(D + RC)
ğ–¦¹ Equality selection: DlogF1.5B + Clog2R
ğ–¦¹ Range selection: First record located as equality, then sequentially fetch leaf pages.
ğ–¦¹ Insert: Search + write modified leaf page; occasional splits ignored
ğ–¦¹ Delete: Search + modify/write pages; similar to insert
- Clustered files combine sorted order benefits with efficient insert/delete.

18. Heap File with Unclustered Tree Index
ğ–¦¹ Each data entry ~0.1 size of a record; leaf pages ~0.15B
ğ–¦¹ Scan: Leaf level cost 0.15B(D + 6.7RC) + fetch each record BR(D + C)
ğ–¦¹ Equality search: DlogF0.15B + Clog2(6.7R) + D
ğ–¦¹ Range search: Cost depends on number of qualifying records; each requires one I/O
ğ–¦¹ Insert: 2D + C (heap) + DlogF0.15B + Clog2(6.7R) + D (index)
ğ–¦¹ Delete: Locate record + index, then write modified pages; cost 2D + DlogF0.15B + Clog2(6.7R)
- Unclustered index fast for single-record search but expensive for scans/range queries.

19. Heap File with Unclustered Hash Index
ğ–¦¹ Each data entry ~0.1 size of record; pages ~0.125B; 80% occupancy
ğ–¦¹ Scan: Retrieve entries 0.125B(D + 8RC) + fetch each record BR(D + C), very expensive
ğ–¦¹ Equality search: H + 2D + 4RC
ğ–¦¹ Range search: Entire heap file scanned; cost B(D + RC)
ğ–¦¹ Insert: 2D + C (heap) + H + 2D + C (index)
ğ–¦¹ Delete: Locate record + index: H + 2D + 4RC, then write pages 2D
- Hash indexes are very fast for equality, do not support efficient range searches.

20. Comparison of I/O Costs
ğ–¦¹ Heap file: efficient storage, fast scan/insert, slow search/delete
ğ–¦¹ Sorted file: efficient storage, fast search, slow insert/delete
ğ–¦¹ Clustered file: fast search, efficient insert/delete, extra space overhead
ğ–¦¹ Unclustered tree/hash: fast search/insert/delete, slow scan/range search
ğ–¦¹ Hash slightly faster for equality, cannot do range search
- No single file organization is best for all operations.

21. INDEXES AND PERFORMANCE TUNING
ğ–¦¹ Indexes improve database performance and must be chosen based on expected workload.
ğ–¦¹ Index choice impacts performance and requires understanding query evaluation and concurrency control.
ğ–¦¹ Examples with multiple tables require knowledge of join algorithms and query plans.

22. Impact of the Workload
ğ–¦¹ Consider expected workload and common operations when choosing indexes.
ğ–¦¹ Indexes support efficient retrieval for selection conditions: equality and range.
â€¢ Hash-based indexes are good for equality selections but poor for range selections.
â€¢ Tree-based indexes support both equality and range selections efficiently.
ğ–¦¹ Both tree and hash indexes handle inserts, deletes, and updates efficiently.
ğ–¦¹ Tree-based indexes are better than fully sorted files for:
â€¢ Efficient inserts and deletes.
â€¢ Faster leaf page search than binary search in sorted files.
ğ–¦¹ Sorted files are faster for sequential page retrieval but expensive for inserts and deletes.
ğ–¦¹ ISAM combines sequential leaf allocation with fast search; inserts/deletes are better than sorted files but worse than B+ trees.

23. Clustered Index Organization
ğ–¦¹ Clustered index organizes the underlying data records; only one clustered index per table.
ğ–¦¹ Multiple unclustered indexes can exist on a data file.
ğ–¦¹ Clustered indexes are expensive to maintain when inserting into full leaf pages due to record movement and updates in other indexes.
ğ–¦¹ Clustering should be used sparingly for queries that benefit from sequential access.
ğ–¦¹ Hash indexes are unsuitable for clustered files because range queries cannot use them.
ğ–¦¹ Index-only evaluation can compute queries using just index entries without fetching data records.
ğ–¦¹ Example: Using a B+ tree index on age for SELECT [pink]FROM[/pink] [yellow]Employees E[/yellow] [pink]WHERE[/pink] [yellow]E.age > 40[/yellow].
â€¢ Benefit depends on selectivity of the condition and whether the index is clustered.
ğ–¦¹ Queries on non-key fields may benefit from clustering if many records share the same value.
ğ–¦¹ Aggregate queries can use indexes (clustered or unclustered) without accessing full tuples.

24. Composite Search Keys
ğ–¦¹ A composite search key contains multiple fields, e.g., (age, sal) or (sal, age).
ğ–¦¹ Equality queries bind all fields in the search key to constants; hash indexes support only equality queries.
ğ–¦¹ Range queries bind only some fields; tree indexes support range queries on a prefix of the composite key.
ğ–¦¹ Composite keys allow broader query matching and increase opportunities for index-only evaluation.
ğ–¦¹ Drawbacks: updates affect any field in the key; composite indexes are larger and may increase tree levels.
ğ–¦¹ Design examples:
â€¢ SELECT [pink]FROM[/pink] [yellow]Employees E[/yellow] [pink]WHERE[/pink] [yellow]E.age BETWEEN 20 AND 30 AND E.sal BETWEEN 3000 AND 5000[/yellow]
- A composite B+ tree index on (age, sal) is effective; hash index cannot help.
â€¢ SELECT [pink]FROM[/pink] [yellow]Employees E[/yellow] [pink]WHERE[/pink] [yellow]E.age = 25 AND E.sal BETWEEN 3000 AND 5000[/yellow]
- Index on (age, sal) performs better than (sal, age) due to ordering of attributes.
â€¢ Aggregate queries benefit from composite indexes for index-only scans.

25. Index Specification in SQL: 1999
ğ–¦¹ SQL:1999 does not require support for indexes or provide standard commands to create/drop them.
ğ–¦¹ Commercial DBMS support indexes; example for creating a B+ tree index:
[pink]CREATE INDEX[/pink] [yellow]IndAgeRating ON Students[/yellow]
[pink]WITH STRUCTURE =[/pink] [yellow]BTREE, KEY = (age, gpa)[/yellow]
ğ–¦¹ The index automatically updates with inserts and deletes on the Students table.

SOURCE: Elmasri and Navathe â€“ "FUNDAMENTALS OF DATABASE SYSTEMS"
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -[12/11/2025]
1. Object and Object-Relational Databases
ğ–¦¹ Object-oriented data models have features now incorporated in relational databases and SQL standards.
ğ–¦¹ Some features are also in NoSQL and XML models.
ğ–¦¹ Object databases (ODBs) were originally called object-oriented databases (OODBs).
ğ–¦¹ Traditional models like network, hierarchical, and relational work well for business applications but have limitations for complex applications (CAD/CAM, biology, GIS, multimedia).
ğ–¦¹ ODBs allow specifying complex object structures and operations.
ğ–¦¹ Growth of object-oriented programming languages (C++, Java) increased the need for ODBs.
ğ–¦¹ Object-relational databases (ORDBMS) combine relational systems with object database features.
ğ–¦¹ SQL:2008 includes many object features originally proposed for SQL/Object.
ğ–¦¹ Many experimental and commercial ODB systems were created but did not gain widespread use due to relational and object-relational popularity.
ğ–¦¹ ODMG 3.0 standard was proposed to provide a standard model and language for ODBs.
ğ–¦¹ Key ODB concepts include object identity, structure, encapsulation, methods, persistence, and inheritance.
ğ–¦¹ SQL standards incorporated these concepts, with object features in SQL:1999 and SQL:2008.

2. Introduction to Object-Oriented Concepts
ğ–¦¹ OO concepts originated in OO programming languages (OOPLs) like SIMULA and Smalltalk.
ğ–¦¹ Pure OO languages explicitly designed for OO, e.g., Smalltalk.
ğ–¦¹ Hybrid OO languages integrate OO features into existing languages, e.g., C++.
ğ–¦¹ Objects have state (value) and behavior (operations).
ğ–¦¹ In OOPLs, objects are transient; OO databases store objects persistently.
ğ–¦¹ Persistent objects can be shared among multiple programs.
ğ–¦¹ Internal structure includes instance variables (attributes) and operations (methods).
ğ–¦¹ Complete encapsulation can be relaxed to allow attribute access for queries.
ğ–¦¹ Operations have a signature (interface) and a method (implementation).
ğ–¦¹ Type and class hierarchies allow inheritance, reusing definitions.
ğ–¦¹ Relationships among objects can be explicitly represented with inverse references.
ğ–¦¹ Operator overloading (polymorphism) allows operations on different object types, often requiring late binding.

3. Object Identity and Literals
ğ–¦¹ Each object in an ODB has a unique object identifier (OID).
â€¢ OID is immutable and system-generated.
â€¢ OID must not depend on attribute values.
â€¢ Early ODBs used physical addresses as OIDs.
ğ–¦¹ ODBs distinguish between objects (with OID) and literals (without OID).
ğ–¦¹ Literals cannot be referenced from other objects but can be part of objects.

4. Complex Type Structures
ğ–¦¹ Objects and literals can have complex types.
ğ–¦¹ Three main type constructors:
â€¢ Atom: basic types (integer, string, boolean) - atomic values.
â€¢ Struct/Tuple: structured types made of multiple components.
â€¢ Collection: multivalued types (set, list, bag, array, dictionary) containing elements of the same type.
ğ–¦¹ Struct constructor generates multiple structured types.
ğ–¦¹ Collection types allow ordered or unordered groups of elements.
ğ–¦¹ Dictionary constructor creates key-value pairs.
ğ–¦¹ Type constructors define data structures for OO database schemas.

5. Encapsulation of Operations and Persistence
ğ–¦¹ Encapsulation defines the interface and hides implementation of object operations.
ğ–¦¹ Operations can create, destroy, update, or retrieve object state.
ğ–¦¹ Interface (signature) is visible; method (implementation) is hidden.
ğ–¦¹ Objects can have visible and hidden attributes.
ğ–¦¹ Operations are applied using dot notation (e.g., d.no_of_emps).
ğ–¦¹ Persistence mechanisms:
â€¢ Naming: assign a unique persistent name to an object.
â€¢ Reachability: objects reachable from a persistent object also become persistent.
ğ–¦¹ Extent is a named collection of objects of a class that are persistent.
ğ–¦¹ Multiple persistent collections can exist for the same class.

6. Type Hierarchies and Inheritance
ğ–¦¹ ODBs support subtypes and supertypes forming type hierarchies.
ğ–¦¹ Subtypes inherit attributes and operations from supertypes.
â€¢ Example: PERSON type has Name, Address, Birth_date, Age, Ssn.
â€¢ EMPLOYEE subtype adds Salary, Hire_date, Seniority.
â€¢ STUDENT subtype adds Major, Gpa.
ğ–¦¹ Inheritance allows incremental development and reusability of types.
ğ–¦¹ Area operation for GEOMETRY_OBJECT can have different implementations for RECTANGLE, TRIANGLE, and CIRCLE.
ğ–¦¹ Objects belong to declared types and persistent collections (extents).
ğ–¦¹ Constraint: objects in a subtype extent must also belong to supertype extent.
ğ–¦¹ ROOT or OBJECT class can include all objects in the system.

7. Object Database Extensions to SQL
ğ–¦¹ SQL was first specified by Chamberlin and Boyce (1974) and standardized in 1989 and 1992.
ğ–¦¹ SQL3 (later SQL:99) incorporated object database features; initially called SQL/Object, later part of SQL/Foundation in SQL:2008.
ğ–¦¹ Object-relational model combines relational model with object database enhancements.
ğ–¦¹ Revisions in 2003 and 2006 added XML-related features.
ğ–¦¹ Object database features include:
â€¢ Type constructors for complex objects: row type, array type, set, list, bag (added in SQL:2008)
â€¢ Object identity via reference type
â€¢ Encapsulation via user-defined types (UDTs) with operations; user-defined routines (UDRs)
â€¢ Inheritance using [pink]UNDER[/pink] keyword

8. User-Defined Types Using CREATE TYPE and Complex Objects
ğ–¦¹ UDTs allow creation of complex-structured objects and separate type declaration from table creation.
ğ–¦¹ Four collection types: [pink]ARRAY[/pink], [pink]MULTISET[/pink], [pink]LIST[/pink], [pink]SET[/pink].
ğ–¦¹ UDTs can be used as attribute types or table types; nesting allows complex structures.
ğ–¦¹ ROW TYPE allows direct structured attributes without separate UDT.
ğ–¦¹ Collection elements accessed using square brackets; [pink]CARDINALITY[/pink] returns current element count.
ğ–¦¹ Dot notation used to access components (e.g., ADDR.CITY).
ğ–¦¹ Code examples:
[pink]CREATE TYPE[/pink] STREET_ADDR_TYPE [pink]AS[/pink] (
 [yellow]NUMBER VARCHAR (5),[/yellow]
 [yellow]STREET_NAME VARCHAR (25),[/yellow]
 [yellow]APT_NO VARCHAR (5),[/yellow]
 [yellow]SUITE_NO VARCHAR (5)[/yellow]
);
[pink]CREATE TYPE[/pink] USA_ADDR_TYPE [pink]AS[/pink] (
 [yellow]STREET_ADDR STREET_ADDR_TYPE,[/yellow]
 [yellow]CITY VARCHAR (25),[/yellow]
 [yellow]ZIP VARCHAR (10)[/yellow]
);
[pink]CREATE TYPE[/pink] USA_PHONE_TYPE [pink]AS[/pink] (
 [yellow]PHONE_TYPE VARCHAR (5),[/yellow]
 [yellow]AREA_CODE CHAR (3),[/yellow]
 [yellow]PHONE_NUM CHAR (7)[/yellow]
);
[pink]CREATE TYPE[/pink] PERSON_TYPE [pink]AS[/pink] (
 [yellow]NAME VARCHAR (35),[/yellow]
 [yellow]SEX CHAR,[/yellow]
 [yellow]BIRTH_DATE DATE,[/yellow]
 [yellow]PHONES USA_PHONE_TYPE ARRAY [4],[/yellow]
 [yellow]ADDR USA_ADDR_TYPE,[/yellow]
 [yellow]INSTANTIABLE,[/yellow]
 [yellow]NOT FINAL,[/yellow]
 [yellow]REF IS SYSTEM GENERATED,[/yellow]
 [pink]INSTANCE METHOD[/pink] AGE() [pink]RETURNS[/pink] INTEGER;
 [pink]CREATE INSTANCE METHOD[/pink] AGE() [pink]RETURNS[/pink] INTEGER
 [pink]FOR[/pink] PERSON_TYPE
 [pink]BEGIN[/pink]
  [yellow]RETURN /* CODE TO CALCULATE A PERSONâ€™S AGE */[/yellow]
 [pink]END;[/pink]
);
[pink]CREATE TYPE[/pink] GRADE_TYPE [pink]AS[/pink] (
 [yellow]COURSENO CHAR (8),[/yellow]
 [yellow]SEMESTER VARCHAR (8),[/yellow]
 [yellow]YEAR CHAR (4),[/yellow]
 [yellow]GRADE CHAR[/yellow]
);
[pink]CREATE TYPE[/pink] STUDENT_TYPE [pink]UNDER[/pink] PERSON_TYPE [pink]AS[/pink] (
 [yellow]MAJOR_CODE CHAR (4),[/yellow]
 [yellow]STUDENT_ID CHAR (12),[/yellow]
 [yellow]DEGREE VARCHAR (5),[/yellow]
 [yellow]TRANSCRIPT GRADE_TYPE ARRAY [100],[/yellow]
 [yellow]INSTANTIABLE,[/yellow]
 [yellow]NOT FINAL,[/yellow]
 [pink]INSTANCE METHOD[/pink] GPA() [pink]RETURNS[/pink] FLOAT;
 [pink]CREATE INSTANCE METHOD[/pink] GPA() [pink]RETURNS[/pink] FLOAT
 [pink]FOR[/pink] STUDENT_TYPE
 [pink]BEGIN[/pink]
  [yellow]RETURN /* CODE TO CALCULATE GPA */[/yellow]
 [pink]END;[/pink]
);
[pink]CREATE TYPE[/pink] EMPLOYEE_TYPE [pink]UNDER[/pink] PERSON_TYPE [pink]AS[/pink] (
 [yellow]JOB_CODE CHAR (4),[/yellow]
 [yellow]SALARY FLOAT,[/yellow]
 [yellow]SSN CHAR (11),[/yellow]
 [yellow]INSTANTIABLE,[/yellow]
 [yellow]NOT FINAL[/yellow]
);
[pink]CREATE TYPE[/pink] MANAGER_TYPE [pink]UNDER[/pink] EMPLOYEE_TYPE [pink]AS[/pink] (
 [yellow]DEPT_MANAGED CHAR (20),[/yellow]
 [yellow]INSTANTIABLE[/yellow]
);
[pink]CREATE TABLE[/pink] PERSON [pink]OF[/pink] PERSON_TYPE
 [yellow]REF IS PERSON_ID SYSTEM GENERATED;[/yellow]
[pink]CREATE TABLE[/pink] EMPLOYEE [pink]OF[/pink] EMPLOYEE_TYPE
 [pink]UNDER[/pink] PERSON;
[pink]CREATE TABLE[/pink] MANAGER [pink]OF[/pink] MANAGER_TYPE
 [pink]UNDER[/pink] EMPLOYEE;
[pink]CREATE TABLE[/pink] STUDENT [pink]OF[/pink] STUDENT_TYPE
 [pink]UNDER[/pink] PERSON;
[pink]CREATE TYPE[/pink] COMPANY_TYPE [pink]AS[/pink] (
 [yellow]COMP_NAME VARCHAR (20),[/yellow]
 [yellow]LOCATION VARCHAR (20)[/yellow]
);
[pink]CREATE TYPE[/pink] EMPLOYMENT_TYPE [pink]AS[/pink] (
 [yellow]Employee REF (EMPLOYEE_TYPE) SCOPE (EMPLOYEE),[/yellow]
 [yellow]Company REF (COMPANY_TYPE) SCOPE (COMPANY)[/yellow]
);
[pink]CREATE TABLE[/pink] COMPANY [pink]OF[/pink] COMPANY_TYPE (
 [yellow]REF IS COMP_ID SYSTEM GENERATED,[/yellow]
 [yellow]PRIMARY KEY (COMP_NAME)[/yellow]
);
[pink]CREATE TABLE[/pink] EMPLOYMENT [pink]OF[/pink] EMPLOYMENT_TYPE;

9. Object Identifiers Using Reference Types
ğ–¦¹ Unique object identifiers created using [pink]REF[/pink].
ğ–¦¹ Syntax: [pink]REF IS SYSTEM GENERATED[/pink] creates system-generated ID.
ğ–¦¹ User can specify [pink]REF IS <OID_ATTRIBUTE> <VALUE_GENERATION_METHOD>[/pink] with SYSTEM GENERATED or DERIVED.

10. Creating Tables Based on the UDTs
ğ–¦¹ INSTANTIABLE UDTs can be used to create tables.
ğ–¦¹ Noninstantiable UDTs only serve as attribute types.
ğ–¦¹ Attributes like PERSON_ID hold system-generated object IDs for table rows.

11. Encapsulation of Operations
ğ–¦¹ UDTs can have methods along with attributes.
ğ–¦¹ Syntax: [pink]CREATE TYPE[/pink] TYPE_NAME (<attributes>, <methods>)
ğ–¦¹ Constructor TYPE_T() returns new object with default values.
ğ–¦¹ Observer function reads attribute; mutator updates it.
ğ–¦¹ Functions may require [pink]EXECUTE[/pink] privilege.
ğ–¦¹ Functions can be internal (SQL PSM) or external (host language signature only).
ğ–¦¹ Attributes/functions categories: PUBLIC, PRIVATE, PROTECTED.
ğ–¦¹ Virtual attributes computed via functions.

12. Specifying Inheritance and Overloading of Functions
ğ–¦¹ Inheritance applied using [pink]UNDER[/pink] for types or tables.
ğ–¦¹ [pink]NOT FINAL[/pink] allows creation of subtypes.
ğ–¦¹ Rules:
â€¢ All attributes inherited
â€¢ Supertype order sets hierarchy
â€¢ Subtype instance usable where supertype instance is used
â€¢ Subtype can redefine functions with same signature
â€¢ Function calls resolve best match based on argument types
â€¢ Dynamic linking considers parameter types at runtime
ğ–¦¹ Table inheritance: INSERT, DELETE, UPDATE in subtable propagate to supertable; tuples in subtable must exist in supertable.

13. Specifying Relationships via Reference
ğ–¦¹ Component attribute can reference tuple of another table using [pink]REF[/pink].
ğ–¦¹ [pink]SCOPE[/pink] specifies table whose tuples can be referenced.
ğ–¦¹ Dot notation accesses components; [pink]â€“>[/pink] used for dereferencing REF attributes.
ğ–¦¹ Example:
[pink]SELECT[/pink] E.Employeeâ€“>NAME
[pink]FROM[/pink] EMPLOYMENT AS E
[pink]WHERE[/pink] E.Companyâ€“>COMP_NAME = â€˜ABCXYZâ€™;
ğ–¦¹ [pink]â€“>[/pink] works like in C: râ€“>a returns attribute a of referenced tuple.
ğ–¦¹ [pink]SCOPE[/pink] allows reference to tuples within a specific table of same type.

14. ODMG Object Model and Object Definition Language ODL
ğ–¦¹ ODMG-93 (1.0) standard created by ODMG consortium; revised to 2.0 and 3.0.
ğ–¦¹ Standard includes object model, object definition language (ODL), object query language (OQL), and bindings to OOP languages.
ğ–¦¹ ODMG 3.0 based on decades of research in conceptual modeling and object databases.
ğ–¦¹ Object-relational technology incorporates object concepts into SQL.

15. Overview of ODMG Object Model
ğ–¦¹ Provides standard data model for object databases, similar to SQL for relational DBs.
ğ–¦¹ Establishes standard terminology in the field.
ğ–¦¹ Basic building blocks: objects and literals.
â€¢ Objects have identifier and state; literals have state only.
ğ–¦¹ Object aspects: identifier, name, lifetime, structure, creation.
- Identifier: unique Object_id.
- Name: optional, unique within ODB; used to locate object.
- Lifetime: persistent or transient; independent of class/type.
- Structure: atomic (single user-defined object) or non-atomic (collection of objects).
- Creation: via [pink]new[/pink] operation in Object_Factory interface.

16. Types of Literals
ğ–¦¹ Atomic literals: predefined basic data types (long, short, unsigned, float, double, boolean, char, string, enum).
ğ–¦¹ Structured literals: user-defined using [pink]STRUCT[/pink], include Date, Interval, Time, Timestamp.
ğ–¦¹ Collection literals: collections of objects or values without Object_id; type generators include set<T>, bag<T>, list<T>, array<T>, dictionary<K,V>.

17. Object Interfaces and Classes
ğ–¦¹ Interface: defines behavior only, non-instantiable.
ğ–¦¹ Class: defines both state and behavior, instantiable.
ğ–¦¹ Literal declaration: defines state only, no behavior or Object_id.
ğ–¦¹ All objects inherit Object interface operations: [pink]copy()[/pink], [pink]delete()[/pink], [pink]same_as()[/pink].
- Dot notation example: O.[pink]same_as[/pink](P), P = O.[pink]copy[/pink]().
- Arrow notation alternative: Oâ€“>[pink]same_as[/pink](P), Oâ€“>[pink]copy[/pink]().

18. Inheritance in ODMG
ğ–¦¹ Behavior-only inheritance: interface inheritance (ISA), uses colon (:), supertype must be interface, subtype can be class or interface.
ğ–¦¹ EXTENDS inheritance: inherits state + behavior among classes, uses [pink]extends[/pink], only single inheritance allowed.
ğ–¦¹ Classes can inherit behavior from multiple interfaces via colon.

19. Built-in Interfaces and Classes
ğ–¦¹ All inherit Object interface.
ğ–¦¹ Collection objects include set, list, bag, array, dictionary; provide operations like [pink]cardinality()[/pink], [pink]is_empty()[/pink], [pink]insert_element(E)[/pink], [pink]remove_element(E)[/pink], [pink]contains_element(E)[/pink], [pink]create_iterator()[/pink].
ğ–¦¹ Iterator interface: [pink]reset()[/pink], [pink]next_position()[/pink], [pink]get_element()[/pink].
ğ–¦¹ Exceptions: ElementNotFound, NoMoreElements.
ğ–¦¹ Specialized operations for set<T>: [pink]create_union(S)[/pink], [pink]is_subset_of(S)[/pink].
ğ–¦¹ List<T> operations: [pink]insert_element_first(E)[/pink], [pink]insert_element_after(E,I)[/pink], [pink]remove_first_element()[/pink], [pink]concat(I)[/pink], [pink]append(I)[/pink].
ğ–¦¹ Array<T> operations: [pink]replace_element_at(I,E)[/pink], [pink]remove_element_at(I)[/pink], [pink]retrieve_element_at(I)[/pink], [pink]resize(N)[/pink].
ğ–¦¹ Dictionary<K,V> operations: [pink]bind(K,V)[/pink], [pink]unbind(K)[/pink], [pink]lookup(K)[/pink], [pink]contains_key(K)[/pink].

20. Atomic (User-Defined) Objects
ğ–¦¹ Defined using [pink]class[/pink] in ODL; not collections.
ğ–¦¹ Example: STUDENT, EMPLOYEE, DEPARTMENT.
ğ–¦¹ Components:
â€¢ Attributes: simple or complex literals, or Object_ids.
â€¢ Relationships: binary, use [pink]relationship[/pink] keyword with [pink]inverse[/pink] for bidirectional mapping.
â€¢ Operations: define behavior, can include exceptions.

21. Extents, Keys, and Factory Objects
ğ–¦¹ Extent: declared with [pink]extent[/pink], contains all persistent objects of a class.
ğ–¦¹ Keys: unique attributes or relationships per extent; composite keys in parentheses.
ğ–¦¹ Factory objects: create individual objects using [pink]new()[/pink].
â€¢ Examples: ObjectFactory, SetFactory, ListFactory, ArrayFactory, DictionaryFactory, DateFactory.
ğ–¦¹ Database interfaces: DatabaseFactory and Database.
- Operations: [pink]open(name)[/pink], [pink]close()[/pink], [pink]bind(object,name)[/pink], [pink]unbind(name)[/pink], [pink]lookup(name)[/pink].

22. Object Definition Language (ODL)
ğ–¦¹ ODL used to create object specifications (classes, interfaces) for object database schema.
ğ–¦¹ Independent of programming language; can be mapped via language bindings (C++, Java, Smalltalk).
ğ–¦¹ Example: UNIVERSITY database schema.
â€¢ Entity types mapped to ODL classes.
â€¢ Inheritance via [pink]extends[/pink]; no direct mapping for union types or multiple inheritance.
â€¢ Classes: PERSON, FACULTY, STUDENT, GRAD_STUDENT.
â€¢ Extents: PERSONS, FACULTY, STUDENTS, GRAD_STUDENTS.
â€¢ Subsets: STUDENTS âŠ† PERSONS, GRAD_STUDENTS âŠ† STUDENTS.
â€¢ Individual objects inherit properties and operations of supertypes.
IMG_URL odl.png

23. Class Hierarchy and Inheritance
ğ–¦¹ GRAD_STUDENTs are a subset of STUDENTs.
ğ–¦¹ STUDENT and FACULTY inherit properties and operations from PERSON.
ğ–¦¹ GRAD_STUDENT inherits properties and operations from STUDENT.
ğ–¦¹ Classes DEPARTMENT, COURSE, SECTION, CURR_SECTION map directly to entity types.

24. PERSON Class
ğ–¦¹ [pink]class[/pink] PERSON
â€¢ [pink]extent[/pink] PERSONS
â€¢ [pink]key[/pink] Ssn
ğ–¦¹ Attributes
â€¢ [pink]attribute struct[/pink] Pname { string Fname, string Mname, string Lname } Name
â€¢ [pink]attribute string[/pink] Ssn
â€¢ [pink]attribute date[/pink] Birth_date
â€¢ [pink]attribute enum[/pink] Gender{M, F} Sex
â€¢ [pink]attribute struct[/pink] Address { short No, string Street, short Apt_no, string City, string State, short Zip } Address
ğ–¦¹ Methods
â€¢ short Age()

25. FACULTY Class
ğ–¦¹ [pink]class[/pink] FACULTY [pink]extends[/pink] PERSON
â€¢ [pink]extent[/pink] FACULTY
ğ–¦¹ Attributes
â€¢ [pink]attribute string[/pink] Rank
â€¢ [pink]attribute float[/pink] Salary
â€¢ [pink]attribute string[/pink] Office
â€¢ [pink]attribute string[/pink] Phone
ğ–¦¹ Relationships
â€¢ DEPARTMENT Works_in inverse DEPARTMENT::Has_faculty
â€¢ set<GRAD_STUDENT> Advises inverse GRAD_STUDENT::Advisor
â€¢ set<GRAD_STUDENT> On_committee_of inverse GRAD_STUDENT::Committee
ğ–¦¹ Methods
â€¢ void give_raise(in float raise)
â€¢ void promote(in string new_rank)

26. GRADE Class
ğ–¦¹ [pink]class[/pink] GRADE
â€¢ [pink]extent[/pink] GRADES
ğ–¦¹ Attributes
â€¢ [pink]attribute enum[/pink] GradeValues{A,B,C,D,F,I,P} Grade
ğ–¦¹ Relationships
â€¢ SECTION Section inverse SECTION::Students
â€¢ STUDENT Student inverse STUDENT::Completed_sections

27. STUDENT Class
ğ–¦¹ [pink]class[/pink] STUDENT [pink]extends[/pink] PERSON
â€¢ [pink]extent[/pink] STUDENTS
ğ–¦¹ Attributes
â€¢ [pink]attribute string[/pink] Class
â€¢ [pink]attribute Department[/pink] Minors_in
ğ–¦¹ Relationships
â€¢ Department Majors_in inverse DEPARTMENT::Has_majors
â€¢ set<GRADE> Completed_sections inverse GRADE::Student
â€¢ set<CURR_SECTION> Registered_in inverse CURR_SECTION::Registered_students
ğ–¦¹ Methods
â€¢ void change_major(in string dname) raises(dname_not_valid)
â€¢ float gpa()
â€¢ void register(in short secno) raises(section_not_valid)
â€¢ void assign_grade(in short secno; IN GradeValue grade) raises(section_not_valid, grade_not_valid)

28. DEGREE Class
ğ–¦¹ [pink]class[/pink] DEGREE
ğ–¦¹ Attributes
â€¢ [pink]attribute string[/pink] College
â€¢ [pink]attribute string[/pink] Degree
â€¢ [pink]attribute string[/pink] Year

29. GRAD_STUDENT Class
ğ–¦¹ [pink]class[/pink] GRAD_STUDENT [pink]extends[/pink] STUDENT
â€¢ [pink]extent[/pink] GRAD_STUDENTS
ğ–¦¹ Attributes
â€¢ [pink]attribute set[/pink]<Degree> Degrees
ğ–¦¹ Relationships
â€¢ Faculty advisor inverse FACULTY::Advises
â€¢ set<FACULTY> Committee inverse FACULTY::On_committee_of
ğ–¦¹ Methods
â€¢ void assign_advisor(in string Lname; in string Fname) raises(faculty_not_valid)
â€¢ void assign_committee_member(in string Lname; in string Fname) raises(faculty_not_valid)

30. DEPARTMENT Class
ğ–¦¹ [pink]class[/pink] DEPARTMENT
â€¢ [pink]extent[/pink] DEPARTMENTS
â€¢ [pink]key[/pink] Dname
ğ–¦¹ Attributes
â€¢ [pink]attribute string[/pink] Dname
â€¢ [pink]attribute string[/pink] Dphone
â€¢ [pink]attribute string[/pink] Doffice
â€¢ [pink]attribute string[/pink] College
â€¢ [pink]attribute FACULTY[/pink] Chair
ğ–¦¹ Relationships
â€¢ set<FACULTY> Has_faculty inverse FACULTY::Works_in
â€¢ set<STUDENT> Has_majors inverse STUDENT::Majors_in
â€¢ set<COURSE> Offers inverse COURSE::Offered_by

31. COURSE Class
ğ–¦¹ [pink]class[/pink] COURSE
â€¢ [pink]extent[/pink] COURSES
â€¢ [pink]key[/pink] Cno
ğ–¦¹ Attributes
â€¢ [pink]attribute string[/pink] Cname
â€¢ [pink]attribute string[/pink] Cno
â€¢ [pink]attribute string[/pink] Description
ğ–¦¹ Relationships
â€¢ set<SECTION> Has_sections inverse SECTION::Of_course
â€¢ <DEPARTMENT> Offered_by inverse DEPARTMENT::Offers

32. SECTION Class
ğ–¦¹ [pink]class[/pink] SECTION
â€¢ [pink]extent[/pink] SECTIONS
ğ–¦¹ Attributes
â€¢ [pink]attribute short[/pink] Sec_no
â€¢ [pink]attribute string[/pink] Year
â€¢ [pink]attribute enum[/pink] Quarter{Fall, Winter, Spring, Summer} Qtr
ğ–¦¹ Relationships
â€¢ set<Grade> Students inverse Grade::Section
â€¢ COURSE Of_course inverse COURSE::Has_sections

33. CURR_SECTION Class
ğ–¦¹ [pink]class[/pink] CURR_SECTION [pink]extends[/pink] SECTION
â€¢ [pink]extent[/pink] CURRENT_SECTIONS
ğ–¦¹ Relationships
â€¢ set<STUDENT> Registered_students inverse STUDENT::Registered_in
ğ–¦¹ Methods
â€¢ void register_student(in string Ssn) raises(student_not_valid, section_full)

34. GRADE Explanation
ğ–¦¹ Represents M:N relationship between STUDENT and SECTION
â€¢ Made a separate class because it has the relationship attribute Grade
â€¢ Relationships: Completed_sections of STUDENT, Section and Student of GRADE, Students of SECTION

35. DEGREE Explanation
ğ–¦¹ Represents composite multivalued attribute Degrees of GRAD_STUDENT

36. Interface Example
ğ–¦¹ interface GeometryObject
â€¢ Attributes
- [pink]attribute enum[/pink] Shape{RECTANGLE, TRIANGLE, CIRCLE, â€¦} Shape
- [pink]attribute struct[/pink] Point {short x, short y} Reference_point
â€¢ Methods
- float perimeter()
- float area()
- void translate(in short x_translation; in short y_translation)
- void rotate(in float angle_of_rotation)
ğ–¦¹ Classes implementing GeometryObject: RECTANGLE, TRIANGLE, CIRCLE
â€¢ Inherit all operations from interface
â€¢ Attributes must be repeated if needed
â€¢ Methods can have different implementations in each class

37. Inheritance Rules
ğ–¦¹ Interface inheritance allows multiple inheritance
ğ–¦¹ Class [pink]extends[/pink] inheritance allows only single inheritance
â€¢ A class can extend at most one class and implement multiple interfaces

38. Differences between ODB and RDB Design
ğ–¦¹ ODB handles relationships using relationship properties or reference attributes containing OID(s) of related objects.
â€¢ Single references and collections of references are allowed.
â€¢ References can be declared in one or both directions; inverses enforce referential integrity.
ğ–¦¹ RDB handles relationships using attributes with matching values (foreign keys).
â€¢ Foreign keys are single-valued.
â€¢ M:N relationships require separate tables.
ğ–¦¹ Mapping binary relationships with attributes in ODB is complex.
â€¢ Including attributes in both directions causes redundancy and possible inconsistencies.
â€¢ Separate classes may be used for relationships, especially for n-ary relationships (n > 2).
ğ–¦¹ Inheritance is built into ODB using constructs like derived (:) and extends.
â€¢ RDB has no built-in inheritance; options must be chosen manually.
ğ–¦¹ Operations must be specified early in ODB design as part of class definitions.
â€¢ RDB can delay operation specifications until implementation.
ğ–¦¹ Philosophical difference: ODB requires predefined behaviors, while RDB allows ad hoc queries.

39. Mapping EER Schema to ODB Schema Overview
ğ–¦¹ Type declarations of object classes are straightforward for EER schemas without categories or n-ary relationships (n > 2).
ğ–¦¹ Class operations are not in the EER diagram and must be added after structural mapping.

40. Step 1: Create ODL Classes
ğ–¦¹ Create an ODL class for each EER entity type or subclass.
â€¢ Include all attributes from the EER class.
â€¢ Multivalued attributes use set, bag, or list constructors.
- list: ordered values, bag: allows duplicates, set: unique values.
â€¢ Composite attributes use struct (tuple) constructor.
â€¢ Declare extent and specify key attributes.

41. Step 2: Add Relationship Properties
ğ–¦¹ Add relationship properties or reference attributes for each binary relationship.
â€¢ Can be created in one or both directions.
â€¢ Inverse references can be declared if supported.
ğ–¦¹ Single-valued for 1:1 or N:1 relationships; collection types for 1:N or M:N.
ğ–¦¹ Relationship attributes can use struct<reference, attributes>.
- Using both directions may cause redundancy.
- Some ODBMS may not support inverse relationships; programmers must maintain relationships in code.

42. Step 3: Include Operations
ğ–¦¹ Add operations for each class based on requirements.
â€¢ Constructor checks constraints when creating objects.
â€¢ Destructor checks constraints when deleting objects.
â€¢ Other methods include additional constraint checks.
- Program code should enforce these checks.

43. Step 4: Subclass Mapping
ğ–¦¹ ODL class corresponding to a subclass inherits attributes, relationships, and methods from its superclass using extends.
ğ–¦¹ Local attributes, relationships, and operations are added as in steps 1, 2, and 3.

44. Step 5: Weak Entity Types
ğ–¦¹ Map weak entity types like regular entities.
â€¢ Alternative: map weak entities with only identifying relationship as composite multivalued attributes using set<struct<â€¦>> or list<struct<â€¦>>.
â€¢ Attributes included in struct correspond to tuple constructor.

45. Step 6: Categories (Union Types)
ğ–¦¹ Mapping categories is difficult.
â€¢ Create a class for the category.
â€¢ Define 1:1 relationships between the category and each superclass, similar to EER-to-relational mapping.

46. Step 7: N-ary Relationships and M:N
ğ–¦¹ N-ary relationships (n > 2) are mapped into a separate class.
â€¢ Include references to each participating class using 1:N mapping.
ğ–¦¹ M:N binary relationships with attributes may also be mapped as separate classes if desired.

47. Practical Application
ğ–¦¹ The mapping algorithm is applied to a subset of the UNIVERSITY database.
ğ–¦¹ The resulting ODL object schema follows the ODMG standard.

48. The Object Query Language OQL Overview
ğ–¦¹ OQL is the query language for the ODMG object model.
â€¢ Works with programming languages like C++, Smalltalk, and Java via ODMG bindings.
â€¢ Queries return objects matching the language's type system.
â€¢ Class operations can have code in these programming languages.
ğ–¦¹ OQL syntax is similar to SQL but includes features for object identity, complex objects, operations, inheritance, polymorphism, and relationships.
ğ–¦¹ Examples use the UNIVERSITY database schema.

49. Simple OQL Queries, Entry Points, and Iterator Variables
ğ–¦¹ Basic OQL query syntax: select â€¦ from â€¦ where â€¦
â€¢ Example: 
Q0: [pink]select[/pink] D.Dname
[pink]from[/pink] D [pink]in[/pink] DEPARTMENTS
[pink]where[/pink] D.College = 'Engineering';
ğ–¦¹ Database entry points can be any named persistent object or extent.
â€¢ Extent names refer to persistent collections (set of objects), e.g., DEPARTMENTS: set<DEPARTMENT>.
ğ–¦¹ Iterator variables range over each object in the collection.
â€¢ Example: D in DEPARTMENTS.
ğ–¦¹ Result type: bag for select, set for select distinct (removes duplicates).
ğ–¦¹ Iterator variable syntax options:
â€¢ D in DEPARTMENTS
â€¢ DEPARTMENTS D
â€¢ DEPARTMENTS AS D

50. Query Results and Path Expressions
ğ–¦¹ Query results can be any ODMG object model type.
â€¢ Single persistent name returns a reference to that object or collection.
â€¢ Example: Q1: DEPARTMENTS; returns set<DEPARTMENT>.
ğ–¦¹ Path expressions traverse relationships/attributes starting from a persistent name or iterator variable.
â€¢ Dot notation connects attributes or relationships.
â€¢ Example: 
Q2: CS_DEPARTMENT.Chair; returns FACULTY object.
Q2A: CS_DEPARTMENT.Chair.Rank; returns string.
Q2B: CS_DEPARTMENT.Has_faculty; returns set<FACULTY>.
ğ–¦¹ Collections must use iterator variables for operations on attributes of multiple objects.
â€¢ Example:
Q3A: [pink]select[/pink] F.Rank [pink]from[/pink] F [pink]in[/pink] CS_DEPARTMENT.Has_faculty;
Q3B: [pink]select distinct[/pink] F.Rank [pink]from[/pink] F [pink]in[/pink] CS_DEPARTMENT.Has_faculty;

51. Structs in Query Results
ğ–¦¹ OQL can return complex structured results using struct.
â€¢ Example:
Q4A: [pink]select struct[/pink](name: struct(last_name: S.name.Lname, first_name: S.name.Fname),
degrees: ([pink]select struct[/pink](deg: D.Degree, yr: D.Year, college: D.College)
[pink]from[/pink] D [pink]in[/pink] S.Degrees)) 
[pink]from[/pink] S [pink]in[/pink] CS_DEPARTMENT.Chair.Advises;
ğ–¦¹ Nested structs allow hierarchical data: first-level structs with name and degrees components, degrees is a collection of second-level structs.

52. Orthogonality of Path Expressions
ğ–¦¹ Attributes, relationships, and operations can be used interchangeably in path expressions.
â€¢ Example: retrieving GPA of senior CS students ordered by GPA, last and first names:
Q5A: [pink]select struct[/pink](last_name: S.name.Lname, first_name: S.name.Fname, gpa: S.gpa)
[pink]from[/pink] S [pink]in[/pink] CS_DEPARTMENT.Has_majors
[pink]where[/pink] S.Class = 'senior'
[pink]order by[/pink] gpa desc, last_name asc, first_name asc;

53. Views as Named Queries
ğ–¦¹ Views use named queries via define keyword; unique identifier required.
â€¢ Example:
V1: [pink]define[/pink] Has_minors(Dept_name) [pink]as[/pink]
[pink]select[/pink] S [pink]from[/pink] S [pink]in[/pink] STUDENTS
[pink]where[/pink] S.Minors_in.Dname = Dept_name;
ğ–¦¹ Views can have parameters and represent infrequently used inverse relationships.
ğ–¦¹ Example query using view: Has_minors('Computer Science');

54. Extracting Single Elements
ğ–¦¹ element operator extracts a single element from a singleton collection.
â€¢ Raises exception if collection is empty or has multiple elements.
â€¢ Example:
Q6: [pink]element[/pink]([pink]select[/pink] D [pink]from[/pink] D [pink]in[/pink] DEPARTMENTS
[pink]where[/pink] D.Dname = 'Computer Science');

55. Collection Operators (Aggregates and Quantifiers)
ğ–¦¹ Aggregate operators: min, max, count, sum, avg.
â€¢ count returns integer; others return type of operand collection.
â€¢ Examples:
Q7: [pink]count[/pink](S [pink]in[/pink] Has_minors('Computer Science'));
Q8: [pink]avg[/pink]([pink]select[/pink] S.Gpa [pink]from[/pink] S [pink]in[/pink] STUDENTS
[pink]where[/pink] S.Majors_in.Dname = 'Computer Science' [pink]and[/pink] S.Class = 'Senior');
ğ–¦¹ Membership and quantifiers:
â€¢ (E in C): true if E in collection C.
â€¢ (for all V in C : B): true if all elements satisfy B.
â€¢ (exists V in C : B): true if at least one element satisfies B.
â€¢ Examples:
Q10: [pink]select[/pink] S.name.Lname, S.name.Fname [pink]from[/pink] S [pink]in[/pink] STUDENTS
[pink]where[/pink] 'Database Systems I' [pink]in[/pink] ([pink]select[/pink] C.Section.Of_course.Cname [pink]from[/pink] C [pink]in[/pink] S.Completed_sections);
Q11: JEREMY [pink]in[/pink] Has_minors('Computer Science');
Q12: [pink]for all[/pink] G [pink]in[/pink] ([pink]select[/pink] S [pink]from[/pink] S [pink]in[/pink] GRAD_STUDENTS
[pink]where[/pink] S.Majors_in.Dname = 'Computer Science') : G.Advisor [pink]in[/pink] CS_DEPARTMENT.Has_faculty;
Q13: [pink]exists[/pink] G [pink]in[/pink] ([pink]select[/pink] S [pink]from[/pink] S [pink]in[/pink] GRAD_STUDENTS
[pink]where[/pink] S.Majors_in.Dname = 'Computer Science') : G.Gpa = 4;

56. Ordered (Indexed) Collection Expressions
ğ–¦¹ Lists and arrays support first, last, ith element, sub-collection, concatenation.
â€¢ Example for highest salary:
Q14: [pink]first[/pink]([pink]select struct[/pink](facname: F.name.Lname, salary: F.Salary)
[pink]from[/pink] F [pink]in[/pink] FACULTY
[pink]order by[/pink] salary desc);
â€¢ Example for top 3 GPAs:
Q15: ([pink]select struct[/pink](last_name: S.name.Lname, first_name: S.name.Fname, gpa: S.Gpa)
[pink]from[/pink] S [pink]in[/pink] CS_DEPARTMENT.Has_majors
[pink]order by[/pink] gpa desc)[0:2];

57. Grouping Operator
ğ–¦¹ group by partitions objects with same attribute values; returns set of structs with partition data.
â€¢ Example: count majors per department:
Q16: ([pink]select struct[/pink](dept_name, number_of_majors: [pink]count[/pink](partition))
[pink]from[/pink] S [pink]in[/pink] STUDENTS
[pink]group by[/pink] dept_name: S.Majors_in.Dname);
ğ–¦¹ Result type: set<struct(dept_name: string, partition: bag<struct(S: STUDENT)>)>
ğ–¦¹ having clause filters groups based on conditions.
â€¢ Example: average GPA for departments with >100 students:
Q17: [pink]select[/pink] dept_name, avg_gpa: [pink]avg[/pink]([pink]select[/pink] P.gpa [pink]from[/pink] P [pink]in[/pink] partition)
[pink]from[/pink] S [pink]in[/pink] STUDENTS
[pink]group by[/pink] dept_name: S.Majors_in.Dname
[pink]having[/pink] [pink]count[/pink](partition) > 100;

58. Overview of the C++ Language Binding in ODMG
ğ–¦¹ C++ language binding maps ODL constructs to C++ constructs using a class library.
â€¢ Object Manipulation Language (OML) specifies how database objects are retrieved and manipulated in C++.
â€¢ Physical pragmas provide control over storage, clustering, indexes, and memory.

59. Database Class Library in C++
ğ–¦¹ Classes for database concepts use the prefix d_.
â€¢ D_Ref<T> allows program variables to refer to both persistent and transient objects of class T.
â€¢ Abstract class D_Object<T> specifies operations for all objects.
â€¢ Abstract class D_Collection<T> specifies operations for collections (not instantiable).
ğ–¦¹ Template classes for collections include:
â€¢ D_Set<T>, D_List<T>, D_Bag<T>, D_Varray<T>, D_Dictionary<T>
- Example: D_Set<D_Ref<STUDENT>> is a set of references to STUDENT objects; D_Set<string> is a set of strings.
â€¢ d_Iterator corresponds to the Iterator class in the object model.

60. Specifying Classes and Attributes
ğ–¦¹ C++ ODL allows database schema classes using C++ and object database library constructs.
ğ–¦¹ Basic attribute types: d_Short, d_Ushort, d_Long, d_Float.
ğ–¦¹ Structured literal types: d_String, d_Interval, d_Date, d_Time, d_Timestamp.

61. Relationships in C++ Binding
ğ–¦¹ Relationships use prefix rel_ in type names.
â€¢ Example for 1:N binary relationship between DEPARTMENT and STUDENT:
[pink]d_Rel_Ref[/pink]<[yellow]DEPARTMENT, Has_majors[/yellow]> Majors_in; 
[pink]d_Rel_Set[/pink]<[yellow]STUDENT, Majors_in[/yellow]> Has_majors;

62. Creating and Modifying Objects
ğ–¦¹ OML overloads [pink]new[/pink] to create persistent or transient objects.
â€¢ Example: D_Ref<STUDENT> S = [pink]new[/pink](DB1, 'John_Smith') STUDENT; creates a persistent STUDENT in DB1.
ğ–¦¹ Objects can be deleted using delete_object().
ğ–¦¹ Object modification is done through class-defined operations (methods).

63. Extents in C++ Binding
ğ–¦¹ Use d_Extent to create named collection objects (extents) in database.
â€¢ Example: D_Extent<PERSON> ALL_PERSONS(DB1); creates a named collection ALL_PERSONS of type D_Set<PERSON>.
ğ–¦¹ Key constraints are not supported; programmer must implement key checks in class methods.
ğ–¦¹ Persistence via reachability is not supported; objects must be declared persistent when created.

64. Techniques used internally to process high-level queries
ğ–¦¹ A high-level query must be scanned, parsed, and validated.
ğ–¦¹ The scanner identifies tokens such as keywords, attribute names, and relation names.
ğ–¦¹ The parser checks if the syntax follows the query language rules.
ğ–¦¹ Validation ensures all attribute and relation names exist and match the database schema.
ğ–¦¹ An internal representation is created, usually as a query tree or query graph.
â€¢ Query tree is a tree structure.
â€¢ Query graph is a directed acyclic graph (DAG).
ğ–¦¹ The DBMS creates an execution strategy or query plan for retrieving results.
ğ–¦¹ Choosing a suitable execution strategy is called query optimization.

65. Execution steps for processing a query
ğ–¦¹ The query optimizer produces a good execution plan.
ğ–¦¹ The code generator creates the code to run the plan.
ğ–¦¹ The runtime processor executes the query code in compiled or interpreted form.
ğ–¦¹ Runtime errors generate error messages.
ğ–¦¹ Code can be executed immediately or stored for later use.

66. Nature of query optimization
ğ–¦¹ Optimization does not always find the absolute best plan.
ğ–¦¹ Optimal plans can be too time-consuming to compute.
ğ–¦¹ Accurate information about table sizes and value distributions may be missing.
ğ–¦¹ Estimating expected result sizes is required based on query predicates.
ğ–¦¹ Planning a good strategy is more realistic than finding a perfect one.

67. Role of navigational and high-level languages
ğ–¦¹ In navigational languages, the programmer chooses the execution strategy.
ğ–¦¹ DBMS has limited optimization capability for navigational languages.
ğ–¦¹ High-level languages like SQL or OQL specify what result is needed, not how to obtain it.
ğ–¦¹ Optimization is necessary for high-level declarative queries.

68. Query processing and optimization in RDBMS
ğ–¦¹ RDBMS evaluates alternative execution strategies systematically.
ğ–¦¹ The system uses various access algorithms to implement SELECT, JOIN, and other operations.
ğ–¦¹ Only strategies supported by available algorithms and the physical design are considered.
ğ–¦¹ SQL queries are translated into relational algebra and additional operations before optimization.

69. Overview of what follows in the discussion
ğ–¦¹ Explanation of how SQL queries translate into relational algebra and related operations.
ğ–¦¹ Discussion of algorithms for relational algebra implementation.
ğ–¦¹ Explanation of pipelining as an execution strategy.
ğ–¦¹ Brief review of parallel execution strategies.
ğ–¦¹ Summary of concepts at the end.

70. Techniques of query optimization
ğ–¦¹ Two main techniques are used:
â€¢ Heuristic rules to reorder operations in a query tree.
â€¢ Cost estimation to choose the plan with minimum estimated cost.
ğ–¦¹ These require prior understanding of SQL, relational algebra, file structures, and indexing.

71. Translating SQL queries into relational algebra
ğ–¦¹ SQL queries are translated into equivalent extended relational algebra expressions.
ğ–¦¹ The expression is represented as a query tree that is optimized later.
ğ–¦¹ SQL queries are divided into query blocks for translation and optimization.
ğ–¦¹ A query block contains SELECT-FROM-WHERE and may include GROUP BY and HAVING.
ğ–¦¹ Nested queries are separated into multiple query blocks.
ğ–¦¹ Aggregate operators like MAX, MIN, SUM, COUNT are supported in extended algebra.

72. Example of nested query translation
ğ–¦¹ SQL query retrieves employees whose salary is greater than the maximum salary in department 5.
ğ–¦¹ Query is decomposed into inner and outer blocks.
â€¢ Inner block retrieves MAX(Salary) where Dno = 5.
â€¢ Outer block selects Lname, Fname where Salary > result of inner block.
ğ–¦¹ Inner block translation:
â„‘MAX Salary(ÏƒDno=5(EMPLOYEE))
ğ–¦¹ Outer block translation:
Ï€Lname,Fname(ÏƒSalary>c(EMPLOYEE))
- c is the result from the inner block.
ğ–¦¹ The inner block is evaluated once because it is uncorrelated.
ğ–¦¹ Correlated subqueries are more complex and need special optimization techniques.

73. Semi-join and anti-join operators
ğ–¦¹ SQL queries for enterprise and OLAP systems may use operations beyond standard relational algebra.
ğ–¦¹ Semi-join and anti-join are two common additional operators.
ğ–¦¹ Semi-join is used for unnesting EXISTS, IN, and ANY subqueries.
- Notation: T1.X S = T2.Y
- Semantics: Return T1 row when a match is found with any T2 value; no need to find all matches.

74. Semi-join example
ğ–¦¹ Schema:
EMPLOYEE(Ssn, Bdate, Address, Sex, Salary, Dno)
DEPARTMENT(Dnumber, Dname, Dmgrssn, Zipcode)
ğ–¦¹ Query counts departments with employees earning more than 200000.
ğ–¦¹ Original nested subquery retrieves E.Dno values where Salary > 200000.
ğ–¦¹ After unnesting, semi-join is used:
SELECT COUNT(*)
FROM EMPLOYEE E, DEPARTMENT D
WHERE D.Dnumber S= E.Dno AND E.Salary > 200000;
- Semi-join finds department numbers that match employee Dno values.

75. Anti-join operator
ğ–¦¹ Anti-join is used for unnesting NOT EXISTS, NOT IN, and ALL subqueries.
- Notation: T1.X A = T2.Y
- Semantics: Reject T1 row if a match exists in T2; return only if no match is found.

76. Anti-join example
ğ–¦¹ Query counts employees not working in departments with Zipcode = 30332.
ğ–¦¹ Anti-join required because inner join would give incorrect results.
ğ–¦¹ Unnested form using anti-join:
SELECT COUNT(*)
FROM EMPLOYEE, DEPARTMENT
WHERE EMPLOYEE.Dno A= DEPARTMENT AND Zipcode =30332
- Anti-join returns employee rows whose Dno does not match any department with Zipcode 30332.

77. Algorithms for External Sorting
ğ–¦¹ External sorting is used when files are too large to fit in main memory.
ğ–¦¹ Used for ORDER BY, sort-merge JOIN, UNION, INTERSECTION, and DISTINCT.
ğ–¦¹ Sorting may be skipped if an index already provides ordered access.

78. Sort-Merge Strategy Overview
ğ–¦¹ Large file is broken into smaller sorted runs.
ğ–¦¹ Runs are created by loading pieces into memory, sorting them, and writing back.
ğ–¦¹ Sorted runs are then merged into larger sorted subfiles until one sorted file remains.

79. Buffer Usage in External Sorting
ğ–¦¹ Main memory buffer space is part of the DBMS cache.
ğ–¦¹ Memory is divided into buffers equal in size to one disk block.
ğ–¦¹ Each buffer holds exactly one disk block.

80. Sorting Phase
ğ–¦¹ Load as many blocks as fit into nB buffers.
ğ–¦¹ Sort the records in memory.
ğ–¦¹ Write as temporary sorted subfile (run).
â€¢ Number of runs nR = ceil(b / nB).
â€¢ Example: nB = 5, b = 1024 â†’ nR = 205 runs.

81. Merging Phase
ğ–¦¹ Runs are merged in multiple passes.
ğ–¦¹ In each merge step, one buffer per run + one output buffer is needed.
ğ–¦¹ Degree of merge dM = min(nB âˆ’ 1, nR).
ğ–¦¹ Number of merge passes = ceil(log_dM(nR)).
â€¢ Example: nB = 5 â†’ dM = 4 â†’ multiple passes until one sorted file.

82. Example Merge Progress (nB = 5, nR = 205)
ğ–¦¹ First pass: 205 runs â†’ merge 4 at a time â†’ 52 runs.
ğ–¦¹ Second pass: 52 â†’ 13 runs.
ğ–¦¹ Third pass: 13 â†’ 4 runs.
ğ–¦¹ Final pass: 4 â†’ 1 fully sorted file.

83. Pseudocode for Sort-Merge Algorithm
ğ–¦¹ Sorting phase:
â€¢ Read next k blocks (k = nB) or remaining blocks.
â€¢ Sort in memory.
â€¢ Write sorted subfile.
ğ–¦¹ Merging phase:
â€¢ Read kâˆ’1 subfiles block by block.
â€¢ Merge and write output subfile.
â€¢ Repeat until one subfile remains.

[pink]set[/pink] [yellow]i â† 1[/yellow];
[pink]set[/pink] [yellow]j â† b[/yellow];
[pink]set[/pink] [yellow]k â† nB[/yellow];
[pink]set[/pink] [yellow]m â† ceil(j / k)[/yellow];
[pink]while[/pink] [yellow](i â‰¤ m)[/yellow] [pink]do[/pink] {
  [yellow]read next k blocks[/yellow];
  [yellow]sort and write subfile[/yellow];
  [yellow]i â† i + 1[/yellow];
}
[pink]set[/pink] [yellow]i â† 1[/yellow];
[pink]set[/pink] [yellow]p â† ceil(log(kâˆ’1)(m))[/yellow];
[pink]set[/pink] [yellow]j â† m[/yellow];
[pink]while[/pink] [yellow](i â‰¤ p)[/yellow] [pink]do[/pink] {
  [yellow]n â† 1[/yellow];
  [yellow]q â† ceil(j / (kâˆ’1))[/yellow];
  [pink]while[/pink] [yellow](n â‰¤ q)[/yellow] [pink]do[/pink] {
    [yellow]read kâˆ’1 subfiles[/yellow];
    [yellow]merge and write[/yellow];
    [yellow]n â† n + 1[/yellow];
  }
  [yellow]j â† q[/yellow];
  [yellow]i â† i + 1[/yellow];
}

84. Cost of Sort-Merge Algorithm
ğ–¦¹ Approximate cost = (2 * b) + (2 * b * (log_dM nR)).
ğ–¦¹ First term: reading + writing during sorting phase.
ğ–¦¹ Second term: reading + writing during each merge pass.

85. Worst-Case Performance
ğ–¦¹ Minimum buffers required: nB = 3.
ğ–¦¹ Then dM = 2.
ğ–¦¹ Cost becomes: (2 * b) + (2 * b * logâ‚‚(nR)).

86. Algorithms for SELECT operation
ğ–¦¹ SELECT is a search to find records that satisfy a condition.
ğ–¦¹ Some algorithms require specific access paths.
ğ–¦¹ Example operations: OP1 to OP7.
â€¢ OP1: ÏƒSsn = â€˜123456789â€™ (EMPLOYEE)
â€¢ OP2: ÏƒDnumber > 5 (DEPARTMENT)
â€¢ OP3: ÏƒDno = 5 (EMPLOYEE)
â€¢ OP4: ÏƒDno = 5 AND Salary > 30000 AND Sex = â€˜Fâ€™ (EMPLOYEE)
â€¢ OP5: ÏƒEssn = â€˜123456789â€™ AND Pno = 10 (WORKS_ON)
â€¢ OP6: SELECT * FROM EMPLOYEE WHERE Dno IN (3,27,49)
â€¢ OP7: SELECT First_name, Lname FROM Employee WHERE ((Salary*Commission_pct)+Salary)>15000

87. Search methods for simple selection (file scans)
ğ–¦¹ S1: Linear search. Scan all blocks, test each record.
ğ–¦¹ S2: Binary search. Used only if file is ordered on key. Example: OP1 if ordered on Ssn.
ğ–¦¹ S3a: Use primary index for equality on key. Example: Ssn='123456789'.
ğ–¦¹ S3b: Use hash key for equality on key. Example: Ssn='123456789'.
ğ–¦¹ S4: Primary index for ranges. Example: Dnumber > 5 retrieves records after Dnumber=5.
ğ–¦¹ S5: Clustering index for equality on nonkey. Example: Dno=5 retrieves all matching records.
ğ–¦¹ S6: Secondary B+-tree index. Supports equality and range queries.
â€¢ Range example: 3000 <= Salary <= 4000.
ğ–¦¹ S7a: Bitmap index. OR bitmaps for values. Example: Dnumber IN (3,27,49) in OP6.
ğ–¦¹ S7b: Functional index. Supports expression-based selection.
â€¢ Example functional index:
[pink]CREATE[/pink] [pink]INDEX[/pink] [yellow]income_ix[/yellow]
[pink]ON[/pink] [yellow]EMPLOYEE (Salary + (Salary*Commission_pct))[/yellow]

88. Notes on index-based methods
ğ–¦¹ S1 works always.
ğ–¦¹ S2 needs sorted file.
ğ–¦¹ S3â€“S6 need indexes.
ğ–¦¹ S4 and S6 handle range queries.
ğ–¦¹ S7a for enumerated sets.
ğ–¦¹ S7b for functional attribute matches.

89. Search methods for conjunctive selection (AND conditions)
ğ–¦¹ For OP4, DBMS may use extra methods.
ğ–¦¹ S8: Use index on one attribute, then test other conditions.
ğ–¦¹ S9: Use composite index if equality conditions match composite key.
â€¢ Example: Index on (Essn, Pno) for OP5.
ğ–¦¹ S10: Intersection of record pointers from multiple secondary indexes.
â€¢ Each index returns pointers; intersect them to find qualifying records.
â€¢ Bitmap and functional indexes can also be AND-ed.

90. Choosing access paths for conjunctive selection
ğ–¦¹ If only one condition has an access path, use it.
ğ–¦¹ Otherwise, S1 is fallback.
ğ–¦¹ Optimizer tries to retrieve fewest records at lowest cost.

91. Search methods for disjunctive selection (OR conditions)
ğ–¦¹ Harder to optimize than AND conditions.
ğ–¦¹ Example: OP4â€² = (Dno=5 OR Salary>30000 OR Sex='F').
ğ–¦¹ Records satisfying OR are union of results.
ğ–¦¹ If any condition lacks an access path â†’ must use linear scan.
ğ–¦¹ If all conditions have access paths â†’ combine their record id sets using union.

92. Estimating selectivity
ğ–¦¹ Optimizer uses catalog statistics to estimate cost.
ğ–¦¹ Catalog stores:
â€¢ Number of records |r(R)|
â€¢ Tuple width
â€¢ Number of blocks bR
â€¢ Blocking factor bfr
â€¢ Distinct values NDV(A,R)
â€¢ min/max values for attributes
ğ–¦¹ Selectivity sl = qualifying_records / total_records.

93. Selectivity estimation examples
ğ–¦¹ Equality on key: sl = 1 / |r(R)|.
ğ–¦¹ Equality on nonkey with i distinct values: sl = 1/i.
ğ–¦¹ Range A â‰¥ v:
â€¢ sl = 0 if v > max(A,R)
â€¢ sl = (max(A,R) âˆ’ v) / (max(A,R) âˆ’ min(A,R))
ğ–¦¹ Estimated qualifying records = |r(R)| * sl.

94. Non-uniform distribution issues
ğ–¦¹ NDV-based estimation assumes uniform distribution.
ğ–¦¹ Real data often non-uniform.
ğ–¦¹ Histograms in catalog provide more accurate estimates.

95. Implementing the JOIN operation
ğ–¦¹ JOIN is one of the most expensive operations in query processing.
ğ–¦¹ Focus is on EQUIJOIN and NATURAL JOIN; join here means one of these.
ğ–¦¹ Two-way join is between two files; multiway joins become complex due to many possible join orders.
ğ–¦¹ General join form: R A=B S
â€¢ A and B must be domain-compatible attributes of R and S.
ğ–¦¹ Techniques discussed apply mainly to two-way joins but extend to general join forms.
ğ–¦¹ Example operations:
â€¢ OP6: EMPLOYEE Dno=Dnumber DEPARTMENT
â€¢ OP7: DEPARTMENT Mgr_ssn=Ssn EMPLOYEE

96. Methods for Implementing Joins
ğ–¦¹ J1â€”Nested-loop join (or nested-block join)
â€¢ Default brute-force method; no special access paths required.
- For each record t in R (outer loop), check every record s in S (inner loop) for t[A] = s[B].

ğ–¦¹ J2â€”Index-based nested-loop join
â€¢ Uses index or hash key on one join attribute (e.g., B of S).
- For each record t in R, retrieve matching records s from S using index: s[B] = t[A].

ğ–¦¹ J3â€”Sort-merge join
â€¢ Requires R and S to be sorted by join attributes A and B.
- Scan both files concurrently to match records with equal A and B values.
â€¢ If unsorted, use external sorting first.
â€¢ Variation: use secondary indexes to access records in join order.
- Inefficiency: physical scattering of records may require multiple disk accesses.

ğ–¦¹ J4â€”Partition-hash join (hash-join)
â€¢ Partition R and S using same hash function h on A (R) and B (S).
â€¢ Partitioning phase: smaller file R is hashed into memory buckets.
â€¢ Probing phase: hash S records to appropriate bucket and combine with R.
- Simplified assumption: smaller file fits entirely in memory; general case removes this restriction.
â€¢ Implementation reads disk blocks, not individual records, adjusting to memory buffers.

ğ–¦¹ Sort-merge join algorithm example
â€¢ Sort R by A and S by B.
â€¢ Set i â†1, j â† 1; while i â‰¤ n and j â‰¤ m
â€¢ Compare R(i)[A] and S(j)[B]:
- If R(i)[A] > S(j)[B], j â† j + 1
- If R(i)[A] < S(j)[B], i â† i + 1
- If equal:
â€¢ Output <R(i), S(j)> to T
â€¢ Check for additional matching tuples in R and S
â€¢ Increment i, j accordingly

ğ–¦¹ Projection with duplicate elimination
â€¢ Create Tâ€² with projected attributes from R.
- If attribute list includes key of R, T â† Tâ€²
- Else: sort Tâ€² and eliminate duplicates using indices i, j.

ğ–¦¹ Set operations with sort-merge
â€¢ UNION: sort R, S; compare tuples; output unique tuples to T.
â€¢ INTERSECTION: sort R, S; output tuples present in both.
â€¢ SET DIFFERENCE: sort R, S; output tuples in R not in S.

97. Buffer Space and Outer-Loop Choice in Nested-Loop Join
ğ–¦¹ Available buffer space affects join performance, especially in nested-loop join (J1).
â€¢ Example: nB = 7 buffers, DEPARTMENT: rD = 50 records, bD = 10 blocks, EMPLOYEE: rE = 6,000 records, bE = 2,000 blocks.
- Outer loop should use the file with fewer blocks for efficiency.
â€¢ Inner loop reads one block at a time; matched records are stored in result buffer.
- Result buffer is written to disk when full and reused.

ğ–¦¹ Disk block calculations
â€¢ EMPLOYEE as outer loop: total block accesses = bE + (â¡bE/(nB-2)â¤ * bD) = 2000 + (â¡2000/5â¤ * 10) = 6000
â€¢ DEPARTMENT as outer loop: total block accesses = bD + (â¡bD/(nB-2)â¤ * bE) = 10 + (â¡10/5â¤ * 2000) = 4010
- Writing result file: add bRES block accesses.

98. Join Selection Factor and Performance
ğ–¦¹ Join selection factor affects performance of index-based nested-loop join (J2).
â€¢ Example OP7: DEPARTMENT joined with EMPLOYEE for manager.
â€¢ Two options:
- Retrieve each EMPLOYEE, use index on DEPARTMENT: bE + (rE * (xMgr_ssn + 1)) = 2000 + 6000*3 = 20,000
- Retrieve each DEPARTMENT, use index on EMPLOYEE: bD + (rD * (xSsn + 1)) = 10 + 50*5 = 260
- More efficient: use smaller file or file with high join selection factor.
â€¢ Index can be created specifically for join if none exists.

99. Sort-Merge Join Performance
ğ–¦¹ Efficient if both files are sorted by join attributes.
â€¢ Single pass through each file; block accesses = bE + bD = 2,010
- If unsorted, need to sort files: total cost â‰ˆ bE + bD + bE log2 bE + bD log2 bD

100. General Partition-Hash Join
ğ–¦¹ Files R and S partitioned into M partitions using same hash function on join attributes.
â€¢ Partitioning phase:
- M buffers for partitions + 1 buffer for input file.
- Records hashed to memory buffer, appended to disk subfile if buffer full.
â€¢ Joining/probing phase:
- For each partition pair Ri, Si, use nested-loop join or in-memory hash table for smaller partition.
â€¢ Cost approximation: 3*(bR + bS) + bRES
- Uniform hash function required to avoid skew.

101. Hybrid Hash-Join
ğ–¦¹ Variation of partition-hash join; joining phase for one partition included in partitioning.
â€¢ Example OP6: smaller file DEPARTMENT.
- First partition resides entirely in memory; others on disk.
â€¢ Second file EMPLOYEE:
- Records hashing to first partition joined immediately.
- Records hashing to other partitions written to disk.
â€¢ Result: M-1 iterations needed in joining phase instead of M.
- Saves disk I/O by joining as many records as possible during partitioning phase.

102. PROJECT Operation Algorithms
ğ–¦¹ PROJECT Ï€<attribute list>(R) selects only specified columns and removes duplicates.
â€¢ If <attribute list> includes a key, the result has same number of tuples as R.
â€¢ If <attribute list> does not include a key, duplicates must be removed.
- Duplicate elimination can be done by sorting and removing consecutive duplicates or using hashing in memory.
- SQL by default does not remove duplicates; DISTINCT keyword is required.

103. Set Operations Algorithms
ğ–¦¹ Set operations include UNION, INTERSECTION, SET DIFFERENCE (MINUS/EXCEPT), and CARTESIAN PRODUCT.
â€¢ CARTESIAN PRODUCT R Ã— S produces n * m records with j + k attributes; expensive to compute.
- Prefer using join instead of CARTESIAN PRODUCT during query optimization.
â€¢ UNION, INTERSECTION, SET DIFFERENCE require type-compatible relations.
- Implemented using sort-merge: sort both relations and scan concurrently.
- For UNION: keep one copy if tuple exists in both relations.
- For INTERSECTION: keep only tuples present in both relations.
â€¢ Hashing can also implement these operations:
- For R âˆª S: hash R, probe S, avoid duplicates.
- For R âˆ© S: hash R, probe S, keep only matching records.
- For R â€“ S: hash R, probe S, remove matching records from R.

104. Anti-Join for SET DIFFERENCE
ğ–¦¹ MINUS or EXCEPT in SQL can be implemented using anti-join.
â€¢ Example:
- SQL: SELECT Dnumber FROM DEPARTMENT MINUS SELECT Dno FROM EMPLOYEE
- Anti-join conversion:
[pink]SELECT[/pink] [yellow]DISTINCT DEPARTMENT.Dnumber[/yellow]
[pink]FROM[/pink] [yellow]DEPARTMENT, EMPLOYEE[/yellow]
[pink]WHERE[/pink] [yellow]DEPARTMENT.Dnumber A = EMPLOYEE.Dno[/yellow]
- "A=" represents anti-join: left table DEPARTMENT, right table EMPLOYEE.

ğ–¦¹ SQL variations for sets and multisets:
â€¢ UNION, INTERSECTION, EXCEPT/MINUS: eliminate duplicates.
â€¢ UNION ALL, INTERSECTION ALL, EXCEPT ALL: retain duplicates (multisets).
- Example with INTERSECT ALL:
[pink]SELECT[/pink] [yellow]Dno[/yellow] [pink]FROM[/pink] [yellow]EMPLOYEE[/yellow]
[pink]INTERSECT ALL[/pink]
[pink]SELECT[/pink] [yellow]Dum[/yellow] [pink]FROM[/pink] [yellow]PROJECT[/yellow]
- Semi-join can implement INTERSECT ALL while controlling duplicates:
[pink]SELECT[/pink] [yellow]DISTINCT EMPLOYEE.Dno[/yellow]
[pink]FROM[/pink] [yellow]DEPARTMENT, EMPLOYEE[/yellow]
[pink]WHERE[/pink] [yellow]EMPLOYEE.Dno S = DEPARTMENT.Dnumber[/yellow]

104. Implementing Aggregate Operations
ğ–¦¹ Aggregate operators (MIN, MAX, COUNT, AVERAGE, SUM) can be computed via table scan or using indexes.
â€¢ MAX(Salary) can be retrieved efficiently using a B+-tree index by following the rightmost pointer from root to leaf.
â€¢ MIN(Salary) uses the leftmost pointer in a B+-tree index.
â€¢ SUM and AVERAGE can use a dense index where each record has an index entry.
- For non-dense indexes, count of records per index value is needed.
â€¢ COUNT(*) can be retrieved from catalog without scanning the table.
â€¢ GROUP BY requires partitioning tuples by the grouping attribute using sorting or hashing.
- Aggregates are then applied to each group.
â€¢ If a clustering index exists on the grouping attribute, records are already grouped.

105. Implementing Different Types of JOINs
ğ–¦¹ Variations of JOIN include outer joins, semi-joins, and anti-joins.

ğ–¦¹ Outer Joins
â€¢ Types: left outer join, right outer join, full outer join.
â€¢ Example of left outer join:
[pink]SELECT[/pink] [yellow]E.Lname, E.Fname, D.Dname[/yellow]
[pink]FROM[/pink] [yellow]EMPLOYEE E LEFT OUTER JOIN DEPARTMENT D ON E.Dno = D.Dnumber[/yellow]
- Includes all tuples from left table; unmatched tuples have NULLs in right table fields.
â€¢ Can be computed by modifying join algorithms (nested-loop, single-loop, sort-merge, hash-join).
â€¢ Algebraic approach:
1. TEMP1 â† Ï€Lname, Fname, Dname (EMPLOYEE Dno=Dnumber DEPARTMENT)
2. TEMP2 â† Ï€Lname, Fname (EMPLOYEE) âˆ’ Ï€Lname, Fname (TEMP1)
- Step 2 uses anti-join to find unmatched tuples.
3. TEMP2 â† TEMP2 Ã— NULL
4. RESULT â† TEMP1 âˆª TEMP2
- Right outer join can be converted to left outer join by switching operands.
- Full outer join pads unmatched tuples from both relations.

ğ–¦¹ Semi-Join and Anti-Join
â€¢ Semi-join: selects outer tuple as soon as first match is found in inner relation.
â€¢ Anti-join: rejects outer tuple as soon as first match is found.
- Can be implemented as extensions of standard join algorithms.

ğ–¦¹ Non-Equi-Join (Theta-Join)
â€¢ Join condition uses inequality operators (<, >, â‰¥, â‰¤, â‰ ).
- All join methods except hash-based algorithms are applicable.

106. Combining Operations Using Pipelining
ğ–¦¹ Materialized evaluation executes one operation at a time, storing intermediate results on disk.
- This creates excessive overhead and delays query processing.
ğ–¦¹ Pipelining avoids storing temporary files by combining multiple operations into a single algorithm.
â€¢ Example: JOIN combined with two SELECT operations and a final PROJECT operation can produce one result file directly.
ğ–¦¹ Pipelined evaluation allows output tuples from one operation to be fed immediately to the next operation.
- Benefits:
  â€¢ Reduces cost and time of writing intermediate results to disk.
  â€¢ Allows early generation of result tuples while other operations continue processing.

107. Iterators for Implementing Physical Operations
ğ–¦¹ Iterators output one tuple at a time instead of generating full relations as temporary files.
â€¢ This contrasts with materialization where entire relations are stored and read back.
ğ–¦¹ Query plan execution invokes iterators in a specific order, allowing multiple iterators to be active simultaneously.
ğ–¦¹ Iterator interface methods:
1. [pink]Open()[/pink]
- Initializes operator, allocates buffers, initializes data structures, and passes selection conditions.
2. [pink]Get_Next()[/pink]
- Calls [pink]Get_Next()[/pink] on input arguments, applies operation-specific code, returns next output tuple, updates iterator state.
3. [pink]Close()[/pink]
- Ends iteration, calls [pink]Close()[/pink] on input arguments.
ğ–¦¹ Iterators can be implemented as classes with these methods.
- Pipelining is effective if tuples can be processed completely as received.
- If multiple passes over input are required, materialization is needed, reducing pipelining benefit.
ğ–¦¹ Iterators can also be applied to access methods.
- Example: B+-tree or hash-based index can be implemented as an iterator producing tuples that meet selection conditions passed to [pink]Open()[/pink].

108. Query Optimization Overview
ğ–¦¹ Goal of query optimization is to select the most efficient and cost-effective strategy for query execution.
- Optimization does not guarantee the absolute best plan; it aims for the best available plan using schema and content information in reasonable time.
ğ–¦¹ Query optimization is performed by a query optimizer in a DBMS to choose the best execution strategy.

109. Query Representation and Transformation
ğ–¦¹ Queries are mapped from SQL into query trees and graphs; most RDBMSs use internal tree representation.
ğ–¦¹ Heuristics are applied to transform queries into more efficient equivalent forms.
ğ–¦¹ General procedure exists for applying these heuristics to optimize queries.

110. Conversion to Execution Plans
ğ–¦¹ Queries are converted into execution plans.
ğ–¦¹ Nested subquery optimization is considered.
ğ–¦¹ Query transformations include:
â€¢ Merging views in Group By queries.
â€¢ Transforming Star Schema queries in data warehouses.
ğ–¦¹ Materialized views are briefly discussed as part of optimization.

111. Selectivity and Result-Size Estimation
ğ–¦¹ Cost-based approach to query optimization is used.
ğ–¦¹ System catalog information is leveraged to estimate selectivity and result sizes.
ğ–¦¹ Histograms are used to aid in estimation.

112. Cost Models
ğ–¦¹ Cost models are presented for selection and join operations.
ğ–¦¹ Join ordering problem is discussed in detail as a critical aspect of query optimization.

113. Example of Cost-Based Optimization
ğ–¦¹ Demonstrates how cost-based optimization is applied in practice.

114. Additional Issues in Query Optimization
ğ–¦¹ Various other considerations affecting optimization are discussed.

115. Query Optimization in Data Warehouses
ğ–¦¹ Specialized techniques and considerations for optimizing queries in data warehouse environments.
Query Optimization in Oracle
ğ–¦¹ Overview of Oracle-specific query optimization approaches.
Semantic Query Optimization
ğ–¦¹ Brief discussion of using semantic information to optimize queries.

116. Query Trees and Heuristics for Query Optimization
ğ–¦¹ Heuristic rules are applied to the internal representation of a query to improve performance.
ğ–¦¹ SQL queries are first parsed into a data structure (query tree or query graph) and then optimized.
ğ–¦¹ Optimized query representation determines the query execution strategy.
ğ–¦¹ Query execution plans are generated based on access paths of the files involved.
ğ–¦¹ Main heuristic: Apply SELECT and PROJECT operations before JOIN or other binary operations to reduce file size and improve efficiency.

117. Notation for Query Trees and Query Graphs
ğ–¦¹ A query tree represents an extended relational algebra expression.
â€¢ Leaf nodes represent input relations of the query.
â€¢ Internal nodes represent relational algebra operations.
- Execution starts from leaf nodes and proceeds to root, producing the final result relation.
IMG_URL query_tree.png
ğ–¦¹ A query graph represents a relational calculus expression.
â€¢ Relation nodes are displayed as single circles.
â€¢ Constant nodes are displayed as double circles or ovals.
â€¢ Selection and join conditions are represented by edges.
â€¢ Attributes to retrieve are shown in square brackets.
ğ–¦¹ Query graph does not specify the order of operations; query trees indicate execution order.

118. Example: Query Q2
ğ–¦¹ Task: Retrieve project number, controlling department number, and department managerâ€™s last name, address, and birthdate for projects located in â€˜Staffordâ€™.
ğ–¦¹ Relational algebra expression:
â€¢ Ï€Pnumber, Dnum, Lname, Address, Bdate (((ÏƒPlocation=â€˜Staffordâ€™([yellow]PROJECT[/yellow]))
 Dnum=Dnumber([yellow]DEPARTMENT[/yellow])) Mgr_ssn=Ssn([yellow]EMPLOYEE[/yellow]))
ğ–¦¹ SQL query:
â€¢ [pink]SELECT[/pink] P.Pnumber, P.Dnum, E.Lname, E.Address, E.Bdate
  [pink]FROM[/pink] [yellow]PROJECT[/yellow] P, [yellow]DEPARTMENT[/yellow] D, [yellow]EMPLOYEE[/yellow] E
  [pink]WHERE[/pink] P.Dnum=D.Dnumber AND D.Mgr_ssn=E.Ssn AND P.Plocation='Stafford';
ğ–¦¹ Execution order in query tree:
â€¢ Node (1) executes before node (2) because its resulting tuples are needed.
â€¢ Node (2) executes before node (3), and so on.

119. Advantages of Query Trees
ğ–¦¹ Query trees explicitly show the order of operations for execution.
ğ–¦¹ More practical than query graphs for optimizers since they need to indicate execution sequence.
ğ–¦¹ Query graphs are neutral and useful for representation but do not indicate operation order.

120. Heuristic Optimization of Query Trees
ğ–¦¹ Many relational algebra expressions and query trees can be semantically equivalent.
ğ–¦¹ The initial query tree generated by the parser is a standard canonical tree, often inefficient due to CARTESIAN PRODUCT operations.
IMG_URL query_optim1.png
ğ–¦¹ Heuristic query optimizer transforms the initial tree into an efficient final query tree.
IMG_URL query_optim2.png
ğ–¦¹ Optimizer applies rules for equivalence among relational algebra expressions to ensure the transformed tree produces the same result.

121. Example of Query Transformation
ğ–¦¹ Query: Find last names of employees born after 1957 who work on project â€˜Aquariusâ€™.
â€¢ SQL: [pink]SELECT[/pink] E.Lname [pink]FROM[/pink] [yellow]EMPLOYEE[/yellow] E, [yellow]WORKS_ON[/yellow] W, [yellow]PROJECT[/yellow] P [pink]WHERE[/pink] P.Pname='Aquarius' AND P.Pnumber=W.Pno AND E.Essn=W.Ssn AND E.Bdate>'1957-12-31';
ğ–¦¹ Initial query tree creates a large CARTESIAN PRODUCT of all relations.
ğ–¦¹ Step-by-step improvements:
â€¢ Apply SELECT operations early to reduce tuples.
â€¢ Reorder EMPLOYEE and PROJECT relations using key attribute info.
â€¢ Replace CARTESIAN PRODUCT followed by SELECT with JOIN operations.
â€¢ Apply PROJECT operations early to reduce columns in intermediate relations.

122. Transformation Rules for Relational Algebra
ğ–¦¹ Cascade of Ïƒ: Break conjunctive selection into sequence of Ïƒ operations.
ğ–¦¹ Commutativity of Ïƒ: Ïƒc1(Ïƒc2(R)) â‰¡ Ïƒc2(Ïƒc1(R))
ğ–¦¹ Cascade of Ï€: Only last Ï€ matters; earlier ones can be ignored.
ğ–¦¹ Commuting Ïƒ with Ï€: If Ïƒ involves attributes in projection, they can be swapped.
ğ–¦¹ Commutativity of join and Ã—: R [pink]JOIN[/pink]c S â‰¡ S [pink]JOIN[/pink]c R ; R Ã— S â‰¡ S Ã— R
ğ–¦¹ Commuting Ïƒ with join or Ã—: Ïƒc(R [pink]JOIN[/pink]c S) â‰¡ (Ïƒc(R)) [pink]JOIN[/pink]c S
ğ–¦¹ Commuting Ï€ with join or Ã—: Ï€L(R [pink]JOIN[/pink]c S) â‰¡ (Ï€A(R)) [pink]JOIN[/pink]c (Ï€B(S)) with adjustments for join attributes.
ğ–¦¹ Commutativity of set operations: âˆª and âˆ© are commutative; âˆ’ is not.
ğ–¦¹ Associativity of [pink]JOIN[/pink], Ã—, âˆª, âˆ©: (R Î¸ S) Î¸ T â‰¡ R Î¸ (S Î¸ T)
ğ–¦¹ Commuting Ïƒ with set operations: Ïƒc(R Î¸ S) â‰¡ (Ïƒc(R)) Î¸ (Ïƒc(S))
ğ–¦¹ Ï€ operation commutes with âˆª: Ï€L(R âˆª S) â‰¡ (Ï€L(R)) âˆª (Ï€L(S))
ğ–¦¹ Converting Ïƒ following Ã— into JOIN: Ïƒc(R Ã— S) â‰¡ R [pink]JOIN[/pink]c S
ğ–¦¹ Pushing Ïƒ with âˆ’ or âˆ©: Apply Ïƒc to only relevant relation(s).
ğ–¦¹ Trivial transformations: R âˆª âˆ… = R ; Ïƒtrue(R) = R
ğ–¦¹ Boolean algebra rules: NOT(c1 AND c2) â‰¡ (NOT c1) OR (NOT c2); NOT(c1 OR c2) â‰¡ (NOT c1) AND (NOT c2)

123. Heuristic Algebraic Optimization Algorithm
ğ–¦¹ Step 1: Break conjunctive SELECT operations into a cascade of individual Ïƒ operations.
ğ–¦¹ Step 2: Move each SELECT operation down the tree using commutativity rules.
â€¢ If condition involves one table, move to leaf node of that table.
â€¢ If condition involves two tables (join), move after tables are combined.
ğ–¦¹ Step 3: Rearrange leaf nodes using commutativity and associativity rules.
â€¢ Execute most restrictive SELECT operations first (fewest tuples or smallest size).
â€¢ Avoid unnecessary CARTESIAN PRODUCT operations.
ğ–¦¹ Step 4: Combine CARTESIAN PRODUCT with SELECT into JOIN if condition represents a join.
ğ–¦¹ Step 5: Move PROJECT operations down the tree.
â€¢ Keep only attributes needed for subsequent operations.
ğ–¦¹ Step 6: Identify subtrees that can be executed by a single algorithm and group operations.

124. Summary of Heuristics
ğ–¦¹ Apply operations that reduce intermediate result size early: SELECT for tuples, PROJECT for attributes.
ğ–¦¹ Execute the most restrictive SELECT and JOIN operations first.
ğ–¦¹ Reorder leaf nodes carefully to avoid Cartesian products while maintaining efficiency.

125. Choice of Query Execution Plans
ğ–¦¹ Alternatives for Query Evaluation
â€¢ An execution plan contains access methods for each relation and algorithms for relational operators.
- Example: Query Q1: Ï€Fname, Lname, Address(ÏƒDname='Research'(DEPARTMENT) Dnumber=Dno EMPLOYEE)
- Optimizer choices: index search for SELECT, index-based nested-loop join, scan for PROJECT.
â€¢ Materialized vs Pipelined evaluation
- Materialized: store operation result as temporary relation, then read for next operation.
- Pipelined: forward tuples directly to next operation, reducing disk I/O.
â€¢ Query tree transformations
- Heuristic-based or cost-based methods optimize execution time and resources.
â€¢ Nested subqueries in WHERE or FROM
- Correlated subquery: inner references outer relation.
- FROM subquery: acts like a view.
- Optimizer transforms and rewrites nested subqueries.

126. Nested Subquery Optimization
ğ–¦¹ Evaluation strategy
â€¢ Outer query uses value from inner query (e.g., MAX(Salary)).
- Efficient methods: use index or catalog if available; otherwise linear search.
â€¢ Correlated subqueries
- Inner query depends on outer query variables.
- Example: EXISTS (SELECT * FROM DEPARTMENT D WHERE D.Dnumber = E.Dno AND D.Zipcode=30332)
- NaÃ¯ve evaluation: inner query executed per outer tuple (inefficient)
- Optimizer converts nested subquery to join (unnesting).
â€¢ Semi-join
- Used when inner join would produce extra tuples.
- Example: IN operator converted using semi-join.
- Anti-join: used for NOT IN connectors.
- Unnesting/decorrelation improves performance for complex nested queries.

127. Subquery (View) Merging Transformation
ğ–¦¹ Inline view or predefined view in FROM clause
â€¢ Optimizer can merge view with outer query to enable more join orders and index usage.
- Example: EMP, DEPT, BLDG joined with inline view V can be merged into single query joining all three tables.
â€¢ GROUP-BY view merging
- Decision to merge depends on optimizer cost estimation.
- Early vs delayed Group By: early reduces data for joins, delayed may reduce grouping cost.
- Example: SALES, CUST, PRODUCT with CP_BOUGHT_VIEW materialized or merged for efficient query execution.

128. Materialized Views
ğ–¦¹ Concept
â€¢ Stores result of a query to avoid recomputation.
â€¢ Useful for expensive operations like join and aggregation.
â€¢ Can be temporary or permanent.
ğ–¦¹ Update strategies
â€¢ Immediate: update view on any base relation change.
â€¢ Lazy: recompute only on demand.
â€¢ Periodic: update at regular intervals.
â€¢ Triggers may automate updates.
ğ–¦¹ Incremental View Maintenance
â€¢ Update view only with net changes from inserted/deleted tuples.
â€¢ Join: vnew = (r âˆª ri) â¨ s or adjust for deletions.
â€¢ Selection: vnew = vold âˆª ÏƒC ri or vnew = vold âˆ’ ÏƒC rd.
â€¢ Projection: maintain counts for tuples; update on insert/delete.
â€¢ Intersection: insert if in other relation; delete if present.
â€¢ Aggregation (Group By)
- Count: increment/decrement per group.
- Sum: maintain sum and count per group; adjust on insert/delete.
- Average: maintain sum and count to compute average.
- Max/Min: track max value and count; recompute if max deleted.
ğ–¦¹ Use in queries
â€¢ Replace query components with materialized view to save computation.
â€¢ Example: using view for R â¨ S or Ï€LR to avoid recomputation; indexes may further optimize access.
