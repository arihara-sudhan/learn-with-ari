--BEGIN--09/12/2025--ADVANCED ARRAYS--
1. Sparse Arrays
ð–¦¹ Sparse array is an array where most positions are empty (zero or no value)
ð–¦¹ Example: array of size 1 million, but only 5 positions have non-zero values
ð–¦¹ Problem: storing all positions wastes memory
ð–¦¹ Idea: store only non-empty values with their positions
ð–¦¹ Why use it:
â€¢ Saves memory
â€¢ Faster for some operations
â€¢ Good when data is mostly empty
ð–¦¹ IMPLEMENTATION IDEAS
â€¢ List of (index, value) pairs
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/advanced-arrays/sparse_array_list_of_kv.cpp
â€¢ Two Arrays: one for indexes, one for values
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/advanced-arrays/sparse_array_two_lists.cpp
â€¢ Linked list representation
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/advanced-arrays/sparse_array_linked_list.cpp
â€¢ Compressed formats (CSR, CSC for matrices)
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/advanced-arrays/sparse_array_matrix_csr.cpp
--END--
--BEGIN--23/11/2025--LINKED LISTS--
1. Arrays and their limitations
ð–¦¹ Arrays store elements one after another in memory, i.e., sequentially
ð–¦¹ Limitations of arrays:
â€¢ Fixed size
- To change the size, you must create a new array and copy all data.
â€¢ Sequential memory
- Elements are next to each other in memory.
- Inserting in the middle requires shifting other elements, which is slow.

2. Linked structures
ð–¦¹ Used to overcome array limitations.
ð–¦¹ Made of nodes, where each node has:
â€¢ Data
- The value you want to store.
â€¢ Reference(s)
- Links to other nodes.
ð–¦¹ Nodes can be anywhere in memory.
ð–¦¹ You move from one node to another using links.

3. Singly Linked List (SLL)
ð–¦¹ Each node has a link only to its next node (successor).
ð–¦¹ Nodes are connected like a chain.
ð–¦¹ Access the list using one variable pointing to the first node.
ð–¦¹ Last node points to null to indicate the end of the list.
IMG_URL sll.png

4. Singly Linked List (SLL) implementation
ð–¦¹ Demonstrates creating and linking nodes in a singly linked list.
ð–¦¹ Code example:
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/linked-list/sll.cpp

5. Adding a Node to Singly Linked List
ð–¦¹ A singly linked list has a head pointer pointing to the first node.
ð–¦¹ Each node stores data and a pointer to the next node.

6. Deleting a Node from Singly Linked List
ð–¦¹ A singly linked list has a head pointer pointing to the first node.
ð–¦¹ Each node stores data and a pointer to the next node.
ð–¦¹ Example C++ implementation:

[pink]#include[/pink] [yellow]<iostream>[/yellow]
[yellow]using namespace std;[/yellow]

[pink]class[/pink] SLLNode {
    [pink]public[/pink]:
        [pink]int[/pink] data;
        SLLNode* next;
        SLLNode([pink]int[/pink] data, SLLNode* next = [green]nullptr[/green]) {
            this->data = data;
            this->next = next;
        }
};

[pink]class[/pink] SinglyLinkedList {
    [pink]private[/pink]:
        SLLNode* head;
    [pink]public[/pink]:
        SinglyLinkedList() {
            head = [green]nullptr[/green];
        }
        ~SinglyLinkedList() {  // destructor to free memory
            SLLNode* temp = head;
            while(temp != [green]nullptr[/green]) {
                SLLNode* nextNode = temp->next;
                [pink]delete[/pink] temp;
                temp = nextNode;
            }
        }
        void printAll() {
            SLLNode* temp = head;
            while(temp != [green]nullptr[/green]) {
                [green]cout[/green] << temp->data << "->";
                temp = temp->next;
            }
            [green]cout[/green] << "END\n";
        }
        void addNode([pink]int[/pink] value) {
            SLLNode* newNode = [pink]new[/pink] SLLNode(value);
            if(head == [green]nullptr[/green]) {
                head = newNode;
            } else {
                SLLNode* temp = head;
                while(temp->next != [green]nullptr[/green]) {
                    temp = temp->next;
                }
                temp->next = newNode;
            }
        }
        void deleteNode([pink]int[/pink] value) {
            if(head == [green]nullptr[/green]) {
                [green]cout[/green] << "NOTHING TO DELETE\n";
            } else {
                SLLNode* temp = head;
                SLLNode* prev = [green]nullptr[/green];
                while(temp != [green]nullptr[/green] && temp->data != value) {
                    prev = temp;
                    temp = temp->next;
                }
                if(temp == [green]nullptr[/green]) {
                    [green]cout[/green] << "DATA NOT THERE\n";
                } else if(temp == head) {
                    head = head->next;
                } else {
                    prev->next = temp->next;
                }
                [pink]delete[/pink] temp;
            }
        }
};

[pink]int[/pink] [pink]main[/pink]() {
    SinglyLinkedList sll;
    sll.addNode(1);
    sll.addNode(2);
    sll.addNode(3);
    sll.printAll();
    sll.deleteNode(1);
    sll.printAll();
    sll.deleteNode(11);
    [pink]return[/pink] 0;
}

ð–¦¹ [pink]deleteNode[/pink] searches for the node with given value.
ð–¦¹ If the list is empty, it prints "NOTHING TO DELETE".
ð–¦¹ If the value is not found, it prints "DATA NOT THERE".
ð–¦¹ If the node is the head, update head to next node.
ð–¦¹ Otherwise, update previous node's next to skip the deleted node.
ð–¦¹ The destructor frees all nodes to avoid memory leaks.

7. Singly Linked List Operations and Complexity
ð–¦¹ Insertion at head: O(1)
â€¢ Create a new node and point it to the current head.
- Very fast because no traversal is needed.
ð–¦¹ Insertion at tail (without tail pointer): O(n)
â€¢ Traverse from head to the last node.
â€¢ Link the new node after the last node.
- Slower because traversal is needed.
ð–¦¹ Insertion after a given node: O(1)
â€¢ If you have a pointer to the node, link the new node immediately.
- Constant time insertion.
ð–¦¹ Deletion of head node: O(1)
â€¢ Move head pointer to the next node.
â€¢ Delete the old head node.
- Fast because no traversal is needed.
ð–¦¹ Deletion of a node by value: O(n)
â€¢ Traverse the list to find the node with the value.
â€¢ Remove the node and fix links.
- Slower because search may require visiting all nodes.
ð–¦¹ Searching for a value: O(n)
â€¢ Check each node from head to tail.
- Linear time search.

8. What is a DLL?
IMG_URL dll.png
ð–¦¹ A list where each node has two links: next and prev
ð–¦¹ You can move both forward and backward
ð–¦¹ Helpful when you need two-way movement

9. Node structure
ð–¦¹ Each node has:
â€¢ data
â€¢ next pointer â†’ goes to next node
â€¢ prev pointer â†’ goes to previous node
ð–¦¹ First node has prev = NULL
ð–¦¹ Last node has next = NULL

10. Basic picture
ð–¦¹ NULL <- [10] <-> [20] <-> [30] -> NULL
11. Doubly Linked List Operations and Complexity
ð–¦¹ Insertion at head: O(1)
â€¢ Create new node
â€¢ new->next = head
â€¢ head->prev = new
â€¢ head = new
- No need to walk through list
ð–¦¹ Insertion at tail without tail pointer: O(n)
â€¢ Walk from head to last node
â€¢ last->next = new
â€¢ new->prev = last
- Must visit all nodes
ð–¦¹ Insertion at tail with tail pointer: O(1)
â€¢ tail->next = new
â€¢ new->prev = tail
â€¢ tail = new
- Very quick
ð–¦¹ Insertion after a given node: O(1)
â€¢ new->next = node->next
â€¢ new->prev = node
â€¢ Fix next nodeâ€™s prev
â€¢ Fix node->next
- Only pointer updates
ð–¦¹ Insertion before a given node: O(1)
â€¢ new->prev = node->prev
â€¢ new->next = node
â€¢ Fix prev nodeâ€™s next
â€¢ Fix node->prev
- DLL makes â€œinsert beforeâ€ easy
ð–¦¹ Deletion of head: O(1)
â€¢ head = head->next
â€¢ head->prev = NULL
â€¢ delete old head
- Very fast
ð–¦¹ Deletion of tail with tail pointer: O(1)
â€¢ tail = tail->prev
â€¢ tail->next = NULL
â€¢ delete old tail
- No traversal needed
ð–¦¹ Deletion by value: O(n)
â€¢ Walk to find the value
â€¢ Fix next and prev
â€¢ Delete the node
- Search takes linear time
ð–¦¹ Searching for a value: O(n)
â€¢ Move node by node
- Same as singly list
ð–¦¹ Forward traversal: O(n)
â€¢ Use next pointer

ð–¦¹ Backward traversal: O(n)
â€¢ Use prev pointer
- Only DLL can do backward travel

12. Extra Advanced DLL Operations
ð–¦¹ Reverse the list: O(n)
â€¢ Swap next and prev for each node
â€¢ Move head to last node
ð–¦¹ Insert at position k: O(n)
â€¢ Walk to k
â€¢ Insert before or after
ð–¦¹ Delete at position k: O(n)
â€¢ Walk to k
â€¢ Remove the node

13. Memory Usage
ð–¦¹ DLL uses more memory than singly lists
â€¢ data
â€¢ next pointer
â€¢ prev pointer
ð–¦¹ Extra pointer takes more space

14. Advantages of DLL
ð–¦¹ Move in both directions
ð–¦¹ Delete easier because prev exists
ð–¦¹ Insert before any node easily
ð–¦¹ Good for systems like:
â€¢ LRU cache
â€¢ Browser history
â€¢ Undo-redo
â€¢ Playlist navigation
ð–¦¹ Fast tail deletion if tail pointer exists

15. Disadvantages of DLL
ð–¦¹ Uses more memory
ð–¦¹ More complex to code
ð–¦¹ Must update two pointers
ð–¦¹ Mistakes in pointers can break list

16. When to Use DLL
ð–¦¹ Use DLL when:
â€¢ You need two-way movement
â€¢ You want quick delete after finding node
â€¢ You need undo/redo
â€¢ You want LRU cache
â€¢ You need easy navigation
ð–¦¹ Do not use DLL when:
â€¢ You want simple structure
â€¢ Memory must be saved
â€¢ Only forward travel is needed
â€¢ Backward travel not needed

17. Doubly Linked List Example Program
[pink]#include[/pink] <iostream>
[pink]using[/pink] [pink]namespace[/pink] std;

[pink]class[/pink] [yellow]DLLNode[/yellow] {
[pink]public[/pink]:
    [pink]int[/pink] [yellow]data[/yellow];
    [blue]DLLNode*[/blue] [yellow]next[/yellow];
    [blue]DLLNode*[/blue] [yellow]prev[/yellow];

    [yellow]DLLNode[/yellow]([pink]int[/pink] [yellow]data[/yellow],
              [blue]DLLNode*[/blue] [yellow]next[/yellow] = [green]nullptr[/green],
              [blue]DLLNode*[/blue] [yellow]prev[/yellow] = [green]nullptr[/green]) {
        [pink]this[/pink]->[yellow]data[/yellow] = [yellow]data[/yellow];
        [pink]this[/pink]->[yellow]next[/yellow] = [yellow]next[/yellow];
        [pink]this[/pink]->[yellow]prev[/yellow] = [yellow]prev[/yellow];
    }
};

[pink]class[/pink] [yellow]DoublyLinkedList[/yellow] {
[pink]private[/pink]:
    [blue]DLLNode*[/blue] [yellow]head[/yellow];

[pink]public[/pink]:
    [yellow]DoublyLinkedList[/yellow]() {
        [yellow]head[/yellow] = [green]nullptr[/green];
    }

    [pink]~DoublyLinkedList[/pink]() {
        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green]) {
            [blue]DLLNode*[/blue] [yellow]nextNode[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
            [pink]delete[/pink] [yellow]temp[/yellow];
            [yellow]temp[/yellow] = [yellow]nextNode[/yellow];
        }
    }

    [pink]void[/pink] [yellow]printAll[/yellow]() {
        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green]) {
            [green]cout[/green] << [yellow]temp[/yellow]->[yellow]data[/yellow] << " <-> ";
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }
        [green]cout[/green] << "END\n";
    }

    [pink]void[/pink] [yellow]addNode[/yellow]([pink]int[/pink] [yellow]value[/yellow]) {
        [blue]DLLNode*[/blue] [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]DLLNode[/yellow]([yellow]value[/yellow]);

        [pink]if[/pink] ([yellow]head[/yellow] == [green]nullptr[/green]) {
            [yellow]head[/yellow] = [yellow]newNode[/yellow];
            [pink]return[/pink];
        }

        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow]->[yellow]next[/yellow] != [green]nullptr[/green]) {
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }

        [yellow]temp[/yellow]->[yellow]next[/yellow] = [yellow]newNode[/yellow];
        [yellow]newNode[/yellow]->[yellow]prev[/yellow] = [yellow]temp[/yellow];
    }

    [pink]void[/pink] [yellow]deleteNode[/yellow]([pink]int[/pink] [yellow]value[/yellow]) {
        [pink]if[/pink] ([yellow]head[/yellow] == [green]nullptr[/green]) {
            [green]cout[/green] << "NOTHING TO DELETE\n";
            [pink]return[/pink];
        }

        [blue]DLLNode*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]temp[/yellow] != [green]nullptr[/green] &&
               [yellow]temp[/yellow]->[yellow]data[/yellow] != [yellow]value[/yellow]) {
            [yellow]temp[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];
        }

        [pink]if[/pink] ([yellow]temp[/yellow] == [green]nullptr[/green]) {
            [green]cout[/green] << "DATA NOT THERE\n";
            [pink]return[/pink];
        }

        [pink]if[/pink] ([yellow]temp[/yellow] == [yellow]head[/yellow]) {
            [yellow]head[/yellow] = [yellow]head[/yellow]->[yellow]next[/yellow];
            [pink]if[/pink] ([yellow]head[/yellow] != [green]nullptr[/green]) {
                [yellow]head[/yellow]->[yellow]prev[/yellow] = [green]nullptr[/green];
            }
        } [pink]else[/pink] {
            [yellow]temp[/yellow]->[yellow]prev[/yellow]->[yellow]next[/yellow] = [yellow]temp[/yellow]->[yellow]next[/yellow];

            [pink]if[/pink] ([yellow]temp[/yellow]->[yellow]next[/yellow] != [green]nullptr[/green]) {
                [yellow]temp[/yellow]->[yellow]next[/yellow]->[yellow]prev[/yellow] = [yellow]temp[/yellow]->[yellow]prev[/yellow];
            }
        }

        [pink]delete[/pink] [yellow]temp[/yellow];
    }
};

[pink]int[/pink] [yellow]main[/yellow]() {
    [yellow]DoublyLinkedList[/yellow] [yellow]dll[/yellow];

    ;
    ;
    ;

    [yellow]dll[/yellow].[yellow]printAll[/yellow]();

    ;
    [yellow]dll[/yellow].[yellow]printAll[/yellow]();

    ;

    [pink]return[/pink] 0;
}

18. What is a Circularly Linked List (CLL)?
ð–¦¹ Last node points back to first node, forming a loop
ð–¦¹ Each node has data and next pointer
ð–¦¹ Can be singly circular (one next) or doubly circular (next and prev)
ð–¦¹ No true head or tail; can start from any node
ð–¦¹ A cursor node marks starting point for operations

19. Structure
ð–¦¹ Singly Circular:
IMG_URL csll.png
ð–¦¹ Doubly Circular:
IMG_URL cdll.png

21. Key Concepts
ð–¦¹ Cursor marks special node for operations
â€¢ back â†’ element at cursor
â€¢ front â†’ element after cursor
ð–¦¹ Traversal
â€¢ Forward: follow next, eventually cycles back
â€¢ Backward (doubly): follow prev, cycles back
ð–¦¹ Head/Tail Access
â€¢ Singly circular: tail pointer may be enough
â€¢ Tailâ€™s next points to head

22. Advantages of Circular List
ð–¦¹ Useful in round-robin scheduling
ð–¦¹ Can implement playlists, queues, process scheduling
ð–¦¹ In doubly circular, insertion/deletion at both ends is easy
ð–¦¹ No end; can cycle infinitely

23. Operations and Complexity
ð–¦¹ Singly Circular:
â€¢ Add after cursor: O(1)
- Create new node
- newNode->next = cursor->next
- cursor->next = newNode
â€¢ Remove after cursor: O(1)
- Only node â†’ cursor = NULL
- Else â†’ cursor->next = cursor->next->next
- Delete old node
â€¢ Advance cursor: O(1)
- cursor = cursor->next
â€¢ Access front/back: O(1)
- back() = cursor->elem
- front() = cursor->next->elem
ð–¦¹ Doubly Circular:
â€¢ Insert/delete at head or tail: O(1)
- prev pointer allows direct access to previous node
â€¢ Traversal backward: O(n)
- Can move in reverse without loops

24. Examples of Use
ð–¦¹ Round-robin process scheduling
â€¢ Each process is a node
â€¢ Cursor moves to next process after execution
ð–¦¹ Digital Audio Player / Playlist
â€¢ Each song is a node
â€¢ Cursor points to current song
â€¢ Advance moves to next song
â€¢ Add/remove songs after cursor
ð–¦¹ Example Playlist Sequence
â€¢ Empty list: []
â€¢ Add "StayinAlive": [StayinAlive*]
â€¢ Add "LeFreak": [LeFreak, StayinAlive*]
â€¢ Add "JiveTalkin": [JiveTalkin, LeFreak, StayinAlive*]
â€¢ Advance cursor twice: [StayinAlive, JiveTalkin, LeFreak*]
â€¢ Remove after cursor: [JiveTalkin, LeFreak*]
â€¢ Add "DiscoInferno": [DiscoInferno, JiveTalkin, LeFreak*]

25. Memory Usage
ð–¦¹ Similar to singly or doubly linked lists
ð–¦¹ Doubly circular uses extra memory for prev pointers

26. Advantages of Circular Lists
ð–¦¹ No head/tail limits; perfect for cycling
ð–¦¹ O(1) insertion and deletion after cursor (or tail in doubly circular)
ð–¦¹ Forward/backward traversal (doubly circular)
ð–¦¹ Efficient for playlists, queues, round-robin

27. Disadvantages
ð–¦¹ Slightly more complex than SLL or DLL
ð–¦¹ Singly circular: reverse traversal difficult
ð–¦¹ Must maintain links carefully; broken link breaks cycle

28. Reverse A Linked List
IMG_URL reverse-ll.gif
ð–¦¹ PSEUDOCODE
function reverseLinkedList(head):
    prev = NULL           // start with prev as NULL
    curr = head           // start at the first node
    
    while curr is not NULL:
        nextNode = curr.next   // remember the next node
        curr.next = prev       // reverse the link
        prev = curr            // move prev forward
        curr = nextNode        // move curr forward
    
    head = prev           // prev is the new head
    return head

29. Skip List
ð–¦¹ A skip list speeds up search, insertion, and deletion in a sorted linked list
ð–¦¹ Adds extra "express lanes" or higher-level pointers
ð–¦¹ Normal linked list: check nodes one by one â†’ slow
ð–¦¹ Skip list: jump ahead using higher levels, drop down when needed
ð–¦¹ Example:
â€¢ Level 3: A ------------------> E
â€¢ Level 2: A --------> C ------> E
â€¢ Level 1: A -> B -> C -> D -> E

30. Properties
ð–¦¹ Elements must be sorted for skipping to work
ð–¦¹ Multiple levels: top levels few nodes, bottom level all nodes
ð–¦¹ Randomized levels: each node gets level randomly, balances list probabilistically
ð–¦¹ Average time: O(log n) for search, insertion, deletion
ð–¦¹ Space: O(n)
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/linked-list/skiplist_node.cpp

31. Analogy
ð–¦¹ Like a book with page numbers
â€¢ Normal: read page by page
â€¢ Skip list: table of contents + bookmarks â†’ jump ahead, fine-tune
ð–¦¹ Faster than normal linked list for sorted data
ð–¦¹ Simpler than balanced trees like AVL or Red-Black

32. Search â€“ Average O(log n), Worst O(n)
ð–¦¹ Average:
â€¢ Multiple levels allow skipping many nodes
â€¢ Each step reduces remaining nodes roughly by half
â€¢ Levels â‰ˆ logâ‚‚(n)
â€¢ Horizontal moves small
- Total steps â‰ˆ logâ‚‚(n) â†’ O(log n)
ð–¦¹ Worst case:
â€¢ All nodes at level 1 â†’ behaves like normal linked list
â€¢ Traverse all n nodes â†’ O(n)

33. Insertion â€“ Average O(log n)
ð–¦¹ Search for correct position (average O(log n))
ð–¦¹ Insert node at all its levels (update pointers)
ð–¦¹ Randomized level assignment limits number of levels per node
- Average insertion â‰ˆ O(log n)
- Worst case rare: all nodes at level 1 â†’ O(n)

34. Deletion â€“ Average O(log n)
ð–¦¹ Search for node (average O(log n))
ð–¦¹ Update pointers of predecessors at all levels
ð–¦¹ Same reasoning as insertion â†’ total cost â‰ˆ O(log n)

35. Space â€“ O(n)
ð–¦¹ Each node stores array of next pointers = nodeâ€™s level
ð–¦¹ Average node level small (â‰ˆ 2) â†’ extra memory per node constant
ð–¦¹ Total nodes = n â†’ total space O(n)

36. What is a Skip List
IMG_URL skiplist.gif
ð–¦¹ An advanced linked list with multiple levels of forward pointers
ð–¦¹ Faster search, insertion, and deletion using express lanes
ð–¦¹ Each node has a randomly assigned level
ð–¦¹ Search starts from top level and goes down

37. Node Levels
ð–¦¹ Each node can have multiple levels = number of forward pointers
ð–¦¹ Higher levels skip more nodes
ð–¦¹ Levels assigned randomly to balance the list
ð–¦¹ Example:
â€¢ Nodes: 1 2 3 4 5 6 7
â€¢ Levels: 1â†’5, 2â†’2, 3â†’3, 4â†’1, 5â†’2, 6â†’1, 7â†’1

38. How Search Works
ð–¦¹ Start at header node, topmost level
ð–¦¹ Move forward while next nodeâ€™s key < search key
ð–¦¹ Drop down one level if next is nullptr or â‰¥ key
ð–¦¹ Repeat until level 0
ð–¦¹ curr points to predecessor â†’ check level 0:
â€¢ curr = curr->forward[0]; if curr != nullptr && curr->key == key found
- Step forward at level 0 because curr ends as largest node < key

39. Why Skip List is Fast
ð–¦¹ Multiple levels allow jumping over nodes
ð–¦¹ Average search = O(log n)
ð–¦¹ Worst case = O(n) if all nodes end at level 0
ð–¦¹ Space = O(n)

40. Example Search (key = 5)
ð–¦¹ Nodes & levels: 1(5), 2(2), 3(3), 4(1), 5(2), 6(1), 7(1)
ð–¦¹ Steps:
â€¢ Start at node 1, level 5 â†’ forward[5]=6 â†’ 6>5 â†’ drop to level 4
â€¢ Level 4 â†’ forward[4]=5 â†’ candidate? curr still points to 1
â€¢ Move forward level 0: curr=curr->forward[0] â†’ points to 5 â†’ key==5 âœ…

41. Key Operations
ð–¦¹ Search: Avg O(log n), Worst O(n)
ð–¦¹ Insertion: Avg O(log n)
ð–¦¹ Deletion: Avg O(log n)
ð–¦¹ Space: O(n)

42. Express Lanes Analogy
ð–¦¹ Level >0 pointers = express lanes
ð–¦¹ Level 0 pointers = normal linked list
ð–¦¹ Node 1 level 5 can jump over nodes 2,3,4,5 to reach 6
ð–¦¹ Nodes exist at multiple levels via random assignment

43. C++ Implementation
ð–¦¹ Includes header, random, time libraries
ð–¦¹ [pink]class[/pink] [yellow]Node[/yellow] with [yellow]key[/yellow], [blue]forward[/blue], [yellow]nodeLevel[/yellow]
ð–¦¹ [pink]class[/pink] [yellow]SkipList[/yellow] with [yellow]level[/yellow] and [yellow]header[/yellow]
ð–¦¹ Random level generator: 0.5 probability to go up
ð–¦¹ [pink]insert[/pink](key): find position, assign random level, update forward pointers
ð–¦¹ [pink]search[/pink](key): move top-down, return found/not found
ð–¦¹ [pink]printList[/pink](): print all levels
ð–¦¹ [pink]main[/pink](): create skip list, insert keys, print list, search keys
â€¢ Code Example:
[pink]#include[/pink] <yellow>iostream</yellow>  
[pink]#include[/pink] <yellow>cstdlib</yellow>  
[pink]#include[/pink] <yellow>ctime</yellow>  
using namespace <green>std</green>;  

const int MAX_LEVEL = 4;  

[pink]class[/pink] [yellow]Node[/yellow] {  
public:  
    int key;  
    [blue]Node**[/blue] forward;  
    int nodeLevel;  
    [pink]Node[/pink](int key, int level) { /* create forward array */ }  
};  

[pink]class[/pink] [yellow]SkipList[/yellow] {  
private:  
    int level;  
    [blue]Node*[/blue] header;  
public:  
    [pink]SkipList[/pink]() { /* init header */ }  
    int randomLevel() { /* 0.5 probability */ }  
    void insert(int key) { /* insert node */ }  
    bool search(int key) { /* search node */ }  
    void printList() { /* print levels */ }  
};  

[pink]int[/pink] [pink]main[/pink]() {  
    srand(time(0));  
    SkipList list;  
    list.insert(3); list.insert(6); /* insert more */  
    list.printList();  
    list.search(9); list.search(15);  
    return 0;  
}

44. Self-Organizing Lists
ð–¦¹ Normal linked list is slow for search because you check nodes one by one
ð–¦¹ Self-organizing lists reorder nodes dynamically to speed up search for frequent items

45. Move-to-Front Method
ð–¦¹ After finding an element, move it to the beginning
ð–¦¹ Frequently searched items stay near the front
ð–¦¹ Example: A B C D, search D â†’ D A B C

46. Transpose Method
ð–¦¹ After finding an element, swap it with the previous node
ð–¦¹ Element moves gradually toward front
ð–¦¹ Example: A B C D, search D â†’ swap with C â†’ A B D C

47. Count Method
ð–¦¹ Keep a count of how many times each element is accessed
ð–¦¹ Sort list so most accessed elements are near front
ð–¦¹ Example: D accessed 3 times, B accessed 1 time â†’ D comes before B

48. Ordering Method
ð–¦¹ Keep list sorted by natural order (alphabetical, birthday, salary)
ð–¦¹ Position of elements does not change dynamically
ð–¦¹ Example: Alice, Bob, Charlie, David

49. How New Data is Inserted
ð–¦¹ In move-to-front, transpose, count methods: new data goes to end of list
ð–¦¹ In ordering method: insert at correct position to maintain order

50. Why This Helps
ð–¦¹ Frequently searched items stay near front â†’ fewer steps to find
ð–¦¹ Useful for repeated searches in a data stream
ð–¦¹ In ordering method, can stop early if element doesnâ€™t exist because list is sorted

51. Inserting a Node in the Middle of a Doubly Linked List
ð–¦¹ To insert in the middle, first find the middle node
ð–¦¹ Use two pointers: slow and fast
â€¢ [yellow]slow[/yellow] moves 1 step at a time
â€¢ [yellow]fast[/yellow] moves 2 steps at a time
â€¢ When [yellow]fast[/yellow] reaches end (nullptr), [yellow]slow[/yellow] points to middle
- Code:
[pink]while[/pink] ([yellow]fast[/yellow] != [green]nullptr[/green] && [yellow]fast[/yellow]->next != [green]nullptr[/green]) {
    [yellow]slow[/yellow] = [yellow]slow[/yellow]->next;       // 1 step
    [yellow]fast[/yellow] = [yellow]fast[/yellow]->next->next; // 2 steps
}
ð–¦¹ Once middle node is found, insert new node before or after it
â€¢ Adjust [yellow]prev[/yellow] and [yellow]next[/yellow] pointers of surrounding nodes

52. Adapting Binary Search to Linked Lists
ð–¦¹ Linked lists donâ€™t allow direct index access like arrays
ð–¦¹ Binary search needs O(n) to reach middle each time
ð–¦¹ So total time = O(n) + O(n/2) + O(n/4) + ... â‰ˆ O(n)
- Not as efficient as array binary search (O(log n))
ð–¦¹ Works logically but practically slower for large lists

53. Unrolled Linked List
IMG_URL unrolled_ll.png
ð–¦¹ A linked list variation where each node stores multiple elements in an array plus a pointer to next node.
ð–¦¹ Purpose: reduce pointer overhead, improve cache performance, and reduce wasted memory.
ð–¦¹ Acts like a mix between arrays and linked lists: dynamic insertion/deletion like linked lists but stores chunks to reduce overhead.

54. Node Structure
ð–¦¹ Each node has:
â€¢ [yellow]next[/yellow] pointer (and optionally [yellow]prev[/yellow] for doubly)
â€¢ [yellow]numElements[/yellow] â†’ number of actual elements
â€¢ [yellow]elements[][/yellow] â†’ array of capacity [yellow]maxElements[/yellow]
- Typically nodes aim to be at least half full for efficiency
- Example:
[pink]record[/pink] [yellow]node[/yellow] {
   [yellow]node next[/yellow];
   [pink]int[/pink] [yellow]numElements[/yellow];
   [yellow]array elements[/yellow];
}

55. Capacity / Block Size
ð–¦¹ Choose [yellow]maxElements[/yellow] so each node fits well into cache lines
ð–¦¹ Example: each node fills one cache line or a small multiple

56. List Layout
ð–¦¹ Nodes chained: Node1 â†’ Node2 â†’ Node3 â€¦
ð–¦¹ Each node has an array of elements, e.g., Node1: [1,2,3,4], Node2: [5,6,7,8]
ð–¦¹ Doubly unrolled list: nodes also have [yellow]prev[/yellow] pointer

57. Search / Traversal
ð–¦¹ Traverse nodes until correct node found, then search inside nodeâ€™s array
ð–¦¹ Reduces pointer hops because nodes hold multiple elements
ð–¦¹ Example: n elements, block size ~âˆšn â†’ ~âˆšn nodes, each ~âˆšn size â†’ search ~O(âˆšn)

58. Insertion
ð–¦¹ Find node where insertion belongs
ð–¦¹ If node has space â†’ insert in array (shift if needed)
ð–¦¹ If node full â†’ split node, move half elements to new node, insert new element

59. Deletion
ð–¦¹ Find elementâ€™s node, remove from array, shift items
ð–¦¹ If node falls below threshold (e.g., < half full) â†’ merge with neighbor or rebalance

60. Advantages
ð–¦¹ Reduced pointer overhead: one pointer per node instead of per element
ð–¦¹ Better cache performance: contiguous memory access inside node
ð–¦¹ More efficient than plain linked lists for dynamic sequences

61. Disadvantages / Trade-offs
ð–¦¹ Slightly complex: splitting/merging nodes, managing arrays inside nodes
ð–¦¹ Large block size with few elements wastes space
ð–¦¹ Within-node search is linear unless extra indexing used
ð–¦¹ Worst-case time may still be linear in number of nodes

62. Complexity Summary
ð–¦¹ Let n = total elements, B = block size
ð–¦¹ Number of nodes â‰ˆ n/B
ð–¦¹ Search = O(n/B + B)
ð–¦¹ Insert/Delete = O(B) (may involve split/merge)
ð–¦¹ Space overhead per element reduced compared to plain linked list

63. Example: 16 elements, block size 4
ð–¦¹ Nodes: Node1: [1,2,3,4] â†’ Node2: [5,6,7,8] â†’ Node3: [9,10,11,12] â†’ Node4: [13,14,15,16]
ð–¦¹ Search 7: traverse Node1 â†’ Node2, then linear scan inside Node2 â†’ 5 comparisons vs 7 in normal linked list
ð–¦¹ Worst-case search 16: 3 node traversals + 4 inside-node â†’ 7 comparisons vs 16 in normal linked list

64. Choosing Block Size B
ð–¦¹ Too small â†’ behaves like normal linked list
ð–¦¹ Too large â†’ inside-node search slow
ð–¦¹ Sweet spot: B â‰ˆ âˆšn â†’ search O(âˆšn)
ð–¦¹ Example: n=10,000 â†’ B=100 â†’ ~100 nodes, inside-node scan â‰¤ 100 â†’ ~200 comparisons

65. C++ Program for Unrolled Linked List
[pink]#include[/pink] <[green]iostream[/green]>
[pink]#include[/pink] <[green]vector[/green]>
[pink]using[/pink] [pink]namespace[/pink] [green]std[/green];

[pink]class[/pink] [yellow]Node[/yellow] {
[pink]public[/pink]:
    [green]vector[/green]<[blue]int[/blue]> [yellow]elements[/yellow];
    [yellow]Node[/yellow]* [yellow]next[/yellow];
    [blue]int[/blue] [yellow]capacity[/yellow];

    [pink]Node[/pink]([blue]int[/blue] [yellow]cap[/yellow]) {
        [yellow]capacity[/yellow] = [yellow]cap[/yellow];
        [yellow]next[/yellow] = [green]nullptr[/green];
    }
};

[pink]class[/pink] [yellow]UnrolledLinkedList[/yellow] {
[pink]private[/pink]:
    [yellow]Node[/yellow]* [yellow]head[/yellow];
    [blue]int[/blue] [yellow]nodeCapacity[/yellow];

[pink]public[/pink]:
    [pink]UnrolledLinkedList[/pink]([blue]int[/blue] [yellow]cap[/yellow]) {
        [yellow]nodeCapacity[/yellow] = [yellow]cap[/yellow];
        [yellow]head[/yellow] = [pink]new[/pink] [yellow]Node[/yellow]([yellow]nodeCapacity[/yellow]);
    }

    [pink]void[/pink] [yellow]insert[/yellow]([blue]int[/blue] [yellow]val[/yellow]) {
        [yellow]Node[/yellow]* [yellow]curr[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]curr[/yellow]->[yellow]next[/yellow] != [green]nullptr[/green])
            [yellow]curr[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];

        [pink]if[/pink] ([yellow]curr[/yellow]->[yellow]elements[/yellow].[green]size[/green]() < [yellow]curr[/yellow]->[yellow]capacity[/yellow]) {
            [yellow]curr[/yellow]->[yellow]elements[/yellow].[green]push_back[/green]([yellow]val[/yellow]);
        } [pink]else[/pink] {
            [yellow]Node[/yellow]* [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]Node[/yellow]([yellow]nodeCapacity[/yellow]);
            [yellow]newNode[/yellow]->[yellow]elements[/yellow].[green]push_back[/green]([yellow]val[/yellow]);
            [yellow]curr[/yellow]->[yellow]next[/yellow] = [yellow]newNode[/yellow];
        }
    }

    [pink]bool[/pink] [yellow]search[/yellow]([blue]int[/blue] [yellow]val[/yellow]) {
        [yellow]Node[/yellow]* [yellow]curr[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]curr[/yellow] != [green]nullptr[/green]) {
            [pink]if[/pink] (![yellow]curr[/yellow]->[yellow]elements[/yellow].[green]empty[/green]() && [yellow]val[/yellow] <= [yellow]curr[/yellow]->[yellow]elements[/yellow].[green]back[/green]()) {
                [pink]for[/pink] ([blue]int[/blue] [yellow]x[/yellow] : [yellow]curr[/yellow]->[yellow]elements[/yellow]) {
                    [pink]if[/pink] ([yellow]x[/yellow] == [yellow]val[/yellow]) {
                        [green]cout[/green] << "Found " << [yellow]val[/yellow] << " in node.\n";
                        [pink]return[/pink] [green]true[/green];
                    }
                }
                [pink]return[/pink] [green]false[/green];
            }
            [yellow]curr[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];
        }
        [green]cout[/green] << [yellow]val[/yellow] << " not found in list.\n";
        [pink]return[/pink] [green]false[/green];
    }

    [pink]void[/pink] [yellow]printList[/yellow]() {
        [yellow]Node[/yellow]* [yellow]curr[/yellow] = [yellow]head[/yellow];
        [blue]int[/blue] [yellow]nodeId[/yellow] = 1;
        [pink]while[/pink] ([yellow]curr[/yellow] != [green]nullptr[/green]) {
            [green]cout[/green] << "Node " << [yellow]nodeId[/yellow] << ": ";
            [pink]for[/pink] ([blue]int[/blue] [yellow]x[/yellow] : [yellow]curr[/yellow]->[yellow]elements[/yellow])
                [green]cout[/green] << [yellow]x[/yellow] << " ";
            [green]cout[/green] << [green]endl[/green];
            [yellow]curr[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];
            [yellow]nodeId[/yellow]++;
        }
    }
};

[pink]int[/pink] [pink]main[/pink]() {
    [blue]int[/blue] [yellow]nodeCapacity[/yellow] = 4;
    [yellow]UnrolledLinkedList[/yellow] [yellow]list[/yellow]([yellow]nodeCapacity[/yellow]);

    [pink]for[/pink] ([blue]int[/blue] [yellow]i[/yellow] = 1; [yellow]i[/yellow] <= 16; [yellow]i[/yellow]++)
        [yellow]list[/yellow].[yellow]insert[/yellow]([yellow]i[/yellow]);

    [yellow]list[/yellow].[yellow]printList[/yellow]();

     ;
     ;
     ;

    [pink]return[/pink] 0;
}

66. XOR Linked List
IMG_URL xorll.png
ð–¦¹ A normal doubly linked list has two pointers per node: next (points to next node) and prev (points to previous node)
ð–¦¹ XOR linked list reduces this to one pointer per node by storing XOR(prev, next)
â€¢ Each node has [blue]Node*[/blue] [yellow]npx[/yellow] = prev XOR next
- Using XOR, if you know one node (prev or next), you can compute the other

67. How it works
ð–¦¹ XOR is a bitwise operation: a XOR b lets you reconstruct a or b if the other is known
ð–¦¹ To move forward: [yellow]next[/yellow] = [yellow]prev[/yellow] XOR [yellow]npx[/yellow]
ð–¦¹ To move backward: [yellow]prev[/yellow] = [yellow]next[/yellow] XOR [yellow]npx[/yellow]

68. Traversal example
ð–¦¹ Suppose list is A <-> B <-> C
ð–¦¹ Node B stores: [yellow]B.npx[/yellow] = A XOR C
ð–¦¹ If you are at B and came from A: [yellow]next[/yellow] = B.npx XOR prev â†’ (A XOR C) XOR A = C
- This lets traversal use only one pointer per node

69. Pros & Cons
ð–¦¹ Pros
â€¢ Saves memory: one pointer instead of two per node
â€¢ Clever low-level technique
ð–¦¹ Cons
â€¢ Hard to debug
â€¢ Needs XOR operation each traversal
â€¢ Not suitable for garbage-collected languages
â€¢ Insertions and deletions are tricky

70. Key Idea
ð–¦¹ Each node keeps combined XOR of prev and next
ð–¦¹ Always need one known node (prev or next) to find the other
ð–¦¹ Traversal is sequential but memory usage is reduced
ð–¦¹ Formula:
â€¢ npx = address(prev) XOR address(next)
â€¢ To go forward: next = prev XOR npx
â€¢ To go backward: prev = next XOR npx

71. C++ Implementation
[pink]#include[/pink] <[green]iostream[/green]>
[pink]using[/pink] [pink]namespace[/pink] [green]std[/green];

[pink]class[/pink] [yellow]XORNode[/yellow] {
[pink]public[/pink]:
    [blue]int[/blue] [yellow]data[/yellow];
    [yellow]XORNode[/yellow]* [yellow]npx[/yellow]; // XOR of prev and next
    [pink]XORNode[/pink]([blue]int[/blue] [yellow]val[/yellow]) {
        [yellow]data[/yellow] = [yellow]val[/yellow];
        [yellow]npx[/yellow] = [green]nullptr[/green];
    }
};

// Helper XOR function
[pink]XORNode*[/pink] [yellow]XOR[/yellow]([yellow]XORNode[/yellow]* [yellow]a[/yellow], [yellow]XORNode[/yellow]* [yellow]b[/yellow]) {
    return ([pink]reinterpret_cast[/pink]<[yellow]XORNode[/yellow]*>(
        ([blue]uintptr_t[/blue]) [yellow]a[/yellow] ^ ([blue]uintptr_t[/blue]) [yellow]b[/yellow]));
}

[pink]class[/pink] [yellow]XORLinkedList[/yellow] {
[pink]private[/pink]:
    [yellow]XORNode[/yellow]* [yellow]head[/yellow];
    [yellow]XORNode[/yellow]* [yellow]tail[/yellow];
[pink]public[/pink]:
    [pink]XORLinkedList[/pink]() {
        [yellow]head[/yellow] = [green]nullptr[/green];
        [yellow]tail[/yellow] = [green]nullptr[/green];
    }

    [pink]void[/pink] [yellow]insert[/yellow]([blue]int[/blue] [yellow]val[/yellow]) {
        [yellow]XORNode[/yellow]* [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]XORNode[/yellow]([yellow]val[/yellow]);
        [pink]if[/pink] ([yellow]head[/yellow] == [green]nullptr[/green]) {
            [yellow]head[/yellow] = [yellow]tail[/yellow] = [yellow]newNode[/yellow];
        } [pink]else[/pink] {
            [yellow]newNode[/yellow]->[yellow]npx[/yellow] = [yellow]XOR[/yellow]([green]nullptr[/green], [yellow]tail[/yellow]);
            [yellow]tail[/yellow]->[yellow]npx[/yellow] = [yellow]XOR[/yellow]([yellow]XOR[/yellow]([yellow]tail[/yellow]->[yellow]npx[/yellow], [green]nullptr[/green]), [yellow]newNode[/yellow]);
            [yellow]tail[/yellow] = [yellow]newNode[/yellow];
        }
    }

    [pink]void[/pink] [yellow]traverseForward[/yellow]() {
        [yellow]XORNode[/yellow]* [yellow]curr[/yellow] = [yellow]head[/yellow];
        [yellow]XORNode[/yellow]* [yellow]prev[/yellow] = [green]nullptr[/green];
        [yellow]XORNode[/yellow]* [yellow]next[/yellow];

        [pink]while[/pink] ([yellow]curr[/yellow] != [green]nullptr[/green]) {
            [green]cout[/green] << [yellow]curr[/yellow]->[yellow]data[/yellow] << " ";
            [yellow]next[/yellow] = [yellow]XOR[/yellow]([yellow]prev[/yellow], [yellow]curr[/yellow]->[yellow]npx[/yellow]);
            [yellow]prev[/yellow] = [yellow]curr[/yellow];
            [yellow]curr[/yellow] = [yellow]next[/yellow];
        }
        [green]cout[/green] << [green]endl[/green];
    }
};

[pink]int[/pink] [pink]main[/pink]() {
    [yellow]XORLinkedList[/yellow] [yellow]list[/yellow];
     ;
     ;
     ;
     ;

    [green]cout[/green] << "Forward traversal: ";
    [yellow]list[/yellow].[yellow]traverseForward[/yellow]();

    [pink]return[/pink] 0;
}
--END--
--BEGIN--24/11/2025--STACKS--
1. A Stack
IMG_URL stack.gif
ð–¦¹ A stack is a list where you add or remove only at the top.
ð–¦¹ push means you add at the top.
ð–¦¹ pop means you remove from the top.
ð–¦¹ topEl means you look at the top without removing.
ð–¦¹ Last added is first removed, so it is LIFO.

2. Stack operations
ð–¦¹ clear() means make stack empty.
ð–¦¹ isEmpty() means check if stack has no items.
ð–¦¹ push(x) means put x on top.
ð–¦¹ pop() means remove the top item.
ð–¦¹ topEl() means see the top item without removing.

3. Example of push and pop
ð–¦¹ Start empty.
ð–¦¹ push 10 â†’ stack becomes [10].
ð–¦¹ push 5 â†’ stack becomes [10, 5].
ð–¦¹ pop removes 5 â†’ stack becomes [10].
ð–¦¹ push 15 â†’ stack becomes [10, 15].
ð–¦¹ push 7 â†’ stack becomes [10, 15, 7].
ð–¦¹ pop removes 7 â†’ stack becomes [10, 15].

4. Checking brackets using stack
ð–¦¹ Used to match brackets like (), [], {} and block comments.
ð–¦¹ For code like:
[yellow]while[/yellow] ([yellow]m[/yellow] < ([yellow]n[/yellow][8] + [yellow]o[/yellow])) { [yellow]p[/yellow] = 7; }
â€¢ When you see opening bracket, push it.
â€¢ When you see closing bracket, pop and check if types match.
- If mismatch, it is an error.
- If stack ends empty, everything matches.
ð–¦¹ Helps because inner brackets must match before outer ones.

5. Adding very large numbers
ð–¦¹ When numbers are too big for normal number types, treat them as strings.
ð–¦¹ Push digits of each number into two stacks.
ð–¦¹ Pop from each stack to add from right to left.

6. JVM use of stacks
ð–¦¹ JVM pushes a frame when a method starts.
ð–¦¹ JVM pops the frame when method ends.
ð–¦¹ Inside each frame, JVM uses an operand stack for calculations.
ð–¦¹ For example:
[pink]imul[/pink] pops two numbers, multiplies them, and pushes the result.

7. Ways to implement a stack
ð–¦¹ Using [yellow]ArrayList[/yellow].
â€¢ Fast, needs resizing when full.
â€¢ push/pop usually O(1).
ð–¦¹ Using [yellow]LinkedList[/yellow].
â€¢ No resizing needed.
â€¢ push/pop always O(1).
â€¢ Very close to real stack behavior.

8. Stack implementation using array or linked list
ð–¦¹ Both array stack and linked-list stack give O(1) time for push, pop, top, and isEmpty.
ð–¦¹ Array stack uses a fixed-size array decided early.
â€¢ Very fast and uses less memory.
â€¢ Items are in continuous memory, so it is cache-friendly.
â€¢ Can overflow if array becomes full.
â€¢ Can waste memory if chosen size is too big.
ð–¦¹ Linked-list stack grows and shrinks as needed.
â€¢ Does not overflow unless whole system runs out of memory.
â€¢ A bit slower because each push needs dynamic memory work.
â€¢ Each node stores an extra pointer, so it uses more memory and is less cache-friendly.
ð–¦¹ Summary: array stack is faster but fixed in size; linked-list stack is flexible but slower and uses more memory.

9. Implementing stack
ð–¦¹ A stack can be made using array.
ð–¦¹ A stack can also be made using linked list.
ð–¦¹ Both methods are simple and complete.

10. Stack using array (C++ code)
ð–¦¹ Uses a fixed-size array.
ð–¦¹ top moves up and down when pushing or popping.
ð–¦¹ Code:
/* array stack */
[pink]#include[/pink] <[yellow]iostream[/yellow]>
[pink]using[/pink] [pink]namespace[/pink] [yellow]std[/yellow];

[pink]class[/pink] [yellow]Stack[/yellow] {
[pink]private[/pink]:
    [blue]int[/blue] [yellow]arr[/yellow][100];
    [blue]int[/blue] [yellow]top[/yellow];

[pink]public[/pink]:
    [yellow]Stack[/yellow]() { [yellow]top[/yellow] = -1; }

    [blue]bool[/blue] [yellow]isEmpty[/yellow]() {
        [pink]return[/pink] [yellow]top[/yellow] == -1;
    }

    [blue]bool[/blue] [yellow]isFull[/yellow]() {
        [pink]return[/pink] [yellow]top[/yellow] == 99;
    }

    [pink]void[/pink] [yellow]push[/yellow]([blue]int[/blue] x) {
        [pink]if[/pink] ([yellow]isFull[/yellow]()) {
            [green]cout[/green] << "Stack Overflow\n";
            [pink]return[/pink];
        }
        [yellow]arr[/yellow][++[yellow]top[/yellow]] = x;
    }

    [pink]void[/pink] [yellow]pop[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) {
            [green]cout[/green] << "Stack Underflow\n";
            [pink]return[/pink];
        }
        [yellow]top[/yellow]--;
    }

    [blue]int[/blue] [yellow]topElement[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) {
            [green]cout[/green] << "Stack is Empty\n";
            [pink]return[/pink] -1;
        }
        [pink]return[/pink] [yellow]arr[/yellow][[yellow]top[/yellow]];
    }
};

[pink]int[/pink] [pink]main[/pink]() {
    [yellow]Stack[/yellow] s;
    s.push(10);
    s.push(20);
    s.push(30);
    [green]cout[/green] << s.[yellow]topElement[/yellow]() << [green]endl[/green];
    s.[yellow]pop[/yellow]();
    [green]cout[/green] << s.[yellow]topElement[/yellow]() << [green]endl[/green];
}

11. Stack using linked list (C++ code)
ð–¦¹ Uses nodes that link together.
ð–¦¹ No fixed size; grows and shrinks freely.
ð–¦¹ Code:
/* linked list stack */
[pink]#include[/pink] <[yellow]iostream[/yellow]>
[pink]using[/pink] [pink]namespace[/pink] [yellow]std[/yellow];

[pink]class[/pink] [yellow]Node[/yellow] {
[pink]public[/pink]:
    [blue]int[/blue] [yellow]data[/yellow];
    [yellow]Node[/yellow]* [yellow]next[/yellow];
};

[pink]class[/pink] [yellow]Stack[/yellow] {
[pink]private[/pink]:
    [yellow]Node[/yellow]* [yellow]top[/yellow];

[pink]public[/pink]:
    [yellow]Stack[/yellow]() { [yellow]top[/yellow] = [green]nullptr[/green]; }

    [blue]bool[/blue] [yellow]isEmpty[/yellow]() {
        [pink]return[/pink] [yellow]top[/yellow] == [green]nullptr[/green];
    }

    [pink]void[/pink] [yellow]push[/yellow]([blue]int[/blue] x) {
        [yellow]Node[/yellow]* [yellow]temp[/yellow] = [pink]new[/pink] [yellow]Node[/yellow]();
        [yellow]temp[/yellow]->[yellow]data[/yellow] = x;
        [yellow]temp[/yellow]->[yellow]next[/yellow] = [yellow]top[/yellow];
        [yellow]top[/yellow] = [yellow]temp[/yellow];
    }

    [pink]void[/pink] [yellow]pop[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) {
            [green]cout[/green] << "Stack Underflow\n";
            [pink]return[/pink];
        }
        [yellow]Node[/yellow]* [yellow]temp[/yellow] = [yellow]top[/yellow];
        [yellow]top[/yellow] = [yellow]top[/yellow]->[yellow]next[/yellow];
        [pink]delete[/pink] [yellow]temp[/yellow];
    }

    [blue]int[/blue] [yellow]topElement[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) {
            [green]cout[/green] << "Stack is Empty\n";
            [pink]return[/pink] -1;
        }
        [pink]return[/pink] [yellow]top[/yellow]->[yellow]data[/yellow];
    }
};

[pink]int[/pink] [pink]main[/pink]() {
    [yellow]Stack[/yellow] s;
    s.push(10);
    s.push(20);
    s.push(30);
    [green]cout[/green] << s.[yellow]topElement[/yellow]() << [green]endl[/green];
    s.[yellow]pop[/yellow]();
    [green]cout[/green] << s.[yellow]topElement[/yellow]() << [green]endl[/green];
}
--END--
--BEGIN--24/11/2025--QUEUES--
1. A Queue
IMG_URL queue.gif
ð–¦¹ A queue stores items in the order they arrive.
ð–¦¹ It follows FIFO (first in, first out).
â€¢ First added item is removed first.
- Explanation: works like people standing in a line.

2. Queue operations
ð–¦¹ Enqueue(x): add an item at the back.
ð–¦¹ Dequeue(): remove an item from the front.
ð–¦¹ Front() / Peek(): show front item without removing it.
ð–¦¹ isEmpty(): check if queue has no items.
ð–¦¹ isFull(): only for array version; checks if space is over.

3. How a queue is built
ð–¦¹ We keep two positions: [yellow]front[/yellow] and [yellow]rear[/yellow].
â€¢ [yellow]front[/yellow] â†’ first item
â€¢ [yellow]rear[/yellow] â†’ last item
ð–¦¹ Two ways to build it:
â€¢ Array queue: use an array and move [yellow]rear[/yellow] for enqueue, move [yellow]front[/yellow] for dequeue.
- Problem: if many operations happen, array may show overflow even when free space exists at the start.
â€¢ Linked-list queue: each node has [yellow]data[/yellow] and [yellow]next[/yellow].
- [yellow]front[/yellow] is head, [yellow]rear[/yellow] is tail.
- Enqueue at tail, dequeue at head.

4. Queue behaviour
ð–¦¹ Works like real-life waiting lines.
â€¢ Examples: ticket counter, printer jobs, server requests, CPU task list.
- Explanation: items leave in same order they came.

5. Time complexity of queue operations
ð–¦¹ Array queue: all operations O(1).
ð–¦¹ Linked-list queue: all operations O(1).
â€¢ isFull() only applies to array queue.

6. Memory use
ð–¦¹ Array queue: fixed size; no extra memory per item; may waste space.
ð–¦¹ Linked-list queue: grows and shrinks; uses extra pointer memory; no wasted space.

7. Where we use queues
ð–¦¹ CPU scheduling.
ð–¦¹ Printer jobs.
ð–¦¹ Web server request management.
ð–¦¹ BFS in graphs/trees.
ð–¦¹ Real-time buffering.
- Purpose: keep items in same order while giving fast insert and remove.

8. Why queue is important
ð–¦¹ It models natural waiting.
ð–¦¹ Many systems need FIFO order.
â€¢ Gives fast insert and delete at ends.
â€¢ Simple and powerful for many tasks.

9. Queue using array â€” C++ program
ð–¦¹ Simple linear array queue with fixed size.
[pink]#include[/pink] <iostream>
[pink]using[/pink] [pink]namespace[/pink] std;

[pink]class[/pink] [yellow]Queue[/yellow] {
[pink]private[/pink]:
    [pink]int[/pink] [yellow]arr[/yellow][100];
    [pink]int[/pink] [yellow]front[/yellow], [yellow]rear[/yellow];

[pink]public[/pink]:
    [yellow]Queue[/yellow]() {
        [yellow]front[/yellow] = 0;
        [yellow]rear[/yellow] = -1;
    }

    [pink]bool[/pink] [yellow]isEmpty[/yellow]() {
        [pink]return[/pink] [yellow]front[/yellow] > [yellow]rear[/yellow];
    }

    [pink]bool[/pink] [yellow]isFull[/yellow]() {
        [pink]return[/pink] [yellow]rear[/yellow] == 99;
    }

    [pink]void[/pink] [yellow]enqueue[/yellow]([pink]int[/pink] [yellow]x[/yellow]) {
        [pink]if[/pink] ([yellow]isFull[/yellow]()) {
            [green]cout[/green] << "Queue Overflow\n";
            [pink]return[/pink];
        }
        [yellow]arr[/yellow][++[yellow]rear[/yellow]] = [yellow]x[/yellow];
    }

    [pink]void[/pink] [yellow]dequeue[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) {
            [green]cout[/green] << "Queue Underflow\n";
            [pink]return[/pink];
        }
        [yellow]front[/yellow]++;
    }

    [pink]int[/pink] [yellow]frontElement[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) {
            [green]cout[/green] << "Queue is Empty\n";
            [pink]return[/pink] -1;
        }
        [pink]return[/pink] [yellow]arr[/yellow][[yellow]front[/yellow]];
    }
};

[pink]int[/pink] [pink]main[/pink]() {
    [yellow]Queue[/yellow] q;
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    [green]cout[/green] << q.[yellow]frontElement[/yellow]() << [green]endl[/green];
    q.[yellow]dequeue[/yellow]();
    [green]cout[/green] << q.[yellow]frontElement[/yellow]() << [green]endl[/green];
}

10. Queue using linked list: C++ program
ð–¦¹ Uses nodes; grows until memory ends.
[pink]#include[/pink] <iostream>
[pink]using[/pink] [pink]namespace[/pink] std;

[pink]class[/pink] [yellow]Node[/yellow] {
[pink]public[/pink]:
    [pink]int[/pink] [yellow]data[/yellow];
    [yellow]Node[/yellow]* [yellow]next[/yellow];
};

[pink]class[/pink] [yellow]Queue[/yellow] {
[pink]private[/pink]:
    [yellow]Node[/yellow]* [yellow]front[/yellow];
    [yellow]Node[/yellow]* [yellow]rear[/yellow];

[pink]public[/pink]:
    [yellow]Queue[/yellow]() {
        [yellow]front[/yellow] = [yellow]rear[/yellow] = [green]nullptr[/green];
    }

    [pink]bool[/pink] [yellow]isEmpty[/yellow]() {
        [pink]return[/pink] [yellow]front[/yellow] == [green]nullptr[/green];
    }

    [pink]void[/pink] [yellow]enqueue[/yellow]([pink]int[/pink] [yellow]x[/yellow]) {
        [yellow]Node[/yellow]* [yellow]temp[/yellow] = [pink]new[/pink] [yellow]Node[/yellow]();
        [yellow]temp[/yellow]->[yellow]data[/yellow] = [yellow]x[/yellow];
        [yellow]temp[/yellow]->[yellow]next[/yellow] = [green]nullptr[/green];

        [pink]if[/pink] ([yellow]rear[/yellow] == [green]nullptr[/green]) {
            [yellow]front[/yellow] = [yellow]rear[/yellow] = [yellow]temp[/yellow];
        } [pink]else[/pink] {
            [yellow]rear[/yellow]->[yellow]next[/yellow] = [yellow]temp[/yellow];
            [yellow]rear[/yellow] = [yellow]temp[/yellow];
        }
    }

    [pink]void[/pink] [yellow]dequeue[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) {
            [green]cout[/green] << "Queue Underflow\n";
            [pink]return[/pink];
        }
        [yellow]Node[/yellow]* [yellow]temp[/yellow] = [yellow]front[/yellow];
        [yellow]front[/yellow] = [yellow]front[/yellow]->[yellow]next[/yellow];

        [pink]if[/pink] ([yellow]front[/yellow] == [green]nullptr[/green]) {
            [yellow]rear[/yellow] = [green]nullptr[/green];
        }

        [pink]delete[/pink] [yellow]temp[/yellow];
    }

    [pink]int[/pink] [yellow]frontElement[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) {
            [green]cout[/green] << "Queue is Empty\n";
            [pink]return[/pink] -1;
        }
        [pink]return[/pink] [yellow]front[/yellow]->[yellow]data[/yellow];
    }
};

[pink]int[/pink] [pink]main[/pink]() {
    [yellow]Queue[/yellow] q;
    q.enqueue(5);
    q.enqueue(15);
    q.enqueue(25);
    [green]cout[/green] << q.[yellow]frontElement[/yellow]() << [green]endl[/green];
    q.[yellow]dequeue[/yellow]();
    [green]cout[/green] << q.[yellow]frontElement[/yellow]() << [green]endl[/green];
}

11. Queue vs. Stack
ð–¦¹ Order:
â€¢ Stack â†’ LIFO (last in, first out)
â€¢ Queue â†’ FIFO (first in, first out)
ð–¦¹ Operations:
â€¢ Stack â†’ push, pop, top
â€¢ Queue â†’ enqueue, dequeue, front
ð–¦¹ Uses:
â€¢ Stack â†’ function calls, undo, expression work, DFS
â€¢ Queue â†’ CPU tasks, printers, BFS, servers
ð–¦¹ Speed:
â€¢ Both give O(1) operations.
ð–¦¹ Memory:
â€¢ Array stack â†’ continuous memory
â€¢ Array queue â†’ may waste front space if many dequeues
â€¢ Linked-list forms â†’ dynamic with pointer cost

12. Priority queue basics
IMG_URL queue-types.jpg
ð–¦¹ A priority queue always removes the element with the best priority.
ð–¦¹ Best priority may mean smallest number or largest number based on rule.
ð–¦¹ How we store items changes the speed of insert and delete.

13. Unsorted List
ð–¦¹ Keep items in a normal list without sorting.
ð–¦¹ Insert is very fast because we just place the new item anywhere.
ð–¦¹ Remove is slow because we must search the whole list to find the best priority.
â€¢ Insert time: O(1)
â€¢ Delete time: O(n)
- Explanation: The best priority can be anywhere, so we need a full scan.
ð–¦¹ Useful when inserts happen many times and deletes happen few times.
ð–¦¹ Related code:
[pink]#include[/pink] <iostream>
[pink]using[/pink] [pink]namespace[/pink] std;
[pink]struct[/pink] [yellow]Node[/yellow] {
    [pink]int[/pink] [yellow]value[/yellow];
    [pink]int[/pink] [yellow]priority[/yellow];
    [blue]Node*[/blue] [yellow]next[/yellow];
    [pink]Node[/pink]([pink]int[/pink] v, [pink]int[/pink] p) : [yellow]value[/yellow](v), [yellow]priority[/yellow](p), [yellow]next[/yellow](nullptr) {}
};
[pink]class[/pink] [yellow]UnsortedPriorityQueue[/yellow] {
[pink]private[/pink]:
    [blue]Node*[/blue] [yellow]head[/yellow];
[pink]public[/pink]:
    [pink]UnsortedPriorityQueue[/pink]() : [yellow]head[/yellow](nullptr) {}
    // Insert at head
    [pink]void[/pink] [yellow]enqueue[/yellow]([pink]int[/pink] value, [pink]int[/pink] priority) {
        [blue]Node*[/blue] [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]Node[/yellow](value, priority);
        [yellow]newNode[/yellow]->[yellow]next[/yellow] = [yellow]head[/yellow];
        [yellow]head[/yellow] = [yellow]newNode[/yellow];
    }
    // Remove highest priority
    [pink]int[/pink] [yellow]dequeue[/yellow]() {
        [pink]if[/pink] (![yellow]head[/yellow]) {
            [green]cout[/green] << "Queue empty\n";
            [pink]return[/pink] -1;
        }
        [blue]Node*[/blue] [yellow]best[/yellow] = [yellow]head[/yellow];
        [blue]Node*[/blue] [yellow]bestPrev[/yellow] = nullptr;
        [blue]Node*[/blue] [yellow]curr[/yellow] = [yellow]head[/yellow]->[yellow]next[/yellow];
        [blue]Node*[/blue] [yellow]prev[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]curr[/yellow]) {
            [pink]if[/pink] ([yellow]curr[/yellow]->[yellow]priority[/yellow] < [yellow]best[/yellow]->[yellow]priority[/yellow]) {
                [yellow]best[/yellow] = [yellow]curr[/yellow];
                [yellow]bestPrev[/yellow] = [yellow]prev[/yellow];
            }
            [yellow]prev[/yellow] = [yellow]curr[/yellow];
            [yellow]curr[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];
        }
        [pink]if[/pink] ([yellow]bestPrev[/yellow]) [yellow]bestPrev[/yellow]->[yellow]next[/yellow] = [yellow]best[/yellow]->[yellow]next[/yellow];
        [pink]else[/pink] [yellow]head[/yellow] = [yellow]best[/yellow]->[yellow]next[/yellow];
        [pink]int[/pink] [yellow]val[/yellow] = [yellow]best[/yellow]->[yellow]value[/yellow];
        [pink]delete[/pink] [yellow]best[/yellow];
        [pink]return[/pink] [yellow]val[/yellow];
    }
    [pink]bool[/pink] [yellow]isEmpty[/yellow]() {
        [pink]return[/pink] [yellow]head[/yellow] == nullptr;
    }
};

14. Sorted List
ð–¦¹ Keep items always sorted by priority.
ð–¦¹ Insert is slow because we must find the correct place.
ð–¦¹ Remove is fast because the best priority is always stored at one known spot.
â€¢ Insert time: O(n)
â€¢ Delete time: O(1)
- Explanation: The head keeps the best priority element.
ð–¦¹ Useful when deletes happen many times and inserts happen few times.
ð–¦¹ Related code:

[pink]#include[/pink] <iostream>
[pink]using[/pink] [pink]namespace[/pink] std;

[pink]struct[/pink] [yellow]Node2[/yellow] {
    [pink]int[/pink] [yellow]value[/yellow];
    [pink]int[/pink] [yellow]priority[/yellow];
    [blue]Node2*[/blue] [yellow]next[/yellow];
    [pink]Node2[/pink]([pink]int[/pink] v, [pink]int[/pink] p) : [yellow]value[/yellow](v), [yellow]priority[/yellow](p), [yellow]next[/yellow](nullptr) {}
};

[pink]class[/pink] [yellow]SortedPriorityQueue[/yellow] {
[pink]private[/pink]:
    [blue]Node2*[/blue] [yellow]head[/yellow];

[pink]public[/pink]:
    [pink]SortedPriorityQueue[/pink]() : [yellow]head[/yellow](nullptr) {}

    // Insert in sorted order
    [pink]void[/pink] [yellow]enqueue[/yellow]([pink]int[/pink] value, [pink]int[/pink] priority) {
        [blue]Node2*[/blue] [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]Node2[/yellow](value, priority);

        [pink]if[/pink] (![yellow]head[/yellow] || priority < [yellow]head[/yellow]->[yellow]priority[/yellow]) {
            [yellow]newNode[/yellow]->[yellow]next[/yellow] = [yellow]head[/yellow];
            [yellow]head[/yellow] = [yellow]newNode[/yellow];
            [pink]return[/pink];
        }

        [blue]Node2*[/blue] [yellow]curr[/yellow] = [yellow]head[/yellow];
        [pink]while[/pink] ([yellow]curr[/yellow]->[yellow]next[/yellow] && [yellow]curr[/yellow]->[yellow]next[/yellow]->[yellow]priority[/yellow] <= priority) {
            [yellow]curr[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];
        }

        [yellow]newNode[/yellow]->[yellow]next[/yellow] = [yellow]curr[/yellow]->[yellow]next[/yellow];
        [yellow]curr[/yellow]->[yellow]next[/yellow] = [yellow]newNode[/yellow];
    }

    // Remove highest priority
    [pink]int[/pink] [yellow]dequeue[/yellow]() {
        [pink]if[/pink] (![yellow]head[/yellow]) {
            [green]cout[/green] << "Queue empty\n";
            [pink]return[/pink] -1;
        }

        [blue]Node2*[/blue] [yellow]temp[/yellow] = [yellow]head[/yellow];
        [yellow]head[/yellow] = [yellow]head[/yellow]->[yellow]next[/yellow];

        [pink]int[/pink] [yellow]val[/yellow] = [yellow]temp[/yellow]->[yellow]value[/yellow];
        [pink]delete[/pink] [yellow]temp[/yellow];
        [pink]return[/pink] [yellow]val[/yellow];
    }

    [pink]bool[/pink] [yellow]isEmpty[/yellow]() {
        [pink]return[/pink] [yellow]head[/yellow] == nullptr;
    }
};

15. Comparison
Structure   Insert   Delete_best   Notes
Unsorted    O(1)     O(n)          Fast insert, slow delete
Sorted      O(n)     O(1)          Slow insert, fast delete

16. Using Heap
ð–¦¹ It must add new elements fast
ð–¦¹ It must give the most important element fast
ð–¦¹ It must remove the most important element fast
â€¢ push â†’ add an element
â€¢ top â†’ get highest-priority element
â€¢ pop â†’ remove highest-priority element
- Binary heap is used because:
  push = O(log n)
  pop = O(log n)
  top = O(1)

17. How priority queue works inside
ð–¦¹ It is built on top of a binary heap
ð–¦¹ The heap is kept in an array in level order
â€¢ Example max-heap:
  Tree:
         100
       /     \
      50      40
     /  \    /  \
    45  10  20  30
  Array:
  [100, 50, 40, 45, 10, 20, 30]

18. What happens on push()
ð–¦¹ When we do pq., it goes to the end of the array
ð–¦¹ Then â€œbubble-upâ€ runs to fix the heap
â€¢ It swaps with parents until heap rule becomes correct
- Same as heap push

19. What happens on pop()
ð–¦¹ pq.[yellow]pop[/yellow]() removes the root (highest priority)
ð–¦¹ Last element moves to the root
ð–¦¹ Then â€œheapify-down (Percolate Down/Sift Down)â€ runs
â€¢ It swaps with the larger child until heap rule becomes correct
- Same as heap pop

20. What top() does
ð–¦¹ pq.[yellow]top[/yellow]() returns the root element
ð–¦¹ It only reads heap[0]
â€¢ So it is O(1)

21. How C++ implements priority_queue
ð–¦¹ It uses a [green]vector[/green] to store the heap
ð–¦¹ It builds the heap using [green]make_heap[/green]
â€¢ C++ uses:
  [green]push_heap[/green]() â†’ O(log n)
  [green]pop_heap[/green]() â†’ O(log n)
  [green]make_heap[/green]() â†’ O(n)

22. What is a deque
ð–¦¹ A deque (double-ended queue) allows adding/removing elements from both front and back
ð–¦¹ It is like a mix of a queue and a stack
â€¢ All operations work in O(1) time (amortized)

23. Why "double-ended"
ð–¦¹ Normal queue only allows:
â€¢ push at back
â€¢ pop from front
ð–¦¹ Deque allows:
â€¢ push_front(x)
â€¢ push_back(x)
â€¢ pop_front()
â€¢ pop_back()
- Both ends are open for insertion and deletion

24. Visual intuition
ð–¦¹ Think of a line of people
â€¢ People can join from front or back
â€¢ People can leave from front or back
- Front <--- [ A B C D ] ---> Back

25. Operations supported
ð–¦¹ push_front(x) â†’ add x at front
ð–¦¹ push_back(x) â†’ add x at back
ð–¦¹ pop_front() â†’ remove front element
ð–¦¹ pop_back() â†’ remove back element
ð–¦¹ front() â†’ read front element
ð–¦¹ back() â†’ read back element
ð–¦¹ empty() â†’ check if deque is empty
- All O(1) time

26. How a deque is implemented
ð–¦¹ Doubly linked list:
â€¢ Each node has prev + next
â€¢ Easy to add/remove at both ends
- Cache performance is poor
ð–¦¹ Circular array / circular buffer (used in C++):
â€¢ Fixed-size array blocks
â€¢ Head and tail move circularly
â€¢ Very fast and memory-efficient

27. Circular Array (Array-Based) Implementation
ð–¦¹ A deque can be implemented using a fixed-size circular array
ð–¦¹ Maintains front and rear indices and moves them circularly using modulo
â€¢ push_front(x) â†’ move front backward circularly and insert x
â€¢ push_back(x) â†’ move rear forward circularly and insert x
â€¢ pop_front() â†’ move front forward circularly
â€¢ pop_back() â†’ move rear backward circularly
â€¢ getFront() â†’ return arr[front]
â€¢ getBack() â†’ return arr[rear]
- All operations O(1) amortized

#include <iostream>
using namespace std;

[pink]class[/pink] [yellow]Deque[/yellow] {
private:
    [pink]int*[/pink] [yellow]arr[/yellow];
    [pink]int[/pink] [yellow]front[/yellow], [yellow]rear[/yellow], [yellow]size[/yellow], [yellow]capacity[/yellow];

public:
    [pink]Deque[/pink]([pink]int[/pink] [yellow]cap[/yellow]) {
        [yellow]capacity[/yellow] = [yellow]cap[/yellow];
        [yellow]arr[/yellow] = [pink]new[/pink] [pink]int[/pink][[yellow]cap[/yellow]];
        [yellow]front[/yellow] = [yellow]rear[/yellow] = -1;
        [yellow]size[/yellow] = 0;
    }

    [pink]bool[/pink] [yellow]isEmpty[/yellow]() { return [yellow]size[/yellow] == 0; }
    [pink]bool[/pink] [yellow]isFull[/yellow]() { return [yellow]size[/yellow] == [yellow]capacity[/yellow]; }

    [pink]void[/pink] [yellow]push_front[/yellow]([pink]int[/pink] [yellow]x[/yellow]) {
        [pink]if[/pink] ([yellow]isFull[/yellow]()) { cout << "Deque full!\n"; [pink]return[/pink]; }
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) [yellow]front[/yellow] = [yellow]rear[/yellow] = 0;
        [pink]else[/pink] [yellow]front[/yellow] = ([yellow]front[/yellow] - 1 + [yellow]capacity[/yellow]) % [yellow]capacity[/yellow];
        [yellow]arr[/yellow][[yellow]front[/yellow]] = [yellow]x[/yellow];
        [yellow]size[/yellow]++;
    }

    [pink]void[/pink] [yellow]push_back[/yellow]([pink]int[/pink] [yellow]x[/yellow]) {
        [pink]if[/pink] ([yellow]isFull[/yellow]()) { cout << "Deque full!\n"; [pink]return[/pink]; }
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) [yellow]front[/yellow] = [yellow]rear[/yellow] = 0;
        [pink]else[/pink] [yellow]rear[/yellow] = ([yellow]rear[/yellow] + 1) % [yellow]capacity[/yellow];
        [yellow]arr[/yellow][[yellow]rear[/yellow]] = [yellow]x[/yellow];
        [yellow]size[/yellow]++;
    }

    [pink]void[/pink] [yellow]pop_front[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) { cout << "Deque empty!\n"; [pink]return[/pink]; }
        [pink]if[/pink] ([yellow]front[/yellow] == [yellow]rear[/yellow]) [yellow]front[/yellow] = [yellow]rear[/yellow] = -1;
        [pink]else[/pink] [yellow]front[/yellow] = ([yellow]front[/yellow] + 1) % [yellow]capacity[/yellow];
        [yellow]size[/yellow]--;
    }

    [pink]void[/pink] [yellow]pop_back[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) { cout << "Deque empty!\n"; [pink]return[/pink]; }
        [pink]if[/pink] ([yellow]front[/yellow] == [yellow]rear[/yellow]) [yellow]front[/yellow] = [yellow]rear[/yellow] = -1;
        [pink]else[/pink] [yellow]rear[/yellow] = ([yellow]rear[/yellow] - 1 + [yellow]capacity[/yellow]) % [yellow]capacity[/yellow];
        [yellow]size[/yellow]--;
    }

    [pink]int[/pink] [yellow]getFront[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) { cout << "Deque empty!\n"; [pink]return[/pink] -1; }
        [pink]return[/pink] [yellow]arr[/yellow][[yellow]front[/yellow]];
    }

    [pink]int[/pink] [yellow]getBack[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) { cout << "Deque empty!\n"; [pink]return[/pink] -1; }
        [pink]return[/pink] [yellow]arr[/yellow][[yellow]rear[/yellow]];
    }
};

[pink]int[/pink] [yellow]main[/yellow]() {
     ;

     ;
     ;
     ;

    cout << "Front: " << [yellow]dq[/yellow].[yellow]getFront[/yellow]() << "\n";  // 20
    cout << "Back: " << [yellow]dq[/yellow].[yellow]getBack[/yellow]() << "\n";    // 30

    [yellow]dq[/yellow].[yellow]pop_front[/yellow]();
    cout << "Front after pop_front: " << [yellow]dq[/yellow].[yellow]getFront[/yellow]() << "\n"; // 10

    [yellow]dq[/yellow].[yellow]pop_back[/yellow]();
    cout << "Back after pop_back: " << [yellow]dq[/yellow].[yellow]getBack[/yellow]() << "\n";    // 10

    [pink]return[/pink] 0;
}

28. Doubly Linked List Implementation
ð–¦¹ A deque can be implemented using a doubly linked list
ð–¦¹ Each node has prev and next pointers
â€¢ push_front(x) â†’ insert new node at front
â€¢ push_back(x) â†’ insert new node at back
â€¢ pop_front() â†’ remove node from front
â€¢ pop_back() â†’ remove node from back
â€¢ getFront() â†’ return front->data
â€¢ getBack() â†’ return rear->data
- All operations O(1)

#include <iostream>
using namespace std;

[pink]struct[/pink] [yellow]Node[/yellow] {
    [pink]int[/pink] [yellow]data[/yellow];
    [yellow]Node[/yellow]* [yellow]prev[/yellow];
    [yellow]Node[/yellow]* [yellow]next[/yellow];
    [yellow]Node[/yellow]([pink]int[/pink] [yellow]x[/yellow]) : [yellow]data[/yellow]([yellow]x[/yellow]), [yellow]prev[/yellow](nullptr), [yellow]next[/yellow](nullptr) {}
};

[pink]class[/pink] [yellow]Deque[/yellow] {
private:
    [yellow]Node[/yellow]* [yellow]front[/yellow];
    [yellow]Node[/yellow]* [yellow]rear[/yellow];

public:
    [pink]Deque[/pink]() {
        [yellow]front[/yellow] = [yellow]rear[/yellow] = nullptr;
    }

    [pink]bool[/pink] [yellow]isEmpty[/yellow]() { return [yellow]front[/yellow] == nullptr; }

    [pink]void[/pink] [yellow]push_front[/yellow]([pink]int[/pink] [yellow]x[/yellow]) {
        [yellow]Node[/yellow]* [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]Node[/yellow]([yellow]x[/yellow]);
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) [yellow]front[/yellow] = [yellow]rear[/yellow] = [yellow]newNode[/yellow];
        [pink]else[/pink] {
            [yellow]newNode[/yellow]->next = [yellow]front[/yellow];
            [yellow]front[/yellow]->prev = [yellow]newNode[/yellow];
            [yellow]front[/yellow] = [yellow]newNode[/yellow];
        }
    }

    [pink]void[/pink] [yellow]push_back[/yellow]([pink]int[/pink] [yellow]x[/yellow]) {
        [yellow]Node[/yellow]* [yellow]newNode[/yellow] = [pink]new[/pink] [yellow]Node[/yellow]([yellow]x[/yellow]);
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) [yellow]front[/yellow] = [yellow]rear[/yellow] = [yellow]newNode[/yellow];
        [pink]else[/pink] {
            [yellow]rear[/yellow]->next = [yellow]newNode[/yellow];
            [yellow]newNode[/yellow]->prev = [yellow]rear[/yellow];
            [yellow]rear[/yellow] = [yellow]newNode[/yellow];
        }
    }

    [pink]void[/pink] [yellow]pop_front[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) { cout << "Deque empty!\n"; [pink]return[/pink]; }
        [yellow]Node[/yellow]* [yellow]temp[/yellow] = [yellow]front[/yellow];
        [yellow]front[/yellow] = [yellow]front[/yellow]->next;
        [pink]if[/pink] ([yellow]front[/yellow]) [yellow]front[/yellow]->prev = nullptr;
        [pink]else[/pink] [yellow]rear[/yellow] = nullptr;
        [pink]delete[/pink] [yellow]temp[/yellow];
    }

    [pink]void[/pink] [yellow]pop_back[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) { cout << "Deque empty!\n"; [pink]return[/pink]; }
        [yellow]Node[/yellow]* [yellow]temp[/yellow] = [yellow]rear[/yellow];
        [yellow]rear[/yellow] = [yellow]rear[/yellow]->prev;
        [pink]if[/pink] ([yellow]rear[/yellow]) [yellow]rear[/yellow]->next = nullptr;
        [pink]else[/pink] [yellow]front[/yellow] = nullptr;
        [pink]delete[/pink] [yellow]temp[/yellow];
    }

    [pink]int[/pink] [yellow]getFront[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) { cout << "Deque empty!\n"; [pink]return[/pink] -1; }
        [pink]return[/pink] [yellow]front[/yellow]->data;
    }

    [pink]int[/pink] [yellow]getBack[/yellow]() {
        [pink]if[/pink] ([yellow]isEmpty[/yellow]()) { cout << "Deque empty!\n"; [pink]return[/pink] -1; }
        [pink]return[/pink] [yellow]rear[/yellow]->data;
    }
};

[pink]int[/pink] [yellow]main[/yellow]() {
    [yellow]Deque[/yellow] [yellow]dq[/yellow];

     ;
     ;
     ;

    cout << "Front: " << [yellow]dq[/yellow].[yellow]getFront[/yellow]() << "\n";  // 20
    cout << "Back: " << [yellow]dq[/yellow].[yellow]getBack[/yellow]() << "\n";    // 30

    [yellow]dq[/yellow].[yellow]pop_front[/yellow]();
    cout << "Front after pop_front: " << [yellow]dq[/yellow].[yellow]getFront[/yellow]() << "\n"; // 10

    [yellow]dq[/yellow].[yellow]pop_back[/yellow]();
    cout << "Back after pop_back: " << [yellow]dq[/yellow].[yellow]getBack[/yellow]() << "\n";    // 10

    [pink]return[/pink] 0;
}

--END--