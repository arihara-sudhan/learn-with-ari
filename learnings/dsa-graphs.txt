--BEGIN--02/12/2025--GRAPHS--
1. Graph
ğ–¦¹ A graph has two sets: vertices V and edges E.
ğ–¦¹ An edge is a pair (v, w). If the pair has order, the graph is directed.
ğ–¦¹ In a directed graph, (v, w) means w is next to v. In undirected graphs, (v, w) and (w, v) mean both are next to each other.
ğ–¦¹ An edge can also have a weight or cost.
â €â €â €â €â €â €â €â¢€â£ â£¤â£¤â£„â£€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â¡´â£Ÿâ£¯â¡·â£¿â¡½â£Ÿâ£·â¡€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â¢€â¢„â¢„â¢€â ™â¢¯â£¿â »â ™â “â €â¢€â¢€â¡€â¡€â €â €â €â €â €â €â €â €â €â €â£€â£ â£ â£€â €â €â €â €â €â €
â €â €â €â €â €â ¸â¡¸â¡¸â¡¸â €â¢€â£ â£´â£¾â£»â£Ÿâ£¿â£»â£Ÿâ£¿â£»â£Ÿâ£·â£¶â£¤â£„â¡€â €â °â£Ÿâ£¯â£¿â£½â£¯â¡¿â£†â €â €â €â €
â €â €â €â €â €â €â £â ƒâ£ â¡¾â£Ÿâ£¯â¡·â£¿â£½â£¯â£¿â£½â£¯â£¿â£½â£¯â¡·â£¿â¢¾â£¯â¡¿â£·â£¦â¡ˆâ ³â¢¿â¢¾â ³â ›â ™â ‚â €â €â €
â €â €â €â €â €â €â¢€â£´â£Ÿâ£¿â¢¯â£¿â£»â£½â¡¾â£·â¢¿â¡¾â£·â¢¿â¡¾â£·â£Ÿâ£¿â£»â¡·â£Ÿâ£¿â¢¾â¡¿â£†â ˆâ¢€â¢”â¢”â¢²â ‚â €â €â €
â €â €â €â €â €â¢€â£¾â£¯â¡¿â£¾â£»â£½â¢¿â£¾â£»â£Ÿâ£¿â£»â£Ÿâ£¿â£»â£¯â£¿â£½â£¯â£¿â£»â£½â£Ÿâ£¿â£»â£·â €â¢±â¢±â ‘â â €â €â €
â €â €â €â €â €â¢¼â¡·â£¿â¡½â£¿â£½â¢¾â£¿â£½â£¯â£¿â£½â£¯â£¿â£½â£¯â¡·â£¿â¢¾â¡·â£¿â£½â¡·â£¿â£½â£Ÿâ£¾â£‡â €â €â €â €â €â €â €
â €â €â €â €â¢€â£¿â£»â£½â¢¿â£½â£¾â£»â¢·â¡¿â£¾â¢·â¡¿â£¾â¢·â¡¿â£¾â£Ÿâ£¿â£»â£Ÿâ£¿â¢¾â£Ÿâ£¿â¢¾â£¯â£·â¢¿â¡€â €â €â €â €â €â €
â €â €â €â €â¢â£¿â£½â¢¾â£»â£·â ‹â ‰â ‰â¢»â£Ÿâ£¿â£»â£Ÿâ£¿â£»â£¯â£¿â£½â£¯â ¿â ½â¢»â£¯â£¿â£»â¡·â£¿â£»â¡‚â €â €â €â €â €â €
â €â €â €â €â â£¿â¢¾â£¿â£½â¢¾â¡€â €â €â£°â£¿â£½â£¿â Ÿâ ›â¢¿â£·â¡¿â£â ‡â €â €â ˆâ£·â¢¿â£½â£Ÿâ£¿â£½â ‚â €â €â €â €â €â €
â €â €â €â €â €â¢¹â£Ÿâ£·â¢¿â£»â£Ÿâ£¯â¡¿â£¯â£¿â£¿â ¿â ‚â €â¢¾â£¿â£¿â¡¿â£·â£¤â ¤â â ›â «â¢·â¡¿â£½â¡â €â €â €â €â €â €â €
â €â €â €â €â €â €â ™â£¿â£»â£½â£¯â£·â¢¿â£¯â£¿â£¯â£¤â£¶â£§â£„â£¼â£¿â£Ÿâ£¿â â¢ â¡ºâ¡¿â£¦â ˆâ£¿â¡¯â ƒâ €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â ‘â ¿â¢¾â£¯â¡¿â£·â¢¿â£¾â£»â£Ÿâ£¿â£»â£¯â¡·â¡¿â ™â£â£¸â¡»â£¿â£â¡€â ™â â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â ˆâ¢‰â ‰â ‹â “â »â ½â ¯â ·â »â ½â €â£¼â£â Ÿâ »â£¾â£®â¡»â¡·â£¦â£€â¢¤â¢¤â¡€â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â£¿â£»â£Ÿâ£·â¢¶â£–â£†â €â ’â €â â£â£Ÿâ¢§â¢´â â¢»â¢¿â¢¿â£®â£»â¡»â¡·â â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â¢€â£¿â£½â£¯â¢¿â£»â£½â£¯â¡¿â£¿â¢¶â¡€â ˆâ »â£·â£¤â¡‚â¢¸â£·â£€â£¸â¡»â¡‡â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â °â£¿â£â£¯â£¿â£»â¡šâ ³â ¿â¡»â ¿â â£¸â¡¢â£„â ‰â »â ·â£·â£â¡Ÿâ Ÿâ €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â ¨â£¿â¢¾â£·â£»â£½â£·â£¶â¡†â¢€â¢¶â£®â£¯â¡»â£®â£Ÿâ£–â¢¦â£„â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â ¨â£¿â¢¯â¡·â£Ÿâ£·â¢¿â£½â£‡â£ˆâ£â£„â ™â »â¢¾â£®â ƒâ €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â ¹â£Ÿâ£¿â ¤â €â €â €â ˆâ €â €â €â ¸â¡€â ™â â €â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â ˆâ ˆâ €â €â €â €â €â €â €â €â €â €â €
2. Paths
ğ–¦¹ A path is a sequence of vertices w1, w2, â€¦, wN where each pair (wi, wi+1) is an edge.
ğ–¦¹ Path length = number of edges = N âˆ’ 1.
ğ–¦¹ A path from a vertex to itself with no edges has length 0.
ğ–¦¹ A loop is an edge like (v, v). We usually avoid loops.
ğ–¦¹ A simple path has all different vertices (first and last may match).

3. Cycles
ğ–¦¹ A cycle in a directed graph is a path with length â‰¥ 1 where first and last vertices are the same.
ğ–¦¹ A simple cycle has all distinct vertices except first and last.
ğ–¦¹ In undirected graphs, edges in the cycle must be different.
ğ–¦¹ A directed graph with no cycles is acyclic (DAG).

4. Connectivity
ğ–¦¹ An undirected graph is connected if every vertex can reach every other.
ğ–¦¹ A directed graph is strongly connected if every vertex can reach every other with direction.
ğ–¦¹ If it is not strongly connected but becomes connected when ignoring direction, it is weakly connected.
ğ–¦¹ A complete graph has an edge between every pair of vertices.

5. Graph Representations
IMG_URL directed_g.png
ğ–¦¹ Graph has 7 vertices and 13 edges
ğ–¦¹ Edges: 1â†’2, 1â†’3, 1â†’4, 2â†’4, 2â†’5, 3â†’4, 3â†’6, 4â†’6, 4â†’7, 5â†’4, 5â†’7, 6â†’7, 7â†’6

6. Adjacency Matrix
ğ–¦¹ Rows = source vertex, Columns = target vertex
ğ–¦¹ 1 = edge exists, 0 = no edge
ğ–¦¹ Table:
      1 2 3 4 5 6 7
1     0 1 1 1 0 0 0
2     0 0 0 1 1 0 0
3     0 0 0 1 0 1 0
4     0 0 0 0 0 1 1
5     0 0 0 1 0 0 1
6     0 0 0 0 0 0 1
7     0 0 0 0 0 1 0

7. Adjacency List
ğ–¦¹ Each vertex stores a list of neighbors
ğ–¦¹ List:
1: 2, 3, 4
2: 4, 5
3: 4, 6
4: 6, 7
5: 4, 7
6: 7
7: 6

8. Incidence Matrix
ğ–¦¹ Rows = vertices, Columns = edges (e1 to e13)
ğ–¦¹ Use -1 for edge start, +1 for edge end, 0 otherwise
ğ–¦¹ Table:
	e1	e2	e3	e4	e5	e6	e7	e8	e9	e10	e11	e12	e13
1	-1	-1	-1	0	0	0	0	0	0	0	0	0	0
2	1	0	0	-1	-1	0	0	0	0	0	0	0	0
3	0	1	0	0	0	-1	0	0	0	0	0	0	0
4	0	0	1	1	0	1	-1	-1	0	0	0	0	0
5	0	0	0	0	1	0	0	1	0	0	0	0	0
6	0	0	0	0	0	0	1	0	-1	0	0	0	0
7	0	0	0	0	0	0	0	0	1	-1	0	0	0
ğ–¦¹ Column meaning: e1=1â†’2, e2=1â†’3, e3=1â†’4, e4=2â†’4, e5=2â†’5, e6=3â†’4, e7=3â†’6, e8=4â†’6, e9=4â†’7, e10=5â†’4, e11=5â†’7, e12=6â†’7, e13=7â†’6

9. Compressed Sparse Row (CSR)
ğ–¦¹ Step 1: List edges per vertex (values, columns)
â€¢ Vertex 1 â†’ 2, 3, 4
â€¢ Vertex 2 â†’ 4, 5
â€¢ Vertex 3 â†’ 4, 6
â€¢ Vertex 4 â†’ 6, 7
â€¢ Vertex 5 â†’ 4, 7
â€¢ Vertex 6 â†’ 7
â€¢ Vertex 7 â†’ 6
ğ–¦¹ Step 2: values = [1,1,1, 1,1, 1,1, 1,1, 1,1, 1,1]  # 13 edges
ğ–¦¹ Step 3: columns = [2,3,4, 4,5, 4,6, 6,7, 4,7, 7,6]
ğ–¦¹ Step 4: row_ptr = [0, 3, 5, 7, 9, 11, 12, 13]
â€¢ Vertex 1 edges â†’ indices 0:3 â†’ 3 edges
â€¢ Vertex 2 edges â†’ indices 3:5 â†’ 2 edges
â€¢ Vertex 3 edges â†’ indices 5:7 â†’ 2 edges
â€¢ Vertex 4 edges â†’ indices 7:9 â†’ 2 edges
â€¢ Vertex 5 edges â†’ indices 9:11 â†’ 2 edges
â€¢ Vertex 6 edges â†’ indices 11:12 â†’ 1 edge
â€¢ Vertex 7 edges â†’ indices 12:13 â†’ 1 edge

10. Adjacency Matrix
ğ–¦¹ Structure: VÃ—V matrix
ğ–¦¹ Space: O(VÂ²)
â€¢ Reason: store 0 for every missing edge
ğ–¦¹ Time:
â€¢ Check edge (u,v) â†’ O(1)
â€¢ Iterate neighbors of vertex â†’ O(V)
â€¢ Iterate all edges â†’ O(VÂ²)
ğ–¦¹ Summary:
â€¢ Space: O(VÂ²)
â€¢ Check edge: O(1)
â€¢ Iterate neighbors: O(V)
â€¢ Iterate all edges: O(VÂ²)

11. Adjacency List
ğ–¦¹ Structure: Array or list of lists; each vertex stores outgoing neighbors
ğ–¦¹ Space: O(V + E)
â€¢ Reason: pointers for V vertices + E edges
ğ–¦¹ Time:
â€¢ Check edge (u,v) â†’ O(degree(u)) worst-case O(V)
â€¢ Iterate neighbors â†’ O(degree(u))
â€¢ Iterate all edges â†’ O(V + E)
ğ–¦¹ Summary:
â€¢ Space: O(V + E)
â€¢ Check edge: O(degree(u))
â€¢ Iterate neighbors: O(degree(u))
â€¢ Iterate all edges: O(V + E)

12. Incidence Matrix
ğ–¦¹ Structure: VÃ—E matrix; row = vertex, column = edge, values -1,0,1
ğ–¦¹ Space: O(VÃ—E)
â€¢ Reason: stores outgoing and incoming info
ğ–¦¹ Time:
â€¢ Check edge (u,v) â†’ O(E)
â€¢ Iterate neighbors â†’ O(E)
â€¢ Iterate all edges â†’ O(VÃ—E)
ğ–¦¹ Summary:
â€¢ Space: O(VÃ—E)
â€¢ Check edge: O(E)
â€¢ Iterate neighbors: O(E)
â€¢ Iterate all edges: O(VÃ—E)

13. Compressed Sparse Row (CSR)
ğ–¦¹ Structure:
â€¢ values â†’ store edges (size E)
â€¢ columns â†’ target vertices (size E)
â€¢ row_ptr â†’ start index of each vertex (size V+1)
ğ–¦¹ Space: O(V + E)
â€¢ Reason: values + columns = 2E, row_ptr = V+1
ğ–¦¹ Time:
â€¢ Check edge (u,v) â†’ O(degree(u))
â€¢ Iterate neighbors â†’ O(degree(u))
â€¢ Iterate all edges â†’ O(E)
ğ–¦¹ Summary:
â€¢ Space: O(V + E)
â€¢ Check edge: O(degree(u))
â€¢ Iterate neighbors: O(degree(u))
â€¢ Iterate all edges: O(E)

14. Quick Comparison
ğ–¦¹ Adjacency Matrix: Space O(VÂ²), Edge check O(1), Neighbors O(V), All edges O(VÂ²)
ğ–¦¹ Adjacency List: Space O(V+E), Edge check O(deg(u)), Neighbors O(deg(u)), All edges O(V+E)
ğ–¦¹ Incidence Matrix: Space O(VÃ—E), Edge check O(E), Neighbors O(E), All edges O(VÃ—E)
ğ–¦¹ CSR: Space O(V+E), Edge check O(deg(u)), Neighbors O(deg(u)), All edges O(E)

15. Degree in a Graph
ğ–¦¹ Degree of a vertex = number of edges connected to it
ğ–¦¹ In undirected graphs, each edge counts for both connected vertices
ğ–¦¹ In directed graphs:
â€¢ In-degree = number of edges coming into the vertex
â€¢ Out-degree = number of edges going out from the vertex

16. Examples
ğ–¦¹ Directed Graph: Edges 1â†’2, 1â†’3, 2â†’3
â€¢ Vertex 1: Out-degree = 2, In-degree = 0
â€¢ Vertex 2: Out-degree = 1, In-degree = 1
â€¢ Vertex 3: Out-degree = 0, In-degree = 2
ğ–¦¹ Undirected Graph: Edges 1â€”2, 1â€”3, 2â€”3
â€¢ Vertex 1 degree = 2
â€¢ Vertex 2 degree = 2
â€¢ Vertex 3 degree = 2

17. Importance of Degree
ğ–¦¹ Shows how connected a vertex is
ğ–¦¹ Used in algorithms:
â€¢ Topological sort â†’ uses in-degree in directed graphs
â€¢ Euler path/cycle â†’ degree conditions decide existence
â€¢ Graph traversal â†’ vertices with higher degree may take longer to explore
--END--
--BEGIN--02/12/2025--TOPOLOGICAL SORT--
18. Topological Sort
ğ–¦¹ If there is an edge uâ†’v, then u must come before v in the order
ğ–¦¹ Works only for graphs with no cycles (DAGs)
â€¢ A cycle makes the order impossible because each node depends on another in a loop

19. Basic Idea
ğ–¦¹ Nodes with no incoming edges are the starting points
ğ–¦¹ Pick all zero-indegree nodes first
ğ–¦¹ After picking a node, remove it and its outgoing edges
â€¢ This may create new zero-indegree nodes
ğ–¦¹ Repeat until all nodes are processed or no zero-indegree node is left
ğ–¦¹ If nodes remain but none have indegree 0, a cycle exists and no valid order is possible
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/graphs/topological_sort_bruteforce.cpp

20. Kahnâ€™s Algorithm (BFS Style)
ğ–¦¹ Count indegree of each node once
ğ–¦¹ Put all zero-indegree nodes into a queue
ğ–¦¹ Remove nodes from queue one by one
â€¢ Reduce indegree of their neighbors
â€¢ When a neighborâ€™s indegree becomes zero, add it to the queue
ğ–¦¹ If all nodes are removed, order is valid; else, there is a cycle
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/graphs/topological_sort_khan.cpp

--END--
--BEGIN--02/12/2025--BFS AND DFS--
21. BFS
ğ–¦¹ BFS = Breadth-First Search; explores graph level by level like waves
ğ–¦¹ Start at one node:
â€¢ First explore nodes 1 step away
â€¢ Then nodes 2 steps away
â€¢ Then 3 steps away, and so on
ğ–¦¹ Finish one layer before moving to next
ğ–¦¹ BFS grows outward like ripples

22. Why Use a Queue
ğ–¦¹ Queue gives first-come, first-served order
ğ–¦¹ When a node is discovered, add to back
ğ–¦¹ When processing, take from front
ğ–¦¹ Ensures earliest discovered nodes are processed first â†’ level by level
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/graphs/bfs.cpp

23. What BFS Provides
ğ–¦¹ Order of node visits
ğ–¦¹ Shortest path in number of edges from start node
ğ–¦¹ Checks if graph is connected
â€¢ If some nodes are not reached, graph has unreachable parts

24. When BFS is Used
ğ–¦¹ Shortest path problems with equal edge weight
ğ–¦¹ Social networks (find people at distance 1,2,3â€¦)
ğ–¦¹ Level-order tree traversal
ğ–¦¹ Solving puzzles (Rubikâ€™s cube, sliding puzzles)
ğ–¦¹ Routing and networking

25. BFS Complexity
ğ–¦¹ Time = O(V + E)
ğ–¦¹ Space = O(V) (for queue and visited nodes)

26. DFS
ğ–¦¹ DFS = Depth-First Search; explores graph deep along a path before backtracking
ğ–¦¹ Like walking in a maze:
â€¢ Pick a path and follow it as far as possible
â€¢ If dead end, backtrack to previous junction
â€¢ Repeat until all paths explored

27. How DFS Works
ğ–¦¹ Start at a node and mark it visited
ğ–¦¹ Pick one unvisited neighbor and explore recursively
ğ–¦¹ Backtrack when no more unvisited neighbors
ğ–¦¹ Repeat until all reachable nodes are visited
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/graphs/dfs.cpp

28. Why a Stack is Used
ğ–¦¹ DFS can use recursion (call stack) or an explicit stack
ğ–¦¹ Stack remembers current path for correct backtracking
--EMBED-GIT--
https://github.com/arihara-sudhan/dsa/blob/main/data-structures/graphs/dfs_stack.cpp

29. What DFS Provides
ğ–¦¹ Order of nodes visited (depth-first)
ğ–¦¹ Can detect cycles
ğ–¦¹ Can classify edges: tree, back, forward, cross
ğ–¦¹ Helps in connected components, checking paths, and solving puzzles

30. DFS Complexity
ğ–¦¹ Time = O(V + E)
ğ–¦¹ Space = O(V) (for recursion stack or explicit stack)
--END--
--BEGIN--02/12/2025--SHORTEST PATH--
1. Shortest Path Problems
ğ–¦¹ A network of cities connected by roads can have costs like distance, time, or money
ğ–¦¹ A path = sequence of connected roads from one city to another
ğ–¦¹ Weighted path length = sum of all road costs
ğ–¦¹ Unweighted path length = number of roads only
ğ–¦¹ Single-source shortest path = find cheapest route from one city to all others
ğ–¦¹ Useful in real life:
â€¢ Sending data over networks
â€¢ Planning flight/train routes
â€¢ GPS navigation

2. Unweighted Shortest Path
ğ–¦¹ All roads considered equal or we care only about number of roads
ğ–¦¹ Start from source city, visit cities 1 road away, then 2 roads away, and so on
ğ–¦¹ Uses BFS:
â€¢ Start at source, distance = 0
â€¢ Visit neighbors, distance = 1
â€¢ Visit neighbors of neighbors, distance = 2
â€¢ Repeat until all reachable cities are visited
ğ–¦¹ Distance recorded is guaranteed shortest in terms of number of roads
ğ–¦¹ Time Complexity = O(V + E), Space Complexity = O(V)

3. Weighted Shortest Path
ğ–¦¹ Roads have different costs (weights)
ğ–¦¹ Positive weights only â†’ use Dijkstraâ€™s algorithm
â€¢ Pick city with smallest known cost, update neighbors
ğ–¦¹ Negative weights allowed â†’ use Bellman-Ford algorithm
â€¢ Handles negative cycles, but shortest path may not exist if negative cycle exists
ğ–¦¹ Useful for:
â€¢ Roads with tolls or different travel times
â€¢ Optimizing network traffic with varying link costs
â€¢ Scheduling tasks with dependencies and costs
ğ–¦¹ Time & Space Complexity:
â€¢ Dijkstra (with min-heap) â†’ Time O((V+E) log V), Space O(V)
â€¢ Bellman-Ford â†’ Time O(VE), Space O(V)
--END--